<!doctype html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="/dnh-blog/statinamic-client.9fa5f875c60ab7ceab65.css" /><meta data-react-helmet="true" property="og:site_name" content="Dạy nhau học Blog"/><meta data-react-helmet="true" name="twitter:site" content="@johndoe"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" property="og:title" content="Struct là gì? bản chất và cách sử dụng"/><meta data-react-helmet="true" property="og:url" content="/struct-la-gi-ban-chat-va-cach-su-dung/"/><meta data-react-helmet="true" property="og:description" content="Sử dụng struct trong chương trình

OHM, lần trước chúng ta đã bàn về [Đệ Quy][1] rồi, bây giờ chúng ta lại quay về vấn đề cơ bản của ngôn…"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:title" content="Struct là gì? bản chất và cách sử dụng"/><meta data-react-helmet="true" name="twitter:creator" content="@undefined"/><meta data-react-helmet="true" name="twitter:description" content="Sử dụng struct trong chương trình

OHM, lần trước chúng ta đã bàn về [Đệ Quy][1] rồi, bây giờ chúng ta lại quay về vấn đề cơ bản của ngôn…"/><meta data-react-helmet="true" name="description" content="Sử dụng struct trong chương trình

OHM, lần trước chúng ta đã bàn về [Đệ Quy][1] rồi, bây giờ chúng ta lại quay về vấn đề cơ bản của ngôn…"/><title data-react-helmet="true">Struct là gì? bản chất và cách sử dụng</title><link data-react-helmet="true" rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Condensed:400,400italic,700,700italic|Open+Sans:300|Roboto+Slab:400,300&amp;subset=latin,vietnamese"/><link data-react-helmet="true" rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css"/></head><body><div id="statinamic"><div data-reactroot="" data-reactid="1" data-react-checksum="1594603886"><!-- react-empty: 2 --><div class="_14ntp" data-reactid="3"><div data-reactid="4"><div data-reactid="5"><!-- react-empty: 6 --><a class="DiFw-" href="/dnh-blog/" data-reactid="7">← Trang chủ</a><div class="_3ISzd" data-reactid="8"><div class="cmhKZ" data-reactid="9"><h1 data-reactid="10">Struct là gì? bản chất và cách sử dụng</h1><div data-reactid="11"><h2 id="s-dng-struct-trong-chng-trnh"><a href="#s-dng-struct-trong-chng-trnh" class="statinamic-HeadingAnchor">#</a>Sử dụng struct trong chương trình</h2>
<p>OHM, lần trước chúng ta đã bàn về <a href="http://daynhauhoc.com/t/de-quy-dich-boi-breakdown/5719">Đệ Quy</a> rồi, bây giờ chúng ta lại quay về vấn đề cơ bản của ngôn ngữ: STRUCT.<br>
Trong bài này mình sẽ  bàn về những vấn đề cơ bản nhất về struct và kèm theo những ví dụ cũng cơ bản không kém. Do bài dài nên mình không đủ thời gian dịch và update hằng ngày nên mọi người bookmark lại và đọc theo ngày nhé.<br>
Bây giờ hãy mở đầu Struct bằng một ví dụ minh họa bên dưới nhé:</p>
<pre><code>#include  &lt;iostream&gt;
using namespace std;
struct inflatable
{
    char name[20];
    float volume;
    double price;
};

int main()
{
    inflatable guest =
    {
        &quot;Glorious Gloria&quot;,    //namevalue
        1.88,                //volum value
        29.99                //price value
    };                        //guest is  structure variable of  type inflatable
    inflatable pal =
    {
        &quot;Audacious Arthur&quot;,
        3.12,
        32.99
    };                        //pal is second variable of  type inflatable
    //Note: som implementations require using static  inflatable guest =
    cout &lt;&lt; &quot;Expand your guest  list with &quot; &lt;&lt; guest.name;
    cout &lt;&lt; &quot; and &quot; &lt;&lt; pal.name &lt;&lt; endl;
    //pal.name is  the name member of the pal variable
    cout &lt;&lt; &quot;You can have both for $&quot; &lt;&lt; guest.price + pal.price &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>Code mình build bằng Visual 2013 nên nếu  những ai build bằng IDE khác thì có thể thay đổi chút ít để phù hợp, và dưới đây là kết quả của đoạn code trên:</p>
<blockquote>
<p>Expand your gues list with Glorious Gloria and Audacious Arthur!<br>
You can have both for $62.98!</p>
</blockquote>
<p><strong>Lưu ý về chương trình</strong><br>
Một điều cực kỳ tối quan trọng là cách mà bạn khai báo dữ liệu Struct trong ví dụ trên. Có hai lựa chọn cho chương trình structur.cpp. Bạn có thể đặt khai báo bên trong hàm main() và ngoài hàm. Và bạn cũng nên nhớ rằng struct chúng ta cũng có thể gọi nó là 1 kiểu dữ liệu được định nghĩa riêng. Điều này cũng có nghĩa rằng nó cũng có dạng “Biến nội bộ” và “Biến toàn cục”. Dựa vào vị trí đặt của Struct thì chúng ta có thể suy ra đươc biến Struct này là biến nội bộ hay biến toàn cục. Tùy vào vị trí đặt Struct thì chúng ta có cách sử  dụng khác nhau<br>
Notice: Trong bài này mình tạm gọi Struct là 1 biến để ngắn gọn nhé.<br>
Biến Struct toàn cục: là loại biến đặt bên ngoài hàm, được khai báo sau khi khai báo thư viện và namspace, loại biến này sử dụng được cho mọi hàm trong chương trình và chúng ta gọi tên tiếng anh mĩ miều là external declaration<br>
Biến Struct cục bộ: là loại biến được đặt bên trong hàm, được khai báo trong 1 hàm cố định và không được truy xuất bởi hàm khác, nói cách khác đó là biến chỉ sử dụng được bởi các funtion đặt chung dấu {} với nó.</p>
<p>Ví dụ</p>
<pre><code>int main()
{
    struct ID
    {
        int a;
        int b;
    };
}
</code></pre>
<p>Như các bạn thấy đấy, Struct cũng được máy tính đối xử như 1 biến vậy, nó có thể được khai báo cục bộ hoặc toàn cục. Với cách khai báo toàn cục thì nó có thể được sử dụng bởi tất cả các hàm.<br>
Quay trở lại với ngôn ngữ C++, ngôn ngữ này không khuyến khích sử dụng biến toàn cục (external variable) nhưng nó khuyến khích sử dụng các struct extenal variable (có thể gọi là cấu trúc toàn cục).</p>
<p>Bây giờ chúng ta lại nhìn cách mình sử dụng struct bênt trên. Cách mà mình khởi tạo 1 biến:</p>
<pre><code>inflatable guest = 
{ 
    &quot;Glorious Gloria&quot;,    //namevalue
    1.88,                //volum value
    29.99                //price value
};    
</code></pre>
<p>Giống như cách bạn truyền tham số vào một mảng, bạn cần để trong một dấu {} và cách nhau bởi một dấuphẩy. Mỗi giá trị được đặt trong một dòng. Tuy nhiên bạn có thể đặt tất  cả vào cùng 1 dòng mà không xảy ra lỗi. Nhưng nhớ rằng phải ngăn cách chúng bằng dấu phẩy, đó là quy tắc nếu bạn không muốn gặp lỗi khi compile bằng bất cứ complier nào.</p>
<pre><code>Inflatable duck = {“daphne”, 0.12, 9.98};
</code></pre>
<p>Bạn có  thể khởi tạo mỗi  giá trị của struct bằng các kiểu dữ liệu  thích hợp. Trong ví dụ mình khái báo bên trên, biến name mình đã khai báo một mãng kiểu char, nhưng nếu sử dụng C++ thì bạn có thể khai báo  kiểu string, điều này không ảnh hưởng tới cách mà chương trình  chạy.</p>
<p>Mỗi giá trị của Struct được đối xử như là một biến của kiểu dữ liệu. Như vậy, khi ta sử dụng biến pal.price thì đây là một biến kiểu double và pal.name là một kiểu char[]. Và khi mà ta sử dụng lệnh cout để xuất dữ liệu ra màn hình với biến pal.name thì máy tính sẽ tự động chọn kiểu string (hay char[]). Cũng như thế, pal.name cũng là một mảng ký tự và chúng ta có thể sử dụng nó như là một mảng. Khi bạn truy xuất giá trị tại pal.name[0] thì bạn sẽ nhận được một giá tị ‘A’, nhưng khi bạn truy xuất pal[0] thì nó hoàn toàn vô nghĩa bởi vì pal là một struct chứ không phải là một mảng(array).</p>
<hr>
<h2 id="khai-bo-struct-trong-c-11"><a href="#khai-bo-struct-trong-c-11" class="statinamic-HeadingAnchor">#</a>KHAI BÁO STRUCT TRONG C++ 11</h2>
<hr>
<p>Giống như mảng, C++11 mở rộng cách mà ta có thể khai báo và sử dụng struct một cách linh hoạt. Thay vì chúng ta cần phải sử dụng dấu “=” thì nay chúng ta có thể quên nó đi.</p>
<pre><code>Inflatable duck {“daphne”, 0.12, 9.98};
</code></pre>
<p>Tiếp theo, mỗi thành phần chưa được gán trị  thay vì nó sẽ là một giá trị rác thì nay mặc định sẽ là 0. Ví dụ, khi mà khai báo một biến có kiểu inflatable mayor thì giá trị ta nhận về khi truy xuất mayor.price hay mayor.volume sẽ  là  0.<br>
Tuy nhiên ta có mayor.name được định nghĩa là  một  mảng ký tự thì tất cả các byte trong mảng mayor.name sẽ được đặt là 0 (hoặc  gọi cách khác đây là ký tự NULL).<br>
Cách mà ta khai báo biến mayor để có các giá trị trên là:</p>
<pre><code>Inflatable mayor{};
</code></pre>
<h2 id="liu-struct-c-th-s-dng-c-class-string-khng"><a href="#liu-struct-c-th-s-dng-c-class-string-khng" class="statinamic-HeadingAnchor">#</a>LIỆU STRUCT CÓ THỂ SỬ DỤNG ĐƯỢC CLASS STRING KHÔNG?</h2>
<p>Liệu chúng ta có thể dùng các đối tượng bên trong Class String để sử dụng cho mảng ký tự name? Tất nhiên, bạn có thể khai báo một structure giống thế này:</p>
<pre><code>struct inflatable
{
    std::string name;
    float volume;
    double price;
};
</code></pre>
<p>Tất nhiên câu trả lời là có thể rồi trừ khi bạn đang sử dụng một IDE hay compiler bản cũ hoặc đã lỗi thời từ lâu thì nó không được hỗ trợ khai báo structure với class string.</p>
<p>Hãy chắc chắn rằng structure bạn khai báo có quyền truy cập vào namespace std. Bạn có thể khai báo sau khi khai báo thư viện hoặc trong khi khai báo struct như cách mà mình làm bên trên, sử  dụng: std: :string</p>
<h2 id="mt-s-thuc-tnh-khc-ca-struct"><a href="#mt-s-thuc-tnh-khc-ca-struct" class="statinamic-HeadingAnchor">#</a>MỘT SỐ THUỘC TÍNH KHÁC CỦA STRUCT</h2>
<p>C++ tạo cho người dùng một môi trường đơn giản nhất có thể để sử dụng “built-in-type”. Ví dụ,  bạn có thể  sử  dụng cấu trúc như là một đối số, và bạn có thể sử dụng structure  như một kiểu dữ liệu của hàm  và return giá trị của  structure đó. Tất nhiên bạn có thể sử dụng các operator (=)  để gán một giá trị của struct cho một biến khác cùng với kiểu đã khai báo. Ví dụ:<br>
<br>
char[50] palprice = pal.prices;</p>
<p>Như chúng ta  thấy  đấy, các “member” được khai báo trong struct cũng được đối  xử như là một variable. Bây giờ chúng ta hãy xem ví  dụ tiếp theo bên dưới</p>
<pre><code>#include  &lt;iostream&gt;
using namespace std;
struct inflatable
{
    char name[20];
    float volume;
    double price;
};

int main()
{
    inflatable bouquet =
    {
        &quot;sunflower&quot;,
        0.20,
        12.49
    };
    inflatable pal =
    {
        &quot;Audacious Arthur&quot;,
        3.12,
        32.99
    };
    inflatable choice;
    cout &lt;&lt; &quot;bouquet: &quot; &lt;&lt; bouquet.name &lt;&lt; &quot;for $&quot; &lt;&lt; bouquet.price &lt;&lt; endl;
    choice = bouquet;
    cout &lt;&lt; &quot;choice: &quot; &lt;&lt; choice.name &lt;&lt; &quot;for $&quot; &lt;&lt; choice.price &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>Và đây là kết quả của đoạn code bên trên:</p>
<blockquote>
<p>Bouquet: sunflower for $12.49<br>
Choice: sunflower for $12.49</p>
</blockquote>
<p>Như bạn đã thấy, cả hai giá trị của Bouquet và Choice đều bằng nhau. Bạn có thể phối hợp định nghĩa 1 cấu trúc và gán thẳng variable cho nó. Để làm được việc này, bạn khai báo thẳng variable sau khi khai báo một struct</p>
<pre><code>truct perks
{
    int key_number;
    char car[12];
} mr_smith, ms_jones;
</code></pre>
<p>Mặc dù cách này vẫn giúp chương trình hoạt động bình thường, tuy nhiên các lập trình viên đều chia ra vì viết giống vậy rất khó để theo dõi chương trình và sửa lỗi.</p>
<p>Một cách khác là bạn có thể tạo dựng 1 struct không tên và gọi một variable sau khi đã định nghĩa xong struct. Như ví dụ dưới đây:</p>
<pre><code>struct perks
{
    int key_number;
    char car[12];
} mr_glitz =
{
    7,
    &quot;Packard&quot;
};
</code></pre>
<p>Trong đoạn code này:</p>
<pre><code>struct
{
    int x;
    int y;
} position;
</code></pre>
<p>Chương trình sẽ tạo dựng một biến struct và gọi nó là position. Bạn có thể truy xuất các “member” của position bằng “membership operation”, ví dụ như là  position.x, nhưng nếu bạn sử  dụng cách khai báo này thì bạn sẽ chỉ có duy nhất một biên postion có thể sử dụng struct này. Và sau đó bạn không thể tạo một biến khác có thể sử dụng chung struct như thế. Nói cách khác, biến position là đặc biệt.</p>
<h2 id="mng-struct"><a href="#mng-struct" class="statinamic-HeadingAnchor">#</a>MẢNG STRUCT</h2>
<p>Trong struct inflatable được định nghĩa ở đầu  bàu có chứa một mảng (char name[]). Nó cũng có khả năng tạo mảng mà  các phần tử là struct. Kỹ thuật để tạo nên một mảng kiểu struct chính là cách mà ta hay sử dụng để tạo 1 mảng của 1 kiểu dữ liệu nào đó.</p>
<pre><code>Inflatable gifts[100]; // array of 100  inflatable structures
</code></pre>
<p>Đây là dòng lệnh để tạo ra một mảng có 100 phần tử kiểu &gt; <code>inflatable</code>. Vì thế mỗi phần tử trong mảng từ <code>gifts[0]</code> tới <code>gifts[99]</code> đều  có kiểu của <code>struct inflatable</code>:</p>
<pre><code>cin &gt;&gt; gifts[0].volume; // use volume member  of  first struct
cout &lt;&lt; gifts[99].price  &lt;&lt; endl; // display price member if last struct
</code></pre>
<p>Nhưng hãy nhớ rằng gifts là tên của mảng chứ không phải là variable, việc truy xuất gift.price sẽ vô nghĩa và bạn sẽ nhanh chóng bị báo lỗi bởi compiler.<br>
Để khai báo một mảng struct, ta cũng  có thể ghép chúng lại bằng cách bên dưới:</p>
<pre><code>Inflatable guests[2] =        // khai báo mảng kiểu struct
{
    {“Bambi”, 0.5, 21.99},        //giá trị đầu tiên của mảng
    {“Godzilla”, 2000, 565.99}    //giá trị tiếp theo
}
</code></pre>
<p>Như cách mọi người thường dùng, bạn có thể định nghĩa bằng cách bạn thích. Ví dụ, cả hai cách định nghĩa có thể đặt ở chung 1 dòng hay tách từng dòng để dễ đọc.</p>
<p>Ví dụ tiếp theo sẽ hướng dẫn cách mà bạn sẽ sử dụng và truy xuất dữ liệu sử dụng dấu chấm “.” (dot operation)</p>
<pre><code>#include &lt;iostream&gt;
struct inflatable
{
    char name[20];
    float volume;
    double price;
};
int main()
{
    using namespace  std;
    inflatable  guests[2] =
    {
        {&quot;Bambi, 0.5, 21.99&quot;},
        {&quot;Godzilla, 2000, 565.99&quot;}
    };
    cout &lt;&lt; &quot;The guests&quot; &lt;&lt; guests[0].name &lt;&lt; &quot; and &quot; &lt;&lt; guests[1].name;
    cout &lt;&lt; &quot;\n Have a  combined volume of &quot; &lt;&lt; guests[0].volume + guests[1].volume &lt;&lt; &quot; 2000.5 cubic feet.\n&quot;;
    return 0;
}
</code></pre>
<p>Và đây là kết quả sau khi chương trình chạy:</p>
<blockquote>
<p>The guests Bambi and Godzilla<br>
Have a  combined volume of 2000.5 cubic feet.</p>
</blockquote>
<h2 id="bit-fields-trong-struct"><a href="#bit-fields-trong-struct" class="statinamic-HeadingAnchor">#</a>BIT FIELDS TRONG STRUCT</h2>
<p>C++ cũng như C cho phép bạn chỉ định  số lượng bit mà bạn muốn sử dụng. Điều này thực sự hữu dụng khi bạn tạo một data structure, bạn có thể chỉ định bạn cần bao nhiêu bộ nhớ. Vùng Fields này nên là một biến hoặc một kiểu dữ liệu ta không dùng tới. Ví dụ sau:</p>
<pre><code>Struct torgle_register
{
    Unsigned in SN : 4;    // dùng 4 bit cho giá trị SN;
    Unsigned  int : 4;    // 4 bit này không dùng tới
    Bool goodIn :  1;    // valid input (1 bit)
    Bool goodTorgle : 1    // successful torgling
};
</code></pre>
<p>Bạn có thể định nghĩa fields cực kỳ linh hoạt, và bạn có thể sử dụng ký hiệu để truy cập các byte field:</p>
<pre><code>Torge_register tr = {14, true, false};
…
If(tr.goodIn)
…
</code></pre>
<p>Bit Fields thường được sử dụng trong lập trình cấp thấp cho các vi xử lý. Tuy nhiên bạn có thể sử dụng nó như là 1 flag để đánh dấu khi sử  dụng pointer.</p>
<h2 id="unions"><a href="#unions" class="statinamic-HeadingAnchor">#</a>UNIONS</h2>
<p>Union là một kiểu dữ liệu cũng  khá giống struct về cách định nghĩa cùng như cách sử dụng. Nhưng nó khác Struct tại một thời điểm nó chỉ lưu được một giá trị duy nhất.<br>
Quay trở lại các ví  dụ trước, ta có 1 struct tên <code>Inflatable</code> có chứa nhiều kiểu dữ liệu bên trong. Ta có gọi một “biến” với tên <code>pal</code> và ta  truy xuất dữ liệu theo <code>pal.name, pal.prices….</code> và dữ liệu được truy xuất được lưu vào các biến của <code>pal.name, pal.prices…</code></p>
<p><strong>Vậy  Union lưu dữ liệu  thế  nào?</strong><br>
Union chỉ lưu 1 dữ liệu tại một thời  điểm. Để hiểu rõ hơn thì bạn hãy xem ví dụ bên dưới đây về union:</p>
<pre><code>Union one4all
{
    Int int_val;
    Long  long_val;
    Double double_val;
};
</code></pre>
<p>Nhìn sơ lược bạn có thể thấy rằng union one4all chỉ có thể lưu giữ 3 kiểu dữ liệu là interger, long và double. Và chúng ta hãy tiếp tục những dòng code tiếp theo:</p>
<pre><code>one4all pail;
pail.int_val = 15;
Cout &lt;&lt; pail.int_val &lt;&lt; endl;
pail.double_val =  1.38;
cout &lt;&lt; pail.double_val &lt;&lt; endl;
cout &lt;&lt; pail.int_val &lt;&lt; endl;
</code></pre>
<p>Như chúng ta  thấy, pail chỉ lưu giá trị int tại 1 thời điểm và tại một thời điểm khác (<code>pail.double_val</code>) thì giá trị cuả int sẽ bị mất. Biến sẽ chỉ lưu trữ giá trị tại thời điểm nó được gọi. Bởi vì union chỉ lưu trữ một giá trị tại một thời  điểm, nó không có đủ bộ nhớ để giữ những giá trị khác. Vì thế, kích thước bộ nhớ của Union là kích thước của biến có kiểu dữ liệu lớn nhất.</p>
<p>Mục đích của việc sử dụng union là để tiết kiệm bộ nhớ khi mà dữ liệu đầu vào có thể  có  nhiều định dạng nhưng không bao giờ được sử dụng đồng thời. Ví dụ, giar sử bạn đang quản lý một “hỗn tạp” các kiểu dữ liệu, một vài thứ trong đó nên sử dụng int ID, một số khác thì dùng string ID, một khác  nữa là double, bla  bla bla. Nếu bạn sử  dụng các khai báo biến bình thường  thì bạn cần khai báo rất nhiều biến và rất nhiều kiểu dữ liệu. Tuy nhiên với union bạn có thể làm theo cách bên dưới đây:</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
struct widget
{
    char brand[20];
    int type;
    union ID
    {
        long id_num;
        char id_char[20];
    } id_val;
};
int main()
{
    widget prize;
    if (prize.type == 1)
    {
        cin &gt;&gt; prize.id_val.id_num;
    }
    else
    {
        cin &gt;&gt; prize.id_val.id_char;
    }
}
</code></pre>
<p>Anonymous union không có tên; bản chất đó là nhiều biến nhưng được lưu vào một vùng nhớ nhất định:</p>
<pre><code>union ID
{
    long id_num;
    char id_char[20];
} id_val;
</code></pre>
<p>Bởi vì union là Anonymous, các biến id<em>num và id</em>char được đối xử như hai “biến con” của prize và được lưu trong 1 vùng nhớ nhất định. Nó  chỉ cần một cái tên trung gian để truy  xuất vào vùng nhớ đó (là id<em>num hay id</em>char) tùy thuộc vào lập trình viên chọn cái nào để sử dụng.<br>
Union thường được  sử dụng để tiết kiệm bộ nhớ.  Nó có vẻ không cần thiết khi mà bộ nhớ RAM ngày nay  thực sự lớn và lên tới hàng gigabyte và hàng terabytes cho  ổ đĩa. Nhưng không dừng lại ở đó, hằng ngày có rất nhiều lập trình viên đang sử dụng union như cứu cánh trong lĩnh vực hệ thống nhúng, nơi mà bộ nhớ và cả ram bị giới hạn rất là nhiều.</p>
</div></div><div class="_3KFbD" data-reactid="12"><div class="_2aoG_" data-reactid="13"><h2 class="pQSNj" data-reactid="14">Tác giả</h2><section data-reactid="15"><div data-reactid="16"><p data-reactid="17"><!-- react-text: 18 -->Đăng vào <!-- /react-text --><time datetime="2015-05-10" data-reactid="19">10 tháng 5 2015</time></p><p data-reactid="20"><a href="http://daynhauhoc.com/t/7092" target="_blank" data-reactid="21">Bài viết gốc</a></p></div></section></div><div class="_2aoG_" data-reactid="22"><h2 class="pQSNj" data-reactid="23">Thông tin</h2><p data-reactid="24"><!-- react-text: 25 -->Proudly published with<!-- /react-text --><a href="http://moox.io/statinamic/" data-reactid="26"> Statinamic</a></p></div></div></div></div></div></div></div></div><script>window.__COLLECTION__ = [{"layout":"PageError","route":"404.html","description":"NOT FOUND\n\nYou just hit a route that doesn't exist... the sadness.\n","__filename":"404.md","__url":"/404.html","__resourceUrl":"/404.html","__dataUrl":"/404.html.db06c43a9ca4dd95a37a8ef55159d153.json"},{"title":"Homepage","layout":"Homepage","description":"No thing here\n","__filename":"index.md","__url":"/","__resourceUrl":"/index.html","__dataUrl":"/index.html.de865c697a43321b3d39b7dd2ca3115b.json"},{"id":11040,"layout":"Post","route":"markdown-trong-daynhauhoc-com","title":"Markdown trong daynhauhoc.com","tags":["markdown"],"date":"2015-08-14T08:33:21.984Z","author":{"username":"GDGHN_AndroidTeam","avatar":"/user_avatar/daynhauhoc.com/gdghn_androidteam/{size}/3567_1.png"},"description":"Lời mở đầu\n\nDo quá trình sử dụng daynhauhoc nếu bạn đồng thời dùng markdown trong bài post sẽ giúp bài viết sáng ý và được chú ý hơn. Cũng…","__filename":"posts/11040.md","__url":"/markdown-trong-daynhauhoc-com/","__resourceUrl":"/markdown-trong-daynhauhoc-com/index.html","__dataUrl":"/markdown-trong-daynhauhoc-com/index.html.28fc2a0748fb2c6dc959031902e227bd.json"},{"id":11047,"layout":"Post","route":"trai-long-1-thang-hoc-tieng-anh","title":"[Trải lòng] 1 tháng học tiếng anh","tags":["english"],"date":"2015-08-14T10:36:23.027Z","description":"Vậy là gần được 1 tháng, mình theo đuổi tiếng anh và bắt đầu từ topic \"Chia sẻ phương pháp học tiếng anh của mình\", mình cảm thấy nó thật…","__filename":"posts/11047.md","__url":"/trai-long-1-thang-hoc-tieng-anh/","__resourceUrl":"/trai-long-1-thang-hoc-tieng-anh/index.html","__dataUrl":"/trai-long-1-thang-hoc-tieng-anh/index.html.73cb47271206909bdcc9dc0c4dc59c57.json"},{"id":11171,"layout":"Post","route":"chung-ta-nen-dung-viec-dich-thuat-ngu-tieng-anh-sang-tieng-viet-vi-mot-nen-giao-duc-tot-hon","title":"Chúng ta nên dừng việc dịch thuật ngữ tiếng Anh sang tiếng Việt vì một nền giáo dục tốt hơn","tags":null,"date":"2015-08-16T11:46:54.862Z","author":{"username":"ltd","avatar":"/user_avatar/daynhauhoc.com/ltd/{size}/1016_1.png"},"description":"Việc dịch thuật ngữ tiếng Anh sang tiếng Việt vừa tốn công, vừa không hiệu quả và tệ hơn hết là còn gây hiểu nhầm ý nghĩa của thuật ngữ. Về…","__filename":"posts/11171.md","__url":"/chung-ta-nen-dung-viec-dich-thuat-ngu-tieng-anh-sang-tieng-viet-vi-mot-nen-giao-duc-tot-hon/","__resourceUrl":"/chung-ta-nen-dung-viec-dich-thuat-ngu-tieng-anh-sang-tieng-viet-vi-mot-nen-giao-duc-tot-hon/index.html","__dataUrl":"/chung-ta-nen-dung-viec-dich-thuat-ngu-tieng-anh-sang-tieng-viet-vi-mot-nen-giao-duc-tot-hon/index.html.d6dadce47551d2d57276053e1fed6904.json"},{"id":11228,"layout":"Post","route":"nhung-kinh-nghiem-voi-lap-trinh-android-phan-i","title":"Những kinh nghiệm với lập trình Android - Phần I","tags":["android"],"date":"2015-08-17T07:32:43.343Z","author":{"username":"GDGHN_AndroidTeam","avatar":"/user_avatar/daynhauhoc.com/gdghn_androidteam/{size}/3567_1.png"},"description":"Tóm tắt\n\n[Có một vài topic như thế này][1] khiến mình rất bối rối không biết phải trả lời như thế nào cho hợp lí. Vậy nên lập thêm một topic…","__filename":"posts/11228.md","__url":"/nhung-kinh-nghiem-voi-lap-trinh-android-phan-i/","__resourceUrl":"/nhung-kinh-nghiem-voi-lap-trinh-android-phan-i/index.html","__dataUrl":"/nhung-kinh-nghiem-voi-lap-trinh-android-phan-i/index.html.6d8a9624dc116d4031a0de65d64b608e.json"},{"id":11235,"layout":"Post","route":"nhung-kinh-nghiem-voi-lap-trinh-android-phan-ii","title":"Những kinh nghiệm với lập trình Android - Phần II","tags":["android"],"date":"2015-08-17T09:02:33.249Z","author":{"username":"GDGHN_AndroidTeam","avatar":"/user_avatar/daynhauhoc.com/gdghn_androidteam/{size}/3567_1.png"},"description":"Sử dụng thư viện Volley hoặc OkHttp thay vì tự viết một HTTP client của riêng bạn\n\nQua quá trình sử dụng, mình nhận thấy rằng để viết một…","__filename":"posts/11235.md","__url":"/nhung-kinh-nghiem-voi-lap-trinh-android-phan-ii/","__resourceUrl":"/nhung-kinh-nghiem-voi-lap-trinh-android-phan-ii/index.html","__dataUrl":"/nhung-kinh-nghiem-voi-lap-trinh-android-phan-ii/index.html.f5f3766bb2b1c918b4f8da8771589327.json"},{"id":11285,"layout":"Post","route":"json-trong-android-phan-2-xuat-json-tu-database-bang-php","title":"JSon trong Android – Phần 2: Xuất JSon từ Database bằng Php","tags":["json","android"],"date":"2015-08-18T07:38:56.241Z","author":{"username":"nguyenvanquan7826","avatar":"/user_avatar/daynhauhoc.com/nguyenvanquan7826/{size}/466_1.png"},"description":"Hôm nay tiếp tục phần 2 ra lò nhé các bạn\nJSon trong Android – Phần 2: Xuất JSon từ Database bằng Php \nhttp&#x3A;//www.nguyenvanquan7826.com…","__filename":"posts/11285.md","__url":"/json-trong-android-phan-2-xuat-json-tu-database-bang-php/","__resourceUrl":"/json-trong-android-phan-2-xuat-json-tu-database-bang-php/index.html","__dataUrl":"/json-trong-android-phan-2-xuat-json-tu-database-bang-php/index.html.5326bebda802318d18ae1bbf2d4410e7.json"},{"id":1147,"layout":"Post","route":"wiki-sort-c-b-n-1-insert-sort-s-p-x-p-chen","title":"[Wiki] Sort cơ bản 1 - Insert Sort - Sắp xếp chèn","tags":["algorithm","c","wiki"],"date":"2014-11-02T09:23:53.502Z","author":{"username":"ltd","avatar":"/user_avatar/daynhauhoc.com/ltd/{size}/1016_1.png"},"description":"Ngồi rảnh rảnh nghiên cứu lại giải thuật đã bỏ từ lâu. Bắt đầu với Insert sort.\nhttp&#x3A;//vi.wikipedia.org/wiki/S%E1%BA%AFp_x%E1%BA%BFp_ch…","__filename":"posts/1147.md","__url":"/wiki-sort-c-b-n-1-insert-sort-s-p-x-p-chen/","__resourceUrl":"/wiki-sort-c-b-n-1-insert-sort-s-p-x-p-chen/index.html","__dataUrl":"/wiki-sort-c-b-n-1-insert-sort-s-p-x-p-chen/index.html.46f3600b2fe618f57b46b1449c436100.json"},{"id":11518,"layout":"Post","route":"maven-la-gi-su-dung-maven-trong-du-an-java","title":"Maven là gì? Sử dụng maven trong dự án java","tags":["java"],"date":"2015-08-22T13:33:03.805Z","description":"\n1. Maven là gì ?\n    Apache maven là một chương trình quản lý dự án cho phép các developers có thể quản lý về version, các dependencies (…","__filename":"posts/11518.md","__url":"/maven-la-gi-su-dung-maven-trong-du-an-java/","__resourceUrl":"/maven-la-gi-su-dung-maven-trong-du-an-java/index.html","__dataUrl":"/maven-la-gi-su-dung-maven-trong-du-an-java/index.html.0d0dde4098612ce0c2920f542e487c74.json"},{"id":14242,"layout":"Post","route":"d-t-ten-bi-n-nh-th-nao-cho-hi-u-qu-part1","title":"Đặt tên biến như thế nào cho hiệu quả (part1)","tags":["coding-style"],"date":"2015-10-09T16:12:03.117Z","author":{"username":"thanhmssl10","avatar":"/user_avatar/daynhauhoc.com/thanhmssl10/{size}/2345_1.png"},"description":"( Sinh nhật diễn đàn rồi, viết bài kiếm ít like đi chơi xổ số nào :smile: )\n \nBài viết này mình xin chia sẻ một vài gợi ý về việc đặt tên…","__filename":"posts/14242.md","__url":"/d-t-ten-bi-n-nh-th-nao-cho-hi-u-qu-part1/","__resourceUrl":"/d-t-ten-bi-n-nh-th-nao-cho-hi-u-qu-part1/index.html","__dataUrl":"/d-t-ten-bi-n-nh-th-nao-cho-hi-u-qu-part1/index.html.0e0b31c3df92d44cd4d79030fbb7b59d.json"},{"id":14273,"layout":"Post","route":"t-i-sao-m-t-s-ng-i-l-i-thich-xin-facebook-d-h-i-bai","title":"Tại sao một số người lại thích xin Facebook để ... hỏi bài?","tags":null,"date":"2015-10-10T07:53:44.616Z","author":{"username":"ltd","avatar":"/user_avatar/daynhauhoc.com/ltd/{size}/1016_1.png"},"description":"... Nhưng có thể sẽ không bao giờ hỏi hoặc khó lòng nhận được câu trả lời như mình hi vọng\n\nTại sao người hỏi có thể sẽ không bao giờ hỏi…","__filename":"posts/14273.md","__url":"/t-i-sao-m-t-s-ng-i-l-i-thich-xin-facebook-d-h-i-bai/","__resourceUrl":"/t-i-sao-m-t-s-ng-i-l-i-thich-xin-facebook-d-h-i-bai/index.html","__dataUrl":"/t-i-sao-m-t-s-ng-i-l-i-thich-xin-facebook-d-h-i-bai/index.html.09dee8c3e5f0f1b400975796e9712646.json"},{"id":14663,"layout":"Post","route":"t-o-va-deploy-app-tren-heroku-node-js","title":"Tạo và deploy app trên heroku (node.js)","tags":["nodejs"],"date":"2015-10-15T04:43:57.019Z","description":"Mình là newbie, từng gặp rất nhiều khó khăn khi tiếp xúc với heroku. Nay mình post bài này để các bạn chưa biết tham khảo. Các đại ca góp ý…","__filename":"posts/14663.md","__url":"/t-o-va-deploy-app-tren-heroku-node-js/","__resourceUrl":"/t-o-va-deploy-app-tren-heroku-node-js/index.html","__dataUrl":"/t-o-va-deploy-app-tren-heroku-node-js/index.html.c13324a293e79d7ce6bc4c523fcfeabe.json"},{"id":1537,"layout":"Post","route":"tai-lieu-lap-trinh-c-for-newbie-chuong-1-nen-tang-de-bat-dau","title":"[Tài liệu lập trình C for newbie] - Chương 1: Nền tảng để bắt đầu!","tags":["c","document"],"date":"2014-11-16T06:54:20.871Z","author":{"username":"TBM_2512","avatar":"/user_avatar/daynhauhoc.com/tbm_2512/{size}/501_1.png"},"description":"Hi mọi người,\n\nHôm nay mình xin chia sẻ với các bạn 1 tài liệu hướng dẫn lập trình C mà mình sưu tầm được. Tài liệu này được viết bởi một…","__filename":"posts/1537.md","__url":"/tai-lieu-lap-trinh-c-for-newbie-chuong-1-nen-tang-de-bat-dau/","__resourceUrl":"/tai-lieu-lap-trinh-c-for-newbie-chuong-1-nen-tang-de-bat-dau/index.html","__dataUrl":"/tai-lieu-lap-trinh-c-for-newbie-chuong-1-nen-tang-de-bat-dau/index.html.4079577ffc45721470091773e36634c0.json"},{"id":15700,"layout":"Post","route":"javascript-debounce-function-la-gi","title":"JavaScript - Debounce function là gì?","tags":["ux","javascript"],"date":"2015-11-02T18:25:24.295Z","author":{"username":"vhnam","avatar":"/user_avatar/daynhauhoc.com/vhnam/{size}/1298_1.png"},"description":"Lúc trước mình có làm một bài test yêu cầu làm một Instant Search như của Twitter. Trong quá trình làm, sẽ phát sinh một trường hợp như…","__filename":"posts/15700.md","__url":"/javascript-debounce-function-la-gi/","__resourceUrl":"/javascript-debounce-function-la-gi/index.html","__dataUrl":"/javascript-debounce-function-la-gi/index.html.e57c00e91e3607bf34f7d6cefe4cb52b.json"},{"id":20049,"layout":"Post","route":"pascal-m-t-ngon-ngu-thoi-thop","title":"Pascal - Một ngôn ngữ thoi thóp","tags":["pascal"],"date":"2016-01-23T11:31:09.647Z","author":{"username":"conan4582","avatar":"/user_avatar/daynhauhoc.com/conan4582/{size}/8110_1.png"},"description":"\\*Lưu ý: Bài viết chỉ thể hiện quan điểm cá nhân và không có ý chỉ trích bất kỳ cá nhân hay tổ chức nào. Vui lòng gở bỏ hết ứng dụng liên…","__filename":"posts/20049.md","__url":"/pascal-m-t-ngon-ngu-thoi-thop/","__resourceUrl":"/pascal-m-t-ngon-ngu-thoi-thop/index.html","__dataUrl":"/pascal-m-t-ngon-ngu-thoi-thop/index.html.017722d1200958aa45923014358c81b5.json"},{"id":20333,"layout":"Post","route":"10-ngon-ngu-l-p-trinh-thu-c-d-ng-kho-nhat","title":"10 Ngôn ngữ lập trình thuộc dạng... \"khó ở\" nhất","tags":null,"date":"2016-01-31T07:57:35.838Z","author":{"username":"conan4582","avatar":"/user_avatar/daynhauhoc.com/conan4582/{size}/8110_1.png"},"description":"Hệ thống xếp hạng này là do quan điểm cá nhân và thu thập ý kiến.\n\n10.Perl\n\nPerl là một ngôn ngữ lập trình do Larry Wall thiết kế để xử lý…","__filename":"posts/20333.md","__url":"/10-ngon-ngu-l-p-trinh-thu-c-d-ng-kho-nhat/","__resourceUrl":"/10-ngon-ngu-l-p-trinh-thu-c-d-ng-kho-nhat/index.html","__dataUrl":"/10-ngon-ngu-l-p-trinh-thu-c-d-ng-kho-nhat/index.html.c39feae67849f3e741b2b894a0cffa22.json"},{"id":20388,"layout":"Post","route":"d-o-java-u-no-co-th-t-day","title":"Đạo Java ư ? Nó có thật đấy","tags":["nerd","java"],"date":"2016-02-01T15:45:40.342Z","author":{"username":"conan4582","avatar":"/user_avatar/daynhauhoc.com/conan4582/{size}/8110_1.png"},"description":"Java - một điệp khúc muôn thuở, một vũ khí uy lực gắn liền với nhiều người và là niềm tự hào của James và Sun micsys quá cố.\nclass…","__filename":"posts/20388.md","__url":"/d-o-java-u-no-co-th-t-day/","__resourceUrl":"/d-o-java-u-no-co-th-t-day/index.html","__dataUrl":"/d-o-java-u-no-co-th-t-day/index.html.65ccc3e74e38011f4a6447b1ae42e7c6.json"},{"id":2079,"layout":"Post","route":"wiki-mot-so-ham-toan-hoc-c","title":"[Wiki] Một số hàm toán học C++","tags":["wiki","c++"],"date":"2014-11-28T16:18:18.658Z","description":"Các hàm trong chương trinh\nUCLN2\n\nHàm này sẽ tính Ước chung lớn nhất cuả 2 số a,b\n\n* * *\n\nđây là toàn bộ code\n\n\\##Edited:\n\nMình vừa viết…","__filename":"posts/2079.md","__url":"/wiki-mot-so-ham-toan-hoc-c/","__resourceUrl":"/wiki-mot-so-ham-toan-hoc-c/index.html","__dataUrl":"/wiki-mot-so-ham-toan-hoc-c/index.html.e18d88bd881ea4aabb56da60d801c505.json"},{"id":21302,"layout":"Post","route":"doc-sach-online-giai-phap-tiet-kiem-cho-nguoi-muon-doc","title":"Đọc sách online, giải pháp tiết kiệm cho người muốn đọc","tags":null,"date":"2016-02-28T12:22:29.141Z","author":{"username":"ltd","avatar":"/user_avatar/daynhauhoc.com/ltd/{size}/1016_1.png"},"description":"Chú ý, lướt qua phần 1 nếu các bạn đã hiểu được việc đọc là quan trọng\n\nPhần 1: Việc đọc là quan trọng\n\nDayNhauHoc luôn khuyến khích các…","__filename":"posts/21302.md","__url":"/doc-sach-online-giai-phap-tiet-kiem-cho-nguoi-muon-doc/","__resourceUrl":"/doc-sach-online-giai-phap-tiet-kiem-cho-nguoi-muon-doc/index.html","__dataUrl":"/doc-sach-online-giai-phap-tiet-kiem-cho-nguoi-muon-doc/index.html.6227d168e8c1e2a63174f10d458b19f0.json"},{"id":21505,"layout":"Post","route":"lau-lau-mot-quyen-sach-think-and-grow-rich-khong-chi-la-sach-lam-giau","title":"Lâu lâu một quyển sách - Think and grow rich, không chỉ là sách làm giàu","tags":["book","review"],"date":"2016-03-03T14:36:24.807Z","author":{"username":"ltd","avatar":"/user_avatar/daynhauhoc.com/ltd/{size}/1016_1.png"},"description":"Đạt thông thường không thích đọc sách nào có chữ \"rich\" trong đó chủ yếu là vì sợ đọc trúng sách \"lừa đảo\" vì Đạt biết làm giàu không khó…","__filename":"posts/21505.md","__url":"/lau-lau-mot-quyen-sach-think-and-grow-rich-khong-chi-la-sach-lam-giau/","__resourceUrl":"/lau-lau-mot-quyen-sach-think-and-grow-rich-khong-chi-la-sach-lam-giau/index.html","__dataUrl":"/lau-lau-mot-quyen-sach-think-and-grow-rich-khong-chi-la-sach-lam-giau/index.html.6d22269438857b15955339ea1a03ce03.json"},{"id":2162,"layout":"Post","route":"wiki-sort-co-ban-3-quick-sort-sap-xep-nhanh","title":"[Wiki] Sort cơ bản 3 - Quick Sort - Sắp xếp nhanh","tags":["wiki","algorithm","c++"],"date":"2014-11-30T06:40:14.346Z","author":{"username":"minh_vu_03","avatar":"/user_avatar/daynhauhoc.com/minh_vu_03/{size}/899_1.png"},"description":"http&#x3A;//vi.wikipedia.org/wiki/S%E1%BA%AFp_x%E1%BA%BFp_nhanh\n\nXem video về Quick Sort ở đây\n\nhttps&#x3A;//www.youtube.com/watch?v=COk…","__filename":"posts/2162.md","__url":"/wiki-sort-co-ban-3-quick-sort-sap-xep-nhanh/","__resourceUrl":"/wiki-sort-co-ban-3-quick-sort-sap-xep-nhanh/index.html","__dataUrl":"/wiki-sort-co-ban-3-quick-sort-sap-xep-nhanh/index.html.67a15066ee945a632861ab106df59ede.json"},{"id":2171,"layout":"Post","route":"wiki-ham-ki-m-tra-s-nguyen-t-trong-c-c","title":"[Wiki] Hàm Kiểm Tra số nguyên tố trong C/C++","tags":["wiki","c++"],"date":"2014-11-30T15:24:50.196Z","author":{"username":"Honey_moon","avatar":"/letter_avatar_proxy/v2/letter/h/82dd89/{size}.png"},"description":"Số nguyên tố:\n\nSố nguyên tố là số tự nhiên chỉ chia hết cho 1 và chính nó. Ngoài ra nó không chia hết cho bất cứ số nào khác. Số 0 và 1…","__filename":"posts/2171.md","__url":"/wiki-ham-ki-m-tra-s-nguyen-t-trong-c-c/","__resourceUrl":"/wiki-ham-ki-m-tra-s-nguyen-t-trong-c-c/index.html","__dataUrl":"/wiki-ham-ki-m-tra-s-nguyen-t-trong-c-c/index.html.72561e8e61221ddb899a7c0680464e86.json"},{"id":2193,"layout":"Post","route":"wiki-toan-tu-trong-c","title":"[Wiki] Toán tử trong C++","tags":["wiki","c++"],"date":"2014-12-01T03:21:00.773Z","author":{"username":"TTmagic","avatar":"/letter_avatar_proxy/v2/letter/t/50afbb/{size}.png"},"description":"Toán tử - Operators /'ɔpəreitə/\nOnce introduced to variables and constants, we can begin to operate with them by using operators. //đoạn này…","__filename":"posts/2193.md","__url":"/wiki-toan-tu-trong-c/","__resourceUrl":"/wiki-toan-tu-trong-c/index.html","__dataUrl":"/wiki-toan-tu-trong-c/index.html.19ee4bc7a399e0c20f88fc5b386264a4.json"},{"id":22056,"layout":"Post","route":"lau-lau-mot-quyen-sach-toi-di-hoc-cua-nha-giao-uu-tu-nguyen-ngoc-ky","title":"Lâu lâu một quyển sách - Tôi đi học của nhà giáo Ưu Tú Nguyễn Ngọc Ký","tags":["review","book"],"date":"2016-03-13T07:34:32.411Z","author":{"username":"ltd","avatar":"/user_avatar/daynhauhoc.com/ltd/{size}/1016_1.png"},"description":"Đạt nghe về quyển Tôi Đi Học đã lâu, nhưng giờ mới có dịp đọc.\n\n\n\nĐang tính đọc xong sẽ review, nhưng quyển này ngắn chắc là sẽ xong trong…","__filename":"posts/22056.md","__url":"/lau-lau-mot-quyen-sach-toi-di-hoc-cua-nha-giao-uu-tu-nguyen-ngoc-ky/","__resourceUrl":"/lau-lau-mot-quyen-sach-toi-di-hoc-cua-nha-giao-uu-tu-nguyen-ngoc-ky/index.html","__dataUrl":"/lau-lau-mot-quyen-sach-toi-di-hoc-cua-nha-giao-uu-tu-nguyen-ngoc-ky/index.html.656d3a228a4a96d9d6544cfdcc01b009.json"},{"id":22117,"layout":"Post","route":"fastest-way-to-learn-basic-of-programming-p1","title":"Fastest way to learn basic of Programming [P1]","tags":["basic"],"date":"2016-03-14T12:05:39.933Z","author":{"username":"conan4582","avatar":"/user_avatar/daynhauhoc.com/conan4582/{size}/8110_1.png"},"description":"Xin chào cả nhà. Căn bản lập trình là thứ bắt đầu đầy nước mắt của lập trình viên :joy:, và một khi bạn đã \"qua cơn nguy kịch\" thì bạn sẽ…","__filename":"posts/22117.md","__url":"/fastest-way-to-learn-basic-of-programming-p1/","__resourceUrl":"/fastest-way-to-learn-basic-of-programming-p1/index.html","__dataUrl":"/fastest-way-to-learn-basic-of-programming-p1/index.html.1a6d446cd51f35548511a339fe832006.json"},{"id":22178,"layout":"Post","route":"fastest-way-to-learn-basic-of-programming-p2","title":"Fastest way to learn basic of Programming [P2]","tags":["basic"],"date":"2016-03-15T10:42:50.131Z","author":{"username":"conan4582","avatar":"/user_avatar/daynhauhoc.com/conan4582/{size}/8110_1.png"},"description":"Chào cả nhà, sau khi làm xong Part 1 của Fastest way to learn basic of Programming, em thấy có rất nhiều bạn newbie và cả không newbie đánh…","__filename":"posts/22178.md","__url":"/fastest-way-to-learn-basic-of-programming-p2/","__resourceUrl":"/fastest-way-to-learn-basic-of-programming-p2/index.html","__dataUrl":"/fastest-way-to-learn-basic-of-programming-p2/index.html.da1552b5592bb7a585f87ae6541603f9.json"},{"id":22191,"layout":"Post","route":"lau-lau-mot-cuon-sach-nha-gia-kim-cua-paulo-coelho-triet-li-tam-niem-phuong-cham-song","title":"[Lâu lâu một cuốn sách] Nhà giả kim của Paulo Coelho - triết lí, tâm niệm, phương châm sống","tags":["review","book"],"date":"2016-03-15T13:47:31.099Z","author":{"username":"Huu_Dung_Tran","avatar":"/user_avatar/daynhauhoc.com/huu_dung_tran/{size}/7604_1.png"},"description":"Chào các bạn, thấy anh đạt review sách cũng hay hay nên mình cũng thử xem sao. \n\nGiới thiệu sờ sơ\n\nQuyển sách hôm nay mình giới thiệu là Nhà…","__filename":"posts/22191.md","__url":"/lau-lau-mot-cuon-sach-nha-gia-kim-cua-paulo-coelho-triet-li-tam-niem-phuong-cham-song/","__resourceUrl":"/lau-lau-mot-cuon-sach-nha-gia-kim-cua-paulo-coelho-triet-li-tam-niem-phuong-cham-song/index.html","__dataUrl":"/lau-lau-mot-cuon-sach-nha-gia-kim-cua-paulo-coelho-triet-li-tam-niem-phuong-cham-song/index.html.5f8456ffad06e6bca05bc1b11e17cc08.json"},{"id":22231,"layout":"Post","route":"fastest-way-to-learn-basic-of-oop-p3","title":"Fastest way to learn basic of OOP [P3]","tags":["oop","basic"],"date":"2016-03-16T06:11:25.322Z","author":{"username":"conan4582","avatar":"/user_avatar/daynhauhoc.com/conan4582/{size}/8110_1.png"},"description":"Chào cả nhà, trưa không ngủ được nên ngồi viết bài luôn ^^.\nQua 2 phần của Fastest way to learn basic of Programming thì các newbie chắc hẳn…","__filename":"posts/22231.md","__url":"/fastest-way-to-learn-basic-of-oop-p3/","__resourceUrl":"/fastest-way-to-learn-basic-of-oop-p3/index.html","__dataUrl":"/fastest-way-to-learn-basic-of-oop-p3/index.html.dd837ca34b71cb3bac5ce92b4757d9bd.json"},{"id":22819,"layout":"Post","route":"dat-nuoc-cua-nhung-ke-luoi-bieng","title":"Đất Nước của những kẻ Lười Biếng","tags":null,"date":"2016-03-26T02:09:03.125Z","author":{"username":"Le_Dinh_Huy","avatar":"/letter_avatar_proxy/v2/letter/l/c5a1d2/{size}.png"},"description":"Đây là một bài viết tôi sưu tầm được, nhưng tôi phải nói trước với bạn là ngôn từ của nó không hề ngọt tai, nếu bạn chưa sẵn sàng nhìn nhận…","__filename":"posts/22819.md","__url":"/dat-nuoc-cua-nhung-ke-luoi-bieng/","__resourceUrl":"/dat-nuoc-cua-nhung-ke-luoi-bieng/index.html","__dataUrl":"/dat-nuoc-cua-nhung-ke-luoi-bieng/index.html.b3d0d75e8bf744db0581625f38b6fb39.json"},{"id":22938,"layout":"Post","route":"doi-pho-voi-cau-hoi-phong-van-truoc-day-ban-lam-gi","title":"Đối phó với câu hỏi phỏng vấn: Trước đây bạn làm gì?","tags":["kinh-nghiem"],"date":"2016-03-27T10:29:04.715Z","author":{"username":"nguyen_phuonganh","avatar":"/letter_avatar_proxy/v2/letter/n/cc9497/{size}.png"},"description":"Công việc và kinh nghiệm làm việc trong quá khứ không chỉ là cơ sở để nhà tuyển dụng biết bạn có phù hợp với vị trí ứng tuyển hay không, mà…","__filename":"posts/22938.md","__url":"/doi-pho-voi-cau-hoi-phong-van-truoc-day-ban-lam-gi/","__resourceUrl":"/doi-pho-voi-cau-hoi-phong-van-truoc-day-ban-lam-gi/index.html","__dataUrl":"/doi-pho-voi-cau-hoi-phong-van-truoc-day-ban-lam-gi/index.html.a67b0d2107f04c8102ae71b3613460df.json"},{"id":22951,"layout":"Post","route":"lau-lau-mot-quyen-sach-doc-dac-nhan-tam-de-internet-khong-bi-huy-diet-boi-11-dong-code","title":"Lâu Lâu Một Quyển Sách: Đọc Đắc Nhân Tâm Để Internet không bị hủy diệt bởi 11 dòng code","tags":["book","review"],"date":"2016-03-27T13:49:58.161Z","author":{"username":"ltd","avatar":"/user_avatar/daynhauhoc.com/ltd/{size}/1016_1.png"},"description":"Đắc nhân tâm là một quyển sách mà Đạt nghe về nó cách đây 6 năm, lúc mới nghe tới sách này Đạt nghĩ đây là một quyển sách dành cho người già…","__filename":"posts/22951.md","__url":"/lau-lau-mot-quyen-sach-doc-dac-nhan-tam-de-internet-khong-bi-huy-diet-boi-11-dong-code/","__resourceUrl":"/lau-lau-mot-quyen-sach-doc-dac-nhan-tam-de-internet-khong-bi-huy-diet-boi-11-dong-code/index.html","__dataUrl":"/lau-lau-mot-quyen-sach-doc-dac-nhan-tam-de-internet-khong-bi-huy-diet-boi-11-dong-code/index.html.9a5ffe4556d9e29bafd260b5668ad30c.json"},{"id":23407,"layout":"Post","route":"ky-nang-song-neu-cac-ban-that-su-muon-thay-doi-suy-nghi-va-cach-song-tieu-cuc-cua-minh-thi-nen-doc-chi-can-bo-ra-9-phut-doc-va-1-phut-ngam-thoi","title":"Kỹ năng sống: nếu các bạn thật sự muốn thay đổi suy nghĩ và cách sống tiêu cực của mình thì nên đọc(chỉ cần bỏ ra 9 phút đọc và 1 phút ngẫm thôi)","tags":["kỹnăngsống"],"date":"2016-04-01T10:36:13.066Z","author":{"username":"Taihuynh","avatar":"/letter_avatar_proxy/v2/letter/t/e8c25b/{size}.png"},"description":"Vào mỗi chiếu thứ 6 hàng tuần khoảng 5:30 PM mình sẽ post 1 chủ đề về kỹ năng sống và những suy nghĩ của giới trẻ hiện nay.Mình chỉ là 1 con…","__filename":"posts/23407.md","__url":"/ky-nang-song-neu-cac-ban-that-su-muon-thay-doi-suy-nghi-va-cach-song-tieu-cuc-cua-minh-thi-nen-doc-chi-can-bo-ra-9-phut-doc-va-1-phut-ngam-thoi/","__resourceUrl":"/ky-nang-song-neu-cac-ban-that-su-muon-thay-doi-suy-nghi-va-cach-song-tieu-cuc-cua-minh-thi-nen-doc-chi-can-bo-ra-9-phut-doc-va-1-phut-ngam-thoi/index.html","__dataUrl":"/ky-nang-song-neu-cac-ban-that-su-muon-thay-doi-suy-nghi-va-cach-song-tieu-cuc-cua-minh-thi-nen-doc-chi-can-bo-ra-9-phut-doc-va-1-phut-ngam-thoi/index.html.3ab75026c09b8ec728a399be43c2d103.json"},{"id":2424,"layout":"Post","route":"thu-thuat-hay-tich-hop-visual-studio-vao-notepad-compile-run-with-visual-studio","title":"[Thủ thuật hay] - Tích hợp Visual studio vào notepad++ (compile & run with Visual studio)","tags":null,"date":"2014-12-06T03:06:48.938Z","author":{"username":"david15894","avatar":"/user_avatar/daynhauhoc.com/david15894/{size}/9742_1.png"},"description":"Có bao giờ bạn tự hỏi: sao trong notepad++ thấy có mấy cái menu \"run\" gì gì đó mà lại không chạy được C/C++ code? Vì bạn chưa tích hợp một…","__filename":"posts/2424.md","__url":"/thu-thuat-hay-tich-hop-visual-studio-vao-notepad-compile-run-with-visual-studio/","__resourceUrl":"/thu-thuat-hay-tich-hop-visual-studio-vao-notepad-compile-run-with-visual-studio/index.html","__dataUrl":"/thu-thuat-hay-tich-hop-visual-studio-vao-notepad-compile-run-with-visual-studio/index.html.015c380ddb9cd9e8b393a2a24b8184b7.json"},{"id":2944,"layout":"Post","route":"wiki-c-11-nhung-cai-hay-dung","title":"[Wiki] C++11 những cái hay dùng","tags":["wiki","c","c++"],"date":"2014-12-23T11:03:55.579Z","description":"Bài tham khảo từ link: \nhttp&#x3A;//www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer\n\nSử dụng auto…","__filename":"posts/2944.md","__url":"/wiki-c-11-nhung-cai-hay-dung/","__resourceUrl":"/wiki-c-11-nhung-cai-hay-dung/index.html","__dataUrl":"/wiki-c-11-nhung-cai-hay-dung/index.html.782380479748ba80a16ad48f2429f00e.json"},{"id":30,"layout":"Post","route":"imgur-com-cong-cu-chia-se-anh-tuyet-voi","title":"Imgur.com: Công cụ chia sẻ ảnh tuyệt vời","tags":["tutorial"],"date":"2014-10-13T10:40:28.747Z","author":{"username":"ltd","avatar":"/user_avatar/daynhauhoc.com/ltd/{size}/1016_1.png"},"description":"Bạn cần share 1 tầm hình lên internet, bạn sẽ gặp các vấn đề sau...\n\nphải tìm một host up ảnh free\n\nupload hình quá lâu\n\nđăng ký quá phức…","__filename":"posts/30.md","__url":"/imgur-com-cong-cu-chia-se-anh-tuyet-voi/","__resourceUrl":"/imgur-com-cong-cu-chia-se-anh-tuyet-voi/index.html","__dataUrl":"/imgur-com-cong-cu-chia-se-anh-tuyet-voi/index.html.9f4f3979e5ed84df1ed0b365cc477278.json"},{"id":3032,"layout":"Post","route":"wiki-cach-ghi-file-trong-c","title":"[Wiki] Cách ghi file trong C++","tags":["wiki","c++"],"date":"2014-12-26T09:55:37.003Z","author":{"username":"ltd","avatar":"/user_avatar/daynhauhoc.com/ltd/{size}/1016_1.png"},"description":"Cách ghi file cực kỳ đơn giản trong C++.\n\nĐể khi nội dung vào file nằm chung thư mục với code, ta làm như sau:\n\nĐể ghi một file có đường dẫn…","__filename":"posts/3032.md","__url":"/wiki-cach-ghi-file-trong-c/","__resourceUrl":"/wiki-cach-ghi-file-trong-c/index.html","__dataUrl":"/wiki-cach-ghi-file-trong-c/index.html.0c8c75c46b3686cf4ca3205c743118e5.json"},{"id":3391,"layout":"Post","route":"tong-hop-doc-file-bang-c-va-c","title":"Tổng hợp: đọc file bằng C++ và C","tags":["tutorial","c++","c"],"date":"2015-01-17T18:12:36.112Z","description":"Mình tìm thấy nhiều cách đọc file bằng C++ vào std::string khác nhau, post tạm 1 cách đã, có thời gian post dần thêm.\n\nCách đầu tiên là đọc…","__filename":"posts/3391.md","__url":"/tong-hop-doc-file-bang-c-va-c/","__resourceUrl":"/tong-hop-doc-file-bang-c-va-c/index.html","__dataUrl":"/tong-hop-doc-file-bang-c-va-c/index.html.464ff8c3329ba259e7255e4a2fe5ba82.json"},{"id":3564,"layout":"Post","route":"github-va-cach-su-dung-co-ban-github-tren-windows","title":"Github Và Cách Sử Dụng Cơ Bản Github Trên Windows","tags":["github"],"date":"2015-01-27T10:33:04.615Z","author":{"username":"dqh","avatar":"/user_avatar/daynhauhoc.com/dqh/{size}/9328_1.png"},"description":"Bài viết được đăng tại đây: http&#x3A;//portal.daynhauhoc.com/p/huong-dan-dung-github-tren-windows-co-ban/\n\nĐã có khá nhiều bài hướng dẫn sử…","__filename":"posts/3564.md","__url":"/github-va-cach-su-dung-co-ban-github-tren-windows/","__resourceUrl":"/github-va-cach-su-dung-co-ban-github-tren-windows/index.html","__dataUrl":"/github-va-cach-su-dung-co-ban-github-tren-windows/index.html.80941c51a117da76c497dad7e5d05850.json"},{"id":3698,"layout":"Post","route":"cach-dat-muc-tieu-smart-theo-5-nguyen-tac","title":"Cách đặt mục tiêu SMART theo 5 nguyên tắc","tags":null,"date":"2015-02-03T07:55:03.449Z","author":{"username":"Le_Dinh_Huy","avatar":"/letter_avatar_proxy/v2/letter/l/c5a1d2/{size}.png"},"description":"\n\nTại sao mình viết bài này ? Vì mình thấy có nhiều bạn có mục tiêu, nhưng chưa biết cách đặt mục tiêu sao cho hiểu quả.\nBài viết nay có…","__filename":"posts/3698.md","__url":"/cach-dat-muc-tieu-smart-theo-5-nguyen-tac/","__resourceUrl":"/cach-dat-muc-tieu-smart-theo-5-nguyen-tac/index.html","__dataUrl":"/cach-dat-muc-tieu-smart-theo-5-nguyen-tac/index.html.30ff3c139d2e817c4948a73b0a432b67.json"},{"id":4584,"layout":"Post","route":"b-n-dung-trinh-so-n-th-o-nao-d-h-c-va-lam-vi-c-v-i-python","title":"Bạn dùng trình soạn thảo nào để học và làm việc với Python?","tags":["python"],"date":"2015-03-07T06:52:34.395Z","author":{"username":"dqh","avatar":"/user_avatar/daynhauhoc.com/dqh/{size}/9328_1.png"},"description":"Bài viết được post tại: http&#x3A;//portal.daynhauhoc.com/p/ban-dung-trinh-soan-thao-nao-de-hoc-va-lam-viec-voi-python/\n\nBạn dùng trình soạn…","__filename":"posts/4584.md","__url":"/b-n-dung-trinh-so-n-th-o-nao-d-h-c-va-lam-vi-c-v-i-python/","__resourceUrl":"/b-n-dung-trinh-so-n-th-o-nao-d-h-c-va-lam-vi-c-v-i-python/index.html","__dataUrl":"/b-n-dung-trinh-so-n-th-o-nao-d-h-c-va-lam-vi-c-v-i-python/index.html.6c926bbad5f0058ccf52c13707113f33.json"},{"id":522,"layout":"Post","route":"dropbox-va-cac-dich-vu-luu-tru-file-khac","title":"Dropbox và các dịch vụ lưu trữ file khác","tags":null,"date":"2014-10-16T16:52:01.105Z","author":{"username":"ltd","avatar":"/user_avatar/daynhauhoc.com/ltd/{size}/1016_1.png"},"description":"Cũ nhưng có thể nhiều người chưa biết. Ai chưa biết và chưa đăng ký Dropbox thì đăng ký theo link dưới để sử dụng Dropbox. Đăng ký là bạn…","__filename":"posts/522.md","__url":"/dropbox-va-cac-dich-vu-luu-tru-file-khac/","__resourceUrl":"/dropbox-va-cac-dich-vu-luu-tru-file-khac/index.html","__dataUrl":"/dropbox-va-cac-dich-vu-luu-tru-file-khac/index.html.de4aa3fd27396c680bde27ce34c1d122.json"},{"id":5719,"layout":"Post","route":"de-quy-dich-boi-breakdown","title":"Đệ quy - dịch bởi @breakdown","tags":null,"date":"2015-04-09T07:06:07.833Z","author":{"username":"ltd","avatar":"/user_avatar/daynhauhoc.com/ltd/{size}/1016_1.png"},"description":"Đây là một bài viết hay được dịch bởi @breakdown. Bài viết được lấy từ sách: \"C Primer Plus 6th Edition\"\n\n* * *\n\nĐệ Quy (Recursion)\n\nHôm nay…","__filename":"posts/5719.md","__url":"/de-quy-dich-boi-breakdown/","__resourceUrl":"/de-quy-dich-boi-breakdown/index.html","__dataUrl":"/de-quy-dich-boi-breakdown/index.html.587479abd022b21b64c19eac4a856268.json"},{"id":5924,"layout":"Post","route":"huong-dan-su-dung-github-tren-windows-voi-tortoisegit-ui","title":"Hướng dẫn sử dụng github trên windows với TortoiseGit UI","tags":["github"],"date":"2015-04-14T10:50:22.313Z","description":"Các bước cài đặt\n\nStep 1. Download & install TortoiseGit https&#x3A;//code.google.com/p/tortoisegit/wiki/Download . NEXT > Next and next…","__filename":"posts/5924.md","__url":"/huong-dan-su-dung-github-tren-windows-voi-tortoisegit-ui/","__resourceUrl":"/huong-dan-su-dung-github-tren-windows-voi-tortoisegit-ui/index.html","__dataUrl":"/huong-dan-su-dung-github-tren-windows-voi-tortoisegit-ui/index.html.df6a28bbf3eac98d44734014abf62fe3.json"},{"id":6078,"layout":"Post","route":"tuts-genymotion-emulator-for-android-studio","title":"[Tuts] - Genymotion Emulator for Android Studio","tags":["android","tutorial"],"date":"2015-04-17T08:18:53.764Z","author":{"username":"david15894","avatar":"/user_avatar/daynhauhoc.com/david15894/{size}/9742_1.png"},"description":"Tích hợp emulator của Genymotion vào Android Studio.\nBạn mới chuyển sang Android Studio vì nghe nói Eclipse hết thời? :joy: Nhưng cấu hình…","__filename":"posts/6078.md","__url":"/tuts-genymotion-emulator-for-android-studio/","__resourceUrl":"/tuts-genymotion-emulator-for-android-studio/index.html","__dataUrl":"/tuts-genymotion-emulator-for-android-studio/index.html.66f2bd74ed2f4b38200b553144d6d2e2.json"},{"id":6297,"layout":"Post","route":"thiet-lap-phim-tat-shutter-tren-ubuntu-lam-mac-dinh","title":"Thiết lập phím tắt Shutter trên Ubuntu làm mặc định","tags":["ubuntu","linux","howto"],"date":"2015-04-22T08:24:03.069Z","author":{"username":"dqh","avatar":"/user_avatar/daynhauhoc.com/dqh/{size}/9328_1.png"},"description":"Ở  Ubuntu, khi ta bấm PrtSc, hay Ctrl+PrtSc mặc định Ubuntu sẽ gọi phần mền ScreenShot để chụp ảnh màn hình, trong bài này mình sẽ hướng dẫn…","__filename":"posts/6297.md","__url":"/thiet-lap-phim-tat-shutter-tren-ubuntu-lam-mac-dinh/","__resourceUrl":"/thiet-lap-phim-tat-shutter-tren-ubuntu-lam-mac-dinh/index.html","__dataUrl":"/thiet-lap-phim-tat-shutter-tren-ubuntu-lam-mac-dinh/index.html.b00482259a1eb6607c3cdc1fd6678691.json"},{"id":6511,"layout":"Post","route":"thuat-toan-nho-tim-boi-chung-nho-nhat-cua-3-so-bat-ky","title":"[Thuật toán nhỏ] Tìm bội chung nhỏ nhất của 3 số bất kỳ","tags":["algorithm","cpp","python","php"],"date":"2015-04-25T15:40:11.523Z","author":{"username":"dqh","avatar":"/user_avatar/daynhauhoc.com/dqh/{size}/9328_1.png"},"description":"Yêu cầu\n\nInput: nhập 3 số nguyên: a, b, c\n\nOutput: BCNN(a, b, c)\n\nKhái niệm\n\nBội chung nhỏ nhất của các số nhất kỳ là số nhỏ nhất có thể…","__filename":"posts/6511.md","__url":"/thuat-toan-nho-tim-boi-chung-nho-nhat-cua-3-so-bat-ky/","__resourceUrl":"/thuat-toan-nho-tim-boi-chung-nho-nhat-cua-3-so-bat-ky/index.html","__dataUrl":"/thuat-toan-nho-tim-boi-chung-nho-nhat-cua-3-so-bat-ky/index.html.9e79a00a5034eb99db87108e90affe8c.json"},{"id":6526,"layout":"Post","route":"huong-dan-dung-github-tren-windows-co-ban-step-by-step","title":"Hướng dẫn dùng Github trên Windows cơ bản (step by step)","tags":["github"],"date":"2015-04-26T07:36:13.728Z","author":{"username":"thanhmssl10","avatar":"/user_avatar/daynhauhoc.com/thanhmssl10/{size}/2345_1.png"},"description":"\\#Hướng dẫn dùng Github cơ bản theo phong cách \"mì ăn liền\" \n\nĐã có khá nhiều bài hướng dẫn sử dụng Github rồi nhưng mình vẫn muốn viết bài…","__filename":"posts/6526.md","__url":"/huong-dan-dung-github-tren-windows-co-ban-step-by-step/","__resourceUrl":"/huong-dan-dung-github-tren-windows-co-ban-step-by-step/index.html","__dataUrl":"/huong-dan-dung-github-tren-windows-co-ban-step-by-step/index.html.cb19a584ec21049d037db5d109cccff4.json"},{"id":6625,"layout":"Post","route":"sublime-text-3-tren-ca-tuyet-voi","title":"Sublime Text 3 ! Trên cả tuyệt vời","tags":["ide"],"date":"2015-04-28T04:46:44.173Z","author":{"username":"dqh","avatar":"/user_avatar/daynhauhoc.com/dqh/{size}/9328_1.png"},"description":"Bài viết được post tại: http&#x3A;//portal.daynhauhoc.com/p/sublime-text-3-tren-ca-tuyet-voi/\n\nSublime Text là một phần mền soạn thảo code…","__filename":"posts/6625.md","__url":"/sublime-text-3-tren-ca-tuyet-voi/","__resourceUrl":"/sublime-text-3-tren-ca-tuyet-voi/index.html","__dataUrl":"/sublime-text-3-tren-ca-tuyet-voi/index.html.241baea5d7e08e54a2026b6b5ad69faa.json"},{"id":6685,"layout":"Post","route":"phan-mem-tao-anh-gif-record-screen-cuc-nhanh","title":"Phần mềm tạo ảnh GIF Record Screen cực nhanh","tags":["gif"],"date":"2015-04-29T11:27:14.468Z","author":{"username":"thanhmssl10","avatar":"/user_avatar/daynhauhoc.com/thanhmssl10/{size}/2345_1.png"},"description":"Ảnh GIF hiện có mặt khắp mọi nơi từ 9gag đến github ( tạo iss nói không rõ vấn đề nên bị bắt làm gif :smile:  )\nĐặc biệt rất hữu ích trong…","__filename":"posts/6685.md","__url":"/phan-mem-tao-anh-gif-record-screen-cuc-nhanh/","__resourceUrl":"/phan-mem-tao-anh-gif-record-screen-cuc-nhanh/index.html","__dataUrl":"/phan-mem-tao-anh-gif-record-screen-cuc-nhanh/index.html.d46114fb6e62fb8176ae2014c50c521b.json"},{"id":6710,"layout":"Post","route":"chia-de-tri-tinh-luy-thua-a-n","title":"[Chia để trị] Tính lũy thừa a^n","tags":["algorithm"],"date":"2015-04-30T06:20:35.807Z","description":"Giờ rảnh được chút, làm thêm một bài nữa về một thuật toán cơ bản: tính lũy thừa an bằng phương pháp chia để trị.\nChắc mọi người đa số hay…","__filename":"posts/6710.md","__url":"/chia-de-tri-tinh-luy-thua-a-n/","__resourceUrl":"/chia-de-tri-tinh-luy-thua-a-n/index.html","__dataUrl":"/chia-de-tri-tinh-luy-thua-a-n/index.html.3daa3d2c38f08455f260cbe680acc591.json"},{"id":6728,"layout":"Post","route":"phan-tich-thuat-toan-tiem-can-asymptotic-notation","title":"[Phân tích thuật toán] Tiệm cận (Asymptotic notation)","tags":["algorithm"],"date":"2015-04-30T15:36:15.457Z","description":"Ở bài này, mình sẽ nói về độ phức tạp của một thuật toán. Do mình cũng mới nghiên cứu để viết bài này nên chưa thể hiểu rõ được, nhưng mình…","__filename":"posts/6728.md","__url":"/phan-tich-thuat-toan-tiem-can-asymptotic-notation/","__resourceUrl":"/phan-tich-thuat-toan-tiem-can-asymptotic-notation/index.html","__dataUrl":"/phan-tich-thuat-toan-tiem-can-asymptotic-notation/index.html.f07f3803a67a865a4c6bde6c77b4bd11.json"},{"id":6730,"layout":"Post","route":"he-dieu-hanh-nao-se-la-vua-trong-tuong-lai","title":"Hệ điều hành nào sẽ là vua trong tương lai?","tags":null,"date":"2015-04-30T16:22:46.523Z","author":{"username":"drgnz","avatar":"/user_avatar/daynhauhoc.com/drgnz/{size}/9465_1.png"},"description":"\n\niOS đã từng làm mưa làm gió với sự cao sang của mình, làm thay đổi nguyên một thế giới Điện thoại Thông minh ở những năm 2007-2012 với…","__filename":"posts/6730.md","__url":"/he-dieu-hanh-nao-se-la-vua-trong-tuong-lai/","__resourceUrl":"/he-dieu-hanh-nao-se-la-vua-trong-tuong-lai/index.html","__dataUrl":"/he-dieu-hanh-nao-se-la-vua-trong-tuong-lai/index.html.25f4e418e8dbc6ab1cfc70c6f39bdf3a.json"},{"id":6758,"layout":"Post","route":"top-3-text-editor-for-web-development","title":"Top 3 Text Editor For Web Development","tags":["web"],"date":"2015-05-01T07:19:17.170Z","author":{"username":"david15894","avatar":"/user_avatar/daynhauhoc.com/david15894/{size}/9742_1.png"},"description":"Nếu bạn đang phân vân không biết chọn text editor nào phù hợp, thì đây là 3 lựa chọn cho bạn :smiley: . \n1.Sublime Text 3 http&#x3A;//www…","__filename":"posts/6758.md","__url":"/top-3-text-editor-for-web-development/","__resourceUrl":"/top-3-text-editor-for-web-development/index.html","__dataUrl":"/top-3-text-editor-for-web-development/index.html.902b78fa03d4263be45134df39677a8a.json"},{"id":6762,"layout":"Post","route":"tan-man-ve-mat-ma-hien-dai-part-1","title":"Tản mạn về Mật mã hiện đại (part 1)","tags":["security","rsa"],"date":"2015-05-01T07:56:22.461Z","author":{"username":"thanhmssl10","avatar":"/user_avatar/daynhauhoc.com/thanhmssl10/{size}/2345_1.png"},"description":"Bài viết được post tại đây: http&#x3A;//portal.daynhauhoc.com/p/tan-man-ve-mat-ma-hien-dai-part-1/\n\n\\#Tản mạn về Mật mã hiện đại  (part…","__filename":"posts/6762.md","__url":"/tan-man-ve-mat-ma-hien-dai-part-1/","__resourceUrl":"/tan-man-ve-mat-ma-hien-dai-part-1/index.html","__dataUrl":"/tan-man-ve-mat-ma-hien-dai-part-1/index.html.a7b80d9618a512d0869d324a5cc10f08.json"},{"id":6818,"layout":"Post","route":"tan-man-ve-mat-ma-hien-dai-part-2","title":"Tản mạn về Mật mã hiện đại (part 2)","tags":["security","photon"],"date":"2015-05-02T12:25:53.828Z","author":{"username":"thanhmssl10","avatar":"/user_avatar/daynhauhoc.com/thanhmssl10/{size}/2345_1.png"},"description":"\\#Tản mạn về Mật mã hiện đại  (part 2)\n\nỞ bài viết trước mình đã giới thiệu các bạn về sơ bộ về mã RSA, còn ở bài này mình sẽ nói về tương…","__filename":"posts/6818.md","__url":"/tan-man-ve-mat-ma-hien-dai-part-2/","__resourceUrl":"/tan-man-ve-mat-ma-hien-dai-part-2/index.html","__dataUrl":"/tan-man-ve-mat-ma-hien-dai-part-2/index.html.076745b4cec951ec3a7f708b00452cff.json"},{"id":6862,"layout":"Post","route":"can-than-khi-truyen-x-vao-mot-function-like-macro","title":"Cẩn thận khi truyền ++x vào một function-like macro","tags":null,"date":"2015-05-04T03:27:20.104Z","author":{"username":"ltd","avatar":"/user_avatar/daynhauhoc.com/ltd/{size}/1016_1.png"},"description":"Bài viết được post tại:  http&#x3A;//portal.daynhauhoc.com/p/can-than-khi-truyen-x-vao-mot-function-like-macro/\n\n1.Có thể các bạn đã biết…","__filename":"posts/6862.md","__url":"/can-than-khi-truyen-x-vao-mot-function-like-macro/","__resourceUrl":"/can-than-khi-truyen-x-vao-mot-function-like-macro/index.html","__dataUrl":"/can-than-khi-truyen-x-vao-mot-function-like-macro/index.html.8d020a216d9c92cc9f300a34d4b132ca.json"},{"id":6907,"layout":"Post","route":"wpf-va-mvvm-phan-4-ung-dung-trong-wpf","title":"WPF và MVVM – Phần 4: Ứng dụng trong WPF","tags":["c-sharp"],"date":"2015-05-05T09:55:12.620Z","description":"Một khái niệm dễ nhầm lẫn khá phổ biến mà tôi thấy mọi người khi bắt đầu với WPF là họ cảm thấy rằng đó là khó tiếp cận, quá phức tạp và quá…","__filename":"posts/6907.md","__url":"/wpf-va-mvvm-phan-4-ung-dung-trong-wpf/","__resourceUrl":"/wpf-va-mvvm-phan-4-ung-dung-trong-wpf/index.html","__dataUrl":"/wpf-va-mvvm-phan-4-ung-dung-trong-wpf/index.html.97e4fc010ff7555435c1cd1085336e71.json"},{"id":6921,"layout":"Post","route":"lam-sao-de-su-dung-bien-hieu-qua-hon-part1","title":"Làm sao để sử dụng biến hiệu quả hơn (part1)","tags":["coding-style"],"date":"2015-05-05T17:12:29.073Z","author":{"username":"thanhmssl10","avatar":"/user_avatar/daynhauhoc.com/thanhmssl10/{size}/2345_1.png"},"description":"Khi chương trình còn đơn giản thì việc sử dụng biến thường không thành vấn đề, nhưng khi bạn làm những chương trình lớn hơn thì việc sử dụng…","__filename":"posts/6921.md","__url":"/lam-sao-de-su-dung-bien-hieu-qua-hon-part1/","__resourceUrl":"/lam-sao-de-su-dung-bien-hieu-qua-hon-part1/index.html","__dataUrl":"/lam-sao-de-su-dung-bien-hieu-qua-hon-part1/index.html.b5f98c43c2cdc0a899b072fc739e929b.json"},{"id":6936,"layout":"Post","route":"lam-sao-de-su-dung-bien-hieu-qua-hon-part2","title":"Làm sao để sử dụng biến hiệu quả hơn (part2)","tags":["coding-style"],"date":"2015-05-06T03:16:39.897Z","author":{"username":"thanhmssl10","avatar":"/user_avatar/daynhauhoc.com/thanhmssl10/{size}/2345_1.png"},"description":"Bài [viết trước][1] mình đã nói về cách khai báo biến và khởi tạo biến và bài viết này sẽ nói về cách chọn phạm vi biến sao cho code hiệu…","__filename":"posts/6936.md","__url":"/lam-sao-de-su-dung-bien-hieu-qua-hon-part2/","__resourceUrl":"/lam-sao-de-su-dung-bien-hieu-qua-hon-part2/index.html","__dataUrl":"/lam-sao-de-su-dung-bien-hieu-qua-hon-part2/index.html.2d7df1ca1942bbcdab5bfcc73306f9c0.json"},{"id":7030,"layout":"Post","route":"lam-blog-bang-jekyll-su-dung-host-cua-github-level-sieu-co-ban","title":"Làm Blog bằng Jekyll sử dụng host của Github (level siêu cơ bản)","tags":["blog","github","jekyll"],"date":"2015-05-08T13:11:33.302Z","author":{"username":"thanhmssl10","avatar":"/user_avatar/daynhauhoc.com/thanhmssl10/{size}/2345_1.png"},"description":"\\#Làm Blog bằng Jekyll sử dụng host của Github (level siêu cơ bản)\n\nHôm trước thấy có anh giới thiệu về cái này nên nghịch thử cho biết, vừa…","__filename":"posts/7030.md","__url":"/lam-blog-bang-jekyll-su-dung-host-cua-github-level-sieu-co-ban/","__resourceUrl":"/lam-blog-bang-jekyll-su-dung-host-cua-github-level-sieu-co-ban/index.html","__dataUrl":"/lam-blog-bang-jekyll-su-dung-host-cua-github-level-sieu-co-ban/index.html.dfed9b43f4116c86d079efaa6956c296.json"},{"id":7032,"layout":"Post","route":"comment-code-tai-sao-chung-ta-nen-comment-code-p1","title":"Comment Code - Tại sao chúng ta nên Comment Code? (p1)","tags":["comment","coding-style"],"date":"2015-05-08T14:43:06.789Z","description":"Comment code là một trong những chủ đề được tranh luận rộng rãi trong thế giới lập trình. Đó là điều mình được học ngay từ khi học môn đầu…","__filename":"posts/7032.md","__url":"/comment-code-tai-sao-chung-ta-nen-comment-code-p1/","__resourceUrl":"/comment-code-tai-sao-chung-ta-nen-comment-code-p1/index.html","__dataUrl":"/comment-code-tai-sao-chung-ta-nen-comment-code-p1/index.html.5766a8c960531a7855602ab8ebae5550.json"},{"id":7038,"layout":"Post","route":"tai-lieu-lap-trinh-c-for-newbie-chuong-2-nhung-ky-thuat-nang-cao","title":"[Tài liệu lập trình C for newbie] - Chương 2: Những kỹ thuật nâng cao!","tags":["document","c"],"date":"2015-05-08T17:30:09.509Z","author":{"username":"TBM_2512","avatar":"/user_avatar/daynhauhoc.com/tbm_2512/{size}/501_1.png"},"description":"Hello every body. Long time no see!\n\nTrước tiên mình xin gửi lời cảm ơn đến Mr.Đạt vì đã tạo ra một sân chơi chung cho mọi người có cơ hội…","__filename":"posts/7038.md","__url":"/tai-lieu-lap-trinh-c-for-newbie-chuong-2-nhung-ky-thuat-nang-cao/","__resourceUrl":"/tai-lieu-lap-trinh-c-for-newbie-chuong-2-nhung-ky-thuat-nang-cao/index.html","__dataUrl":"/tai-lieu-lap-trinh-c-for-newbie-chuong-2-nhung-ky-thuat-nang-cao/index.html.2e6085427cd707e40a73dfb85fc997c2.json"},{"id":7063,"layout":"Post","route":"lam-sao-de-su-dung-bien-hieu-qua-hon-part-4","title":"Làm sao để sử dụng biến hiệu quả hơn (part 4)","tags":["coding-style"],"date":"2015-05-09T09:00:57.925Z","author":{"username":"thanhmssl10","avatar":"/user_avatar/daynhauhoc.com/thanhmssl10/{size}/2345_1.png"},"description":"\\#Làm sao để sử dụng biến hiệu quả hơn  (part 4)\n\nSử dụng một biến với nhiều mục đích đôi khi làm chúng ta có  cảm giác như tiết kiệm được…","__filename":"posts/7063.md","__url":"/lam-sao-de-su-dung-bien-hieu-qua-hon-part-4/","__resourceUrl":"/lam-sao-de-su-dung-bien-hieu-qua-hon-part-4/index.html","__dataUrl":"/lam-sao-de-su-dung-bien-hieu-qua-hon-part-4/index.html.3fc306d680d9eb5c25d3d77da4dbe14b.json"},{"id":7092,"layout":"Post","route":"struct-la-gi-ban-chat-va-cach-su-dung","title":"Struct là gì? bản chất và cách sử dụng","tags":["union","data-structures","struct","c++"],"date":"2015-05-10T14:24:23.654Z","description":"Sử dụng struct trong chương trình\n\nOHM, lần trước chúng ta đã bàn về [Đệ Quy][1] rồi, bây giờ chúng ta lại quay về vấn đề cơ bản của ngôn…","__filename":"posts/7092.md","__url":"/struct-la-gi-ban-chat-va-cach-su-dung/","__resourceUrl":"/struct-la-gi-ban-chat-va-cach-su-dung/index.html","__dataUrl":"/struct-la-gi-ban-chat-va-cach-su-dung/index.html.172445a580cb55c9f0f086df600e6be3.json"},{"id":7251,"layout":"Post","route":"cach-tai-them-ram-cho-laptop-ban-da-thu-chua-d","title":"Cách \"tải thêm\" RAM cho laptop, bạn đã thử chưa :D","tags":["hp"],"date":"2015-05-14T16:26:03.937Z","author":{"username":"thanhmssl10","avatar":"/user_avatar/daynhauhoc.com/thanhmssl10/{size}/2345_1.png"},"description":"Đợt trước thằng bạn mình nó dùng một con lap HP 1000 nhưng mà nó kêu ram yếu quá nên nó bảo mình xem hộ: Đây là cuộc đối thoại :\"ớ đù ram…","__filename":"posts/7251.md","__url":"/cach-tai-them-ram-cho-laptop-ban-da-thu-chua-d/","__resourceUrl":"/cach-tai-them-ram-cho-laptop-ban-da-thu-chua-d/index.html","__dataUrl":"/cach-tai-them-ram-cho-laptop-ban-da-thu-chua-d/index.html.0b19ea88d2dc2b6dc6c41fd0c4c6a837.json"},{"id":7275,"layout":"Post","route":"cai-dat-plugin-soat-loi-code-style-python-flake8-lint-cho-sublime-text-2","title":"Cài đặt Plugin soát lỗi code style Python Flake8 Lint cho Sublime Text 2","tags":["pep8","sublime-text-2","python"],"date":"2015-05-15T07:24:48.293Z","author":{"username":"thanhmssl10","avatar":"/user_avatar/daynhauhoc.com/thanhmssl10/{size}/2345_1.png"},"description":"Mình đang định học code Python theo style [PEP8][1] với cả mới chuyển nhà sang SublimeText nên quyết định mày mò tìm/cài đặt Plugin hỗ trợ…","__filename":"posts/7275.md","__url":"/cai-dat-plugin-soat-loi-code-style-python-flake8-lint-cho-sublime-text-2/","__resourceUrl":"/cai-dat-plugin-soat-loi-code-style-python-flake8-lint-cho-sublime-text-2/index.html","__dataUrl":"/cai-dat-plugin-soat-loi-code-style-python-flake8-lint-cho-sublime-text-2/index.html.50e616dbd47e20250c32fdc6836437fd.json"},{"id":7287,"layout":"Post","route":"giao-trinh-ky-thuat-lap-trinh-c-can-ban-va-nang-cao-phien-ban-moi-dep-ro-net-co-day-du-bookmarks","title":"Giáo Trình Kỹ Thuật Lập Trình C Căn Bản Và Nâng Cao phiên bản mới, đẹp, rõ nét, có đầy đủ bookmarks","tags":["document","c"],"date":"2015-05-15T14:33:43.891Z","description":"Mặc dù trên mạng đã có ebook này nhưng là phiên bản cũ 2006, bản Ebook này scan sách mới nhất (cũng không khác phiên bản cũ nhiều là mấy…","__filename":"posts/7287.md","__url":"/giao-trinh-ky-thuat-lap-trinh-c-can-ban-va-nang-cao-phien-ban-moi-dep-ro-net-co-day-du-bookmarks/","__resourceUrl":"/giao-trinh-ky-thuat-lap-trinh-c-can-ban-va-nang-cao-phien-ban-moi-dep-ro-net-co-day-du-bookmarks/index.html","__dataUrl":"/giao-trinh-ky-thuat-lap-trinh-c-can-ban-va-nang-cao-phien-ban-moi-dep-ro-net-co-day-du-bookmarks/index.html.88f978886adf6ddfc4c99c5e84441683.json"},{"id":7734,"layout":"Post","route":"suy-nghi-cua-1-lap-trinh-vien-phan-2","title":"Suy nghĩ của 1 lập trình viên ! ( Phần 2 )","tags":null,"date":"2015-05-27T18:44:39.593Z","author":{"username":"khiemnvd","avatar":"/user_avatar/daynhauhoc.com/khiemnvd/{size}/9211_1.png"},"description":"tiếp theo phần 1 [http://daynhauhoc.com/t/suy-nghi-cua-1-lap-trinh-vien-phan-1/7733][1]\n\nTrong bài viết trước, tôi đã cố gắng mô tả một số…","__filename":"posts/7734.md","__url":"/suy-nghi-cua-1-lap-trinh-vien-phan-2/","__resourceUrl":"/suy-nghi-cua-1-lap-trinh-vien-phan-2/index.html","__dataUrl":"/suy-nghi-cua-1-lap-trinh-vien-phan-2/index.html.629cb7ff7f1e0514ac59ce10c7275cd7.json"},{"id":7871,"layout":"Post","route":"101-loi-co-ban-trong-lap-trinh-c","title":"101 Lỗi cơ bản trong Lập Trình C","tags":["c"],"date":"2015-06-01T14:15:36.242Z","description":"Tình cờ lụm được trên mạng nên chia sẻ ngay cho mọi người :)\n","__filename":"posts/7871.md","__url":"/101-loi-co-ban-trong-lap-trinh-c/","__resourceUrl":"/101-loi-co-ban-trong-lap-trinh-c/index.html","__dataUrl":"/101-loi-co-ban-trong-lap-trinh-c/index.html.bdb385446015130970c01b0a7defa679.json"},{"id":8069,"layout":"Post","route":"tool-ho-tro-xu-li-loi-man-hinh-xanh-chet-choc","title":"Tool hỗ trợ xử lí lỗi màn hình xanh chết chóc","tags":["tool","bsod"],"date":"2015-06-07T08:15:57.025Z","author":{"username":"thanhmssl10","avatar":"/user_avatar/daynhauhoc.com/thanhmssl10/{size}/2345_1.png"},"description":"Tool này sẽ đọc các file dmp trong C:\\\\Windows\\\\minidump để đưa ra các thông tin về lỗi màn hình xanh\nhttp&#x3A;//www.nirsoft.net/utils/blue…","__filename":"posts/8069.md","__url":"/tool-ho-tro-xu-li-loi-man-hinh-xanh-chet-choc/","__resourceUrl":"/tool-ho-tro-xu-li-loi-man-hinh-xanh-chet-choc/index.html","__dataUrl":"/tool-ho-tro-xu-li-loi-man-hinh-xanh-chet-choc/index.html.e9781da5bdcf1c53101fe0a09dc3edb3.json"},{"id":8257,"layout":"Post","route":"nghe-thuat-cua-code-de-doc-phan-1","title":"Nghệ thuật của code \"dễ đọc\" (Phần 1)","tags":["coding-style"],"date":"2015-06-13T16:43:14.561Z","description":"Chào các bạn, hôm nọ mình có đọc được bài http&#x3A;//daynhauhoc.com/t/lam-sao-de-su-dung-bien-hieu-qua-hon-part1/6921 của anh thanhmssl10…","__filename":"posts/8257.md","__url":"/nghe-thuat-cua-code-de-doc-phan-1/","__resourceUrl":"/nghe-thuat-cua-code-de-doc-phan-1/index.html","__dataUrl":"/nghe-thuat-cua-code-de-doc-phan-1/index.html.d925d1e6473f9469ac0faeec5c497197.json"},{"id":8330,"layout":"Post","route":"cach-hoc-lap-trinh-thanh-cong","title":"Cách học lập trình thành công","tags":["learn","how-to","programming"],"date":"2015-06-15T13:56:33.572Z","author":{"username":"ltd","avatar":"/user_avatar/daynhauhoc.com/ltd/{size}/1016_1.png"},"description":"Đạt đang học Python, cho vui, và làm [Video hướng dẫn Python][1], lấy tiếng :sunglasses:. \n\nMình thấy cách học lập trình hay nhất, hiệu quả…","__filename":"posts/8330.md","__url":"/cach-hoc-lap-trinh-thanh-cong/","__resourceUrl":"/cach-hoc-lap-trinh-thanh-cong/index.html","__dataUrl":"/cach-hoc-lap-trinh-thanh-cong/index.html.03b7b3be792d740ffc67383e633d2031.json"},{"id":8457,"layout":"Post","route":"lam-the-nao-de-hien-thi-va-nhap-tieng-viet-trong-cmd-windows","title":"Làm thế nào để hiển thị và nhập tiếng Việt trong cmd Windows","tags":["unicode","windows"],"date":"2015-06-18T14:21:44.971Z","author":{"username":"thanhmssl10","avatar":"/user_avatar/daynhauhoc.com/thanhmssl10/{size}/2345_1.png"},"description":"Bước 1: Mở cmd gõ chcp 65001 \nhttps&#x3A;//msdn.microsoft.com/en-us/library/windows/desktop/dd317756%28v=vs.85%29.aspx\n\nBước 2: Chuột phải…","__filename":"posts/8457.md","__url":"/lam-the-nao-de-hien-thi-va-nhap-tieng-viet-trong-cmd-windows/","__resourceUrl":"/lam-the-nao-de-hien-thi-va-nhap-tieng-viet-trong-cmd-windows/index.html","__dataUrl":"/lam-the-nao-de-hien-thi-va-nhap-tieng-viet-trong-cmd-windows/index.html.3f2f27ec486650787c01f537877fb64a.json"},{"id":8539,"layout":"Post","route":"tai-sao-moi-nguoi-lai-thich-dung-tag-khong-ly-do-nhu-vay","title":"Tại sao mọi người lại thích dùng [tag] không lý do như vậy?","tags":["tag"],"date":"2015-06-20T15:09:44.592Z","author":{"username":"ltd","avatar":"/user_avatar/daynhauhoc.com/ltd/{size}/1016_1.png"},"description":"Đạt thấy ở nhiều diễn đàn ở VN hiện nay, có cả dnh, hay có các topic sử dụng tag một cách lạ lùng, ví dụ như\n\n[Tâm sự] bạn\n\nHoặc\n\n[U23 Việt…","__filename":"posts/8539.md","__url":"/tai-sao-moi-nguoi-lai-thich-dung-tag-khong-ly-do-nhu-vay/","__resourceUrl":"/tai-sao-moi-nguoi-lai-thich-dung-tag-khong-ly-do-nhu-vay/index.html","__dataUrl":"/tai-sao-moi-nguoi-lai-thich-dung-tag-khong-ly-do-nhu-vay/index.html.92e054a60d64f5dd57fa1f521a2f14e8.json"},{"id":8542,"layout":"Post","route":"su-dung-hashtag-dung-cach-tren-mang-xa-hoi","title":"Sử dụng hashtag # đúng cách trên mạng xã hội","tags":["howto","hashtag"],"date":"2015-06-20T15:31:42.057Z","author":{"username":"ltd","avatar":"/user_avatar/daynhauhoc.com/ltd/{size}/1016_1.png"},"description":"Theo định nghĩa [Wikipedia][1] thì hashtag là một cách để đánh dấu một chủ đề bằng các sử dụng dấu # và theo sau là một chữ, câu không có…","__filename":"posts/8542.md","__url":"/su-dung-hashtag-dung-cach-tren-mang-xa-hoi/","__resourceUrl":"/su-dung-hashtag-dung-cach-tren-mang-xa-hoi/index.html","__dataUrl":"/su-dung-hashtag-dung-cach-tren-mang-xa-hoi/index.html.de03c1a7286c7798f3c056a29dfb1ad1.json"},{"id":8626,"layout":"Post","route":"co-gi-moi-trong-javascript","title":"Có gì mới trong javascript","tags":["wiki","programming","javascript"],"date":"2015-06-22T14:22:11.551Z","description":"Đang học lại javascript thấy cái này hay [javascript es6][1]\n\nMình thấy có một số cái mới khá hay nên chia sẻ cùng mọi người :smile…","__filename":"posts/8626.md","__url":"/co-gi-moi-trong-javascript/","__resourceUrl":"/co-gi-moi-trong-javascript/index.html","__dataUrl":"/co-gi-moi-trong-javascript/index.html.251937a2ff183f17391bf22a3570a4cd.json"},{"id":9290,"layout":"Post","route":"nguoi-vn-minh-gioi-qua-phai-rang-phan-dau","title":"Người VN mình giỏi quá, phải ráng phấn đấu","tags":null,"date":"2015-07-10T02:04:27.754Z","author":{"username":"ltd","avatar":"/user_avatar/daynhauhoc.com/ltd/{size}/1016_1.png"},"description":"Sáng nay đang StackOverflow thì đọc thấy câu trả lời này hay, tuy không cụ thể. Thử xem profile của ông này thế nào mà điểm cao thế\n\n \n\nOh…","__filename":"posts/9290.md","__url":"/nguoi-vn-minh-gioi-qua-phai-rang-phan-dau/","__resourceUrl":"/nguoi-vn-minh-gioi-qua-phai-rang-phan-dau/index.html","__dataUrl":"/nguoi-vn-minh-gioi-qua-phai-rang-phan-dau/index.html.0151d1a57040871932122d48d34a3db2.json"},{"id":9361,"layout":"Post","route":"review-kinh-thuc-tai-ao-smilecardboard","title":"[Review] Kính thực tại ảo SmileCardboard","tags":["vr","review"],"date":"2015-07-11T15:21:04.420Z","description":"Từ bé đã mê cái kính thực tại ảo, ôm vào mặt  bước vào trong bộ phim để tha hồ tự sướng^^. Tuy nhiên mơ ước chỉ là mơ ước, vì những cái kính…","__filename":"posts/9361.md","__url":"/review-kinh-thuc-tai-ao-smilecardboard/","__resourceUrl":"/review-kinh-thuc-tai-ao-smilecardboard/index.html","__dataUrl":"/review-kinh-thuc-tai-ao-smilecardboard/index.html.131b767c8ba2379f374726c55a2b5231.json"},{"id":9704,"layout":"Post","route":"lam-sao-de-cau-hoi-cua-minh-thu-hut-duoc-nhieu-views-va-mau-co-cau-tra-loi-tren-daynhauhoc","title":"Làm sao để câu hỏi của mình thu hút được nhiều views và mau có câu trả lời trên DayNhauHoc?","tags":["share","how-to-ask","wiki"],"date":"2015-07-19T14:07:53.878Z","author":{"username":"ltd","avatar":"/user_avatar/daynhauhoc.com/ltd/{size}/1016_1.png"},"description":"Đạt thấy có nhiều topic mất rất nhiều thời gian để thu hút sự chú ý của các thành viên khác và nhận được câu trả lời. Bài viết này chia sẻ…","__filename":"posts/9704.md","__url":"/lam-sao-de-cau-hoi-cua-minh-thu-hut-duoc-nhieu-views-va-mau-co-cau-tra-loi-tren-daynhauhoc/","__resourceUrl":"/lam-sao-de-cau-hoi-cua-minh-thu-hut-duoc-nhieu-views-va-mau-co-cau-tra-loi-tren-daynhauhoc/index.html","__dataUrl":"/lam-sao-de-cau-hoi-cua-minh-thu-hut-duoc-nhieu-views-va-mau-co-cau-tra-loi-tren-daynhauhoc/index.html.461a5307342ce11b46c03fdbd54322b4.json"}];window.__INITIAL_STATE__ = {"pages":{"/struct-la-gi-ban-chat-va-cach-su-dung/":{"head":{"id":7092,"layout":"Post","route":"struct-la-gi-ban-chat-va-cach-su-dung","title":"Struct là gì? bản chất và cách sử dụng","tags":["union","data-structures","struct","c++"],"date":"2015-05-10T14:24:23.654Z","description":"Sử dụng struct trong chương trình\n\nOHM, lần trước chúng ta đã bàn về [Đệ Quy][1] rồi, bây giờ chúng ta lại quay về vấn đề cơ bản của ngôn…"},"body":"<h2 id=\"s-dng-struct-trong-chng-trnh\"><a href=\"#s-dng-struct-trong-chng-trnh\" class=\"statinamic-HeadingAnchor\">#</a>Sử dụng struct trong chương trình</h2>\n<p>OHM, lần trước chúng ta đã bàn về <a href=\"http://daynhauhoc.com/t/de-quy-dich-boi-breakdown/5719\">Đệ Quy</a> rồi, bây giờ chúng ta lại quay về vấn đề cơ bản của ngôn ngữ: STRUCT.<br>\nTrong bài này mình sẽ  bàn về những vấn đề cơ bản nhất về struct và kèm theo những ví dụ cũng cơ bản không kém. Do bài dài nên mình không đủ thời gian dịch và update hằng ngày nên mọi người bookmark lại và đọc theo ngày nhé.<br>\nBây giờ hãy mở đầu Struct bằng một ví dụ minh họa bên dưới nhé:</p>\n<pre><code>#include  &lt;iostream&gt;\nusing namespace std;\nstruct inflatable\n{\n    char name[20];\n    float volume;\n    double price;\n};\n\nint main()\n{\n    inflatable guest =\n    {\n        &quot;Glorious Gloria&quot;,    //namevalue\n        1.88,                //volum value\n        29.99                //price value\n    };                        //guest is  structure variable of  type inflatable\n    inflatable pal =\n    {\n        &quot;Audacious Arthur&quot;,\n        3.12,\n        32.99\n    };                        //pal is second variable of  type inflatable\n    //Note: som implementations require using static  inflatable guest =\n    cout &lt;&lt; &quot;Expand your guest  list with &quot; &lt;&lt; guest.name;\n    cout &lt;&lt; &quot; and &quot; &lt;&lt; pal.name &lt;&lt; endl;\n    //pal.name is  the name member of the pal variable\n    cout &lt;&lt; &quot;You can have both for $&quot; &lt;&lt; guest.price + pal.price &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>Code mình build bằng Visual 2013 nên nếu  những ai build bằng IDE khác thì có thể thay đổi chút ít để phù hợp, và dưới đây là kết quả của đoạn code trên:</p>\n<blockquote>\n<p>Expand your gues list with Glorious Gloria and Audacious Arthur!<br>\nYou can have both for $62.98!</p>\n</blockquote>\n<p><strong>Lưu ý về chương trình</strong><br>\nMột điều cực kỳ tối quan trọng là cách mà bạn khai báo dữ liệu Struct trong ví dụ trên. Có hai lựa chọn cho chương trình structur.cpp. Bạn có thể đặt khai báo bên trong hàm main() và ngoài hàm. Và bạn cũng nên nhớ rằng struct chúng ta cũng có thể gọi nó là 1 kiểu dữ liệu được định nghĩa riêng. Điều này cũng có nghĩa rằng nó cũng có dạng “Biến nội bộ” và “Biến toàn cục”. Dựa vào vị trí đặt của Struct thì chúng ta có thể suy ra đươc biến Struct này là biến nội bộ hay biến toàn cục. Tùy vào vị trí đặt Struct thì chúng ta có cách sử  dụng khác nhau<br>\nNotice: Trong bài này mình tạm gọi Struct là 1 biến để ngắn gọn nhé.<br>\nBiến Struct toàn cục: là loại biến đặt bên ngoài hàm, được khai báo sau khi khai báo thư viện và namspace, loại biến này sử dụng được cho mọi hàm trong chương trình và chúng ta gọi tên tiếng anh mĩ miều là external declaration<br>\nBiến Struct cục bộ: là loại biến được đặt bên trong hàm, được khai báo trong 1 hàm cố định và không được truy xuất bởi hàm khác, nói cách khác đó là biến chỉ sử dụng được bởi các funtion đặt chung dấu {} với nó.</p>\n<p>Ví dụ</p>\n<pre><code>int main()\n{\n    struct ID\n    {\n        int a;\n        int b;\n    };\n}\n</code></pre>\n<p>Như các bạn thấy đấy, Struct cũng được máy tính đối xử như 1 biến vậy, nó có thể được khai báo cục bộ hoặc toàn cục. Với cách khai báo toàn cục thì nó có thể được sử dụng bởi tất cả các hàm.<br>\nQuay trở lại với ngôn ngữ C++, ngôn ngữ này không khuyến khích sử dụng biến toàn cục (external variable) nhưng nó khuyến khích sử dụng các struct extenal variable (có thể gọi là cấu trúc toàn cục).</p>\n<p>Bây giờ chúng ta lại nhìn cách mình sử dụng struct bênt trên. Cách mà mình khởi tạo 1 biến:</p>\n<pre><code>inflatable guest = \n{ \n    &quot;Glorious Gloria&quot;,    //namevalue\n    1.88,                //volum value\n    29.99                //price value\n};    \n</code></pre>\n<p>Giống như cách bạn truyền tham số vào một mảng, bạn cần để trong một dấu {} và cách nhau bởi một dấuphẩy. Mỗi giá trị được đặt trong một dòng. Tuy nhiên bạn có thể đặt tất  cả vào cùng 1 dòng mà không xảy ra lỗi. Nhưng nhớ rằng phải ngăn cách chúng bằng dấu phẩy, đó là quy tắc nếu bạn không muốn gặp lỗi khi compile bằng bất cứ complier nào.</p>\n<pre><code>Inflatable duck = {“daphne”, 0.12, 9.98};\n</code></pre>\n<p>Bạn có  thể khởi tạo mỗi  giá trị của struct bằng các kiểu dữ liệu  thích hợp. Trong ví dụ mình khái báo bên trên, biến name mình đã khai báo một mãng kiểu char, nhưng nếu sử dụng C++ thì bạn có thể khai báo  kiểu string, điều này không ảnh hưởng tới cách mà chương trình  chạy.</p>\n<p>Mỗi giá trị của Struct được đối xử như là một biến của kiểu dữ liệu. Như vậy, khi ta sử dụng biến pal.price thì đây là một biến kiểu double và pal.name là một kiểu char[]. Và khi mà ta sử dụng lệnh cout để xuất dữ liệu ra màn hình với biến pal.name thì máy tính sẽ tự động chọn kiểu string (hay char[]). Cũng như thế, pal.name cũng là một mảng ký tự và chúng ta có thể sử dụng nó như là một mảng. Khi bạn truy xuất giá trị tại pal.name[0] thì bạn sẽ nhận được một giá tị ‘A’, nhưng khi bạn truy xuất pal[0] thì nó hoàn toàn vô nghĩa bởi vì pal là một struct chứ không phải là một mảng(array).</p>\n<hr>\n<h2 id=\"khai-bo-struct-trong-c-11\"><a href=\"#khai-bo-struct-trong-c-11\" class=\"statinamic-HeadingAnchor\">#</a>KHAI BÁO STRUCT TRONG C++ 11</h2>\n<hr>\n<p>Giống như mảng, C++11 mở rộng cách mà ta có thể khai báo và sử dụng struct một cách linh hoạt. Thay vì chúng ta cần phải sử dụng dấu “=” thì nay chúng ta có thể quên nó đi.</p>\n<pre><code>Inflatable duck {“daphne”, 0.12, 9.98};\n</code></pre>\n<p>Tiếp theo, mỗi thành phần chưa được gán trị  thay vì nó sẽ là một giá trị rác thì nay mặc định sẽ là 0. Ví dụ, khi mà khai báo một biến có kiểu inflatable mayor thì giá trị ta nhận về khi truy xuất mayor.price hay mayor.volume sẽ  là  0.<br>\nTuy nhiên ta có mayor.name được định nghĩa là  một  mảng ký tự thì tất cả các byte trong mảng mayor.name sẽ được đặt là 0 (hoặc  gọi cách khác đây là ký tự NULL).<br>\nCách mà ta khai báo biến mayor để có các giá trị trên là:</p>\n<pre><code>Inflatable mayor{};\n</code></pre>\n<h2 id=\"liu-struct-c-th-s-dng-c-class-string-khng\"><a href=\"#liu-struct-c-th-s-dng-c-class-string-khng\" class=\"statinamic-HeadingAnchor\">#</a>LIỆU STRUCT CÓ THỂ SỬ DỤNG ĐƯỢC CLASS STRING KHÔNG?</h2>\n<p>Liệu chúng ta có thể dùng các đối tượng bên trong Class String để sử dụng cho mảng ký tự name? Tất nhiên, bạn có thể khai báo một structure giống thế này:</p>\n<pre><code>struct inflatable\n{\n    std::string name;\n    float volume;\n    double price;\n};\n</code></pre>\n<p>Tất nhiên câu trả lời là có thể rồi trừ khi bạn đang sử dụng một IDE hay compiler bản cũ hoặc đã lỗi thời từ lâu thì nó không được hỗ trợ khai báo structure với class string.</p>\n<p>Hãy chắc chắn rằng structure bạn khai báo có quyền truy cập vào namespace std. Bạn có thể khai báo sau khi khai báo thư viện hoặc trong khi khai báo struct như cách mà mình làm bên trên, sử  dụng: std: :string</p>\n<h2 id=\"mt-s-thuc-tnh-khc-ca-struct\"><a href=\"#mt-s-thuc-tnh-khc-ca-struct\" class=\"statinamic-HeadingAnchor\">#</a>MỘT SỐ THUỘC TÍNH KHÁC CỦA STRUCT</h2>\n<p>C++ tạo cho người dùng một môi trường đơn giản nhất có thể để sử dụng “built-in-type”. Ví dụ,  bạn có thể  sử  dụng cấu trúc như là một đối số, và bạn có thể sử dụng structure  như một kiểu dữ liệu của hàm  và return giá trị của  structure đó. Tất nhiên bạn có thể sử dụng các operator (=)  để gán một giá trị của struct cho một biến khác cùng với kiểu đã khai báo. Ví dụ:<br>\n<br>\nchar[50] palprice = pal.prices;</p>\n<p>Như chúng ta  thấy  đấy, các “member” được khai báo trong struct cũng được đối  xử như là một variable. Bây giờ chúng ta hãy xem ví  dụ tiếp theo bên dưới</p>\n<pre><code>#include  &lt;iostream&gt;\nusing namespace std;\nstruct inflatable\n{\n    char name[20];\n    float volume;\n    double price;\n};\n\nint main()\n{\n    inflatable bouquet =\n    {\n        &quot;sunflower&quot;,\n        0.20,\n        12.49\n    };\n    inflatable pal =\n    {\n        &quot;Audacious Arthur&quot;,\n        3.12,\n        32.99\n    };\n    inflatable choice;\n    cout &lt;&lt; &quot;bouquet: &quot; &lt;&lt; bouquet.name &lt;&lt; &quot;for $&quot; &lt;&lt; bouquet.price &lt;&lt; endl;\n    choice = bouquet;\n    cout &lt;&lt; &quot;choice: &quot; &lt;&lt; choice.name &lt;&lt; &quot;for $&quot; &lt;&lt; choice.price &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>Và đây là kết quả của đoạn code bên trên:</p>\n<blockquote>\n<p>Bouquet: sunflower for $12.49<br>\nChoice: sunflower for $12.49</p>\n</blockquote>\n<p>Như bạn đã thấy, cả hai giá trị của Bouquet và Choice đều bằng nhau. Bạn có thể phối hợp định nghĩa 1 cấu trúc và gán thẳng variable cho nó. Để làm được việc này, bạn khai báo thẳng variable sau khi khai báo một struct</p>\n<pre><code>truct perks\n{\n    int key_number;\n    char car[12];\n} mr_smith, ms_jones;\n</code></pre>\n<p>Mặc dù cách này vẫn giúp chương trình hoạt động bình thường, tuy nhiên các lập trình viên đều chia ra vì viết giống vậy rất khó để theo dõi chương trình và sửa lỗi.</p>\n<p>Một cách khác là bạn có thể tạo dựng 1 struct không tên và gọi một variable sau khi đã định nghĩa xong struct. Như ví dụ dưới đây:</p>\n<pre><code>struct perks\n{\n    int key_number;\n    char car[12];\n} mr_glitz =\n{\n    7,\n    &quot;Packard&quot;\n};\n</code></pre>\n<p>Trong đoạn code này:</p>\n<pre><code>struct\n{\n    int x;\n    int y;\n} position;\n</code></pre>\n<p>Chương trình sẽ tạo dựng một biến struct và gọi nó là position. Bạn có thể truy xuất các “member” của position bằng “membership operation”, ví dụ như là  position.x, nhưng nếu bạn sử  dụng cách khai báo này thì bạn sẽ chỉ có duy nhất một biên postion có thể sử dụng struct này. Và sau đó bạn không thể tạo một biến khác có thể sử dụng chung struct như thế. Nói cách khác, biến position là đặc biệt.</p>\n<h2 id=\"mng-struct\"><a href=\"#mng-struct\" class=\"statinamic-HeadingAnchor\">#</a>MẢNG STRUCT</h2>\n<p>Trong struct inflatable được định nghĩa ở đầu  bàu có chứa một mảng (char name[]). Nó cũng có khả năng tạo mảng mà  các phần tử là struct. Kỹ thuật để tạo nên một mảng kiểu struct chính là cách mà ta hay sử dụng để tạo 1 mảng của 1 kiểu dữ liệu nào đó.</p>\n<pre><code>Inflatable gifts[100]; // array of 100  inflatable structures\n</code></pre>\n<p>Đây là dòng lệnh để tạo ra một mảng có 100 phần tử kiểu &gt; <code>inflatable</code>. Vì thế mỗi phần tử trong mảng từ <code>gifts[0]</code> tới <code>gifts[99]</code> đều  có kiểu của <code>struct inflatable</code>:</p>\n<pre><code>cin &gt;&gt; gifts[0].volume; // use volume member  of  first struct\ncout &lt;&lt; gifts[99].price  &lt;&lt; endl; // display price member if last struct\n</code></pre>\n<p>Nhưng hãy nhớ rằng gifts là tên của mảng chứ không phải là variable, việc truy xuất gift.price sẽ vô nghĩa và bạn sẽ nhanh chóng bị báo lỗi bởi compiler.<br>\nĐể khai báo một mảng struct, ta cũng  có thể ghép chúng lại bằng cách bên dưới:</p>\n<pre><code>Inflatable guests[2] =        // khai báo mảng kiểu struct\n{\n    {“Bambi”, 0.5, 21.99},        //giá trị đầu tiên của mảng\n    {“Godzilla”, 2000, 565.99}    //giá trị tiếp theo\n}\n</code></pre>\n<p>Như cách mọi người thường dùng, bạn có thể định nghĩa bằng cách bạn thích. Ví dụ, cả hai cách định nghĩa có thể đặt ở chung 1 dòng hay tách từng dòng để dễ đọc.</p>\n<p>Ví dụ tiếp theo sẽ hướng dẫn cách mà bạn sẽ sử dụng và truy xuất dữ liệu sử dụng dấu chấm “.” (dot operation)</p>\n<pre><code>#include &lt;iostream&gt;\nstruct inflatable\n{\n    char name[20];\n    float volume;\n    double price;\n};\nint main()\n{\n    using namespace  std;\n    inflatable  guests[2] =\n    {\n        {&quot;Bambi, 0.5, 21.99&quot;},\n        {&quot;Godzilla, 2000, 565.99&quot;}\n    };\n    cout &lt;&lt; &quot;The guests&quot; &lt;&lt; guests[0].name &lt;&lt; &quot; and &quot; &lt;&lt; guests[1].name;\n    cout &lt;&lt; &quot;\\n Have a  combined volume of &quot; &lt;&lt; guests[0].volume + guests[1].volume &lt;&lt; &quot; 2000.5 cubic feet.\\n&quot;;\n    return 0;\n}\n</code></pre>\n<p>Và đây là kết quả sau khi chương trình chạy:</p>\n<blockquote>\n<p>The guests Bambi and Godzilla<br>\nHave a  combined volume of 2000.5 cubic feet.</p>\n</blockquote>\n<h2 id=\"bit-fields-trong-struct\"><a href=\"#bit-fields-trong-struct\" class=\"statinamic-HeadingAnchor\">#</a>BIT FIELDS TRONG STRUCT</h2>\n<p>C++ cũng như C cho phép bạn chỉ định  số lượng bit mà bạn muốn sử dụng. Điều này thực sự hữu dụng khi bạn tạo một data structure, bạn có thể chỉ định bạn cần bao nhiêu bộ nhớ. Vùng Fields này nên là một biến hoặc một kiểu dữ liệu ta không dùng tới. Ví dụ sau:</p>\n<pre><code>Struct torgle_register\n{\n    Unsigned in SN : 4;    // dùng 4 bit cho giá trị SN;\n    Unsigned  int : 4;    // 4 bit này không dùng tới\n    Bool goodIn :  1;    // valid input (1 bit)\n    Bool goodTorgle : 1    // successful torgling\n};\n</code></pre>\n<p>Bạn có thể định nghĩa fields cực kỳ linh hoạt, và bạn có thể sử dụng ký hiệu để truy cập các byte field:</p>\n<pre><code>Torge_register tr = {14, true, false};\n…\nIf(tr.goodIn)\n…\n</code></pre>\n<p>Bit Fields thường được sử dụng trong lập trình cấp thấp cho các vi xử lý. Tuy nhiên bạn có thể sử dụng nó như là 1 flag để đánh dấu khi sử  dụng pointer.</p>\n<h2 id=\"unions\"><a href=\"#unions\" class=\"statinamic-HeadingAnchor\">#</a>UNIONS</h2>\n<p>Union là một kiểu dữ liệu cũng  khá giống struct về cách định nghĩa cùng như cách sử dụng. Nhưng nó khác Struct tại một thời điểm nó chỉ lưu được một giá trị duy nhất.<br>\nQuay trở lại các ví  dụ trước, ta có 1 struct tên <code>Inflatable</code> có chứa nhiều kiểu dữ liệu bên trong. Ta có gọi một “biến” với tên <code>pal</code> và ta  truy xuất dữ liệu theo <code>pal.name, pal.prices….</code> và dữ liệu được truy xuất được lưu vào các biến của <code>pal.name, pal.prices…</code></p>\n<p><strong>Vậy  Union lưu dữ liệu  thế  nào?</strong><br>\nUnion chỉ lưu 1 dữ liệu tại một thời  điểm. Để hiểu rõ hơn thì bạn hãy xem ví dụ bên dưới đây về union:</p>\n<pre><code>Union one4all\n{\n    Int int_val;\n    Long  long_val;\n    Double double_val;\n};\n</code></pre>\n<p>Nhìn sơ lược bạn có thể thấy rằng union one4all chỉ có thể lưu giữ 3 kiểu dữ liệu là interger, long và double. Và chúng ta hãy tiếp tục những dòng code tiếp theo:</p>\n<pre><code>one4all pail;\npail.int_val = 15;\nCout &lt;&lt; pail.int_val &lt;&lt; endl;\npail.double_val =  1.38;\ncout &lt;&lt; pail.double_val &lt;&lt; endl;\ncout &lt;&lt; pail.int_val &lt;&lt; endl;\n</code></pre>\n<p>Như chúng ta  thấy, pail chỉ lưu giá trị int tại 1 thời điểm và tại một thời điểm khác (<code>pail.double_val</code>) thì giá trị cuả int sẽ bị mất. Biến sẽ chỉ lưu trữ giá trị tại thời điểm nó được gọi. Bởi vì union chỉ lưu trữ một giá trị tại một thời  điểm, nó không có đủ bộ nhớ để giữ những giá trị khác. Vì thế, kích thước bộ nhớ của Union là kích thước của biến có kiểu dữ liệu lớn nhất.</p>\n<p>Mục đích của việc sử dụng union là để tiết kiệm bộ nhớ khi mà dữ liệu đầu vào có thể  có  nhiều định dạng nhưng không bao giờ được sử dụng đồng thời. Ví dụ, giar sử bạn đang quản lý một “hỗn tạp” các kiểu dữ liệu, một vài thứ trong đó nên sử dụng int ID, một số khác thì dùng string ID, một khác  nữa là double, bla  bla bla. Nếu bạn sử  dụng các khai báo biến bình thường  thì bạn cần khai báo rất nhiều biến và rất nhiều kiểu dữ liệu. Tuy nhiên với union bạn có thể làm theo cách bên dưới đây:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nstruct widget\n{\n    char brand[20];\n    int type;\n    union ID\n    {\n        long id_num;\n        char id_char[20];\n    } id_val;\n};\nint main()\n{\n    widget prize;\n    if (prize.type == 1)\n    {\n        cin &gt;&gt; prize.id_val.id_num;\n    }\n    else\n    {\n        cin &gt;&gt; prize.id_val.id_char;\n    }\n}\n</code></pre>\n<p>Anonymous union không có tên; bản chất đó là nhiều biến nhưng được lưu vào một vùng nhớ nhất định:</p>\n<pre><code>union ID\n{\n    long id_num;\n    char id_char[20];\n} id_val;\n</code></pre>\n<p>Bởi vì union là Anonymous, các biến id<em>num và id</em>char được đối xử như hai “biến con” của prize và được lưu trong 1 vùng nhớ nhất định. Nó  chỉ cần một cái tên trung gian để truy  xuất vào vùng nhớ đó (là id<em>num hay id</em>char) tùy thuộc vào lập trình viên chọn cái nào để sử dụng.<br>\nUnion thường được  sử dụng để tiết kiệm bộ nhớ.  Nó có vẻ không cần thiết khi mà bộ nhớ RAM ngày nay  thực sự lớn và lên tới hàng gigabyte và hàng terabytes cho  ổ đĩa. Nhưng không dừng lại ở đó, hằng ngày có rất nhiều lập trình viên đang sử dụng union như cứu cánh trong lĩnh vực hệ thống nhúng, nơi mà bộ nhớ và cả ram bị giới hạn rất là nhiều.</p>\n","rawBody":"\nSử dụng struct trong chương trình\n---------------------------------\n\nOHM, lần trước chúng ta đã bàn về [Đệ Quy][1] rồi, bây giờ chúng ta lại quay về vấn đề cơ bản của ngôn ngữ: STRUCT.\nTrong bài này mình sẽ  bàn về những vấn đề cơ bản nhất về struct và kèm theo những ví dụ cũng cơ bản không kém. Do bài dài nên mình không đủ thời gian dịch và update hằng ngày nên mọi người bookmark lại và đọc theo ngày nhé.\nBây giờ hãy mở đầu Struct bằng một ví dụ minh họa bên dưới nhé:\n\n```\n#include  <iostream>\nusing namespace std;\nstruct inflatable\n{\n    char name[20];\n    float volume;\n    double price;\n};\n\nint main()\n{\n    inflatable guest =\n    {\n        \"Glorious Gloria\",    //namevalue\n        1.88,                //volum value\n        29.99                //price value\n    };                        //guest is  structure variable of  type inflatable\n    inflatable pal =\n    {\n        \"Audacious Arthur\",\n        3.12,\n        32.99\n    };                        //pal is second variable of  type inflatable\n    //Note: som implementations require using static  inflatable guest =\n    cout << \"Expand your guest  list with \" << guest.name;\n    cout << \" and \" << pal.name << endl;\n    //pal.name is  the name member of the pal variable\n    cout << \"You can have both for $\" << guest.price + pal.price << endl;\n    return 0;\n}\n```\n\nCode mình build bằng Visual 2013 nên nếu  những ai build bằng IDE khác thì có thể thay đổi chút ít để phù hợp, và dưới đây là kết quả của đoạn code trên:\n\n> Expand your gues list with Glorious Gloria and Audacious Arthur!\n> You can have both for $62.98!\n\n\n**Lưu ý về chương trình**\nMột điều cực kỳ tối quan trọng là cách mà bạn khai báo dữ liệu Struct trong ví dụ trên. Có hai lựa chọn cho chương trình structur.cpp. Bạn có thể đặt khai báo bên trong hàm main() và ngoài hàm. Và bạn cũng nên nhớ rằng struct chúng ta cũng có thể gọi nó là 1 kiểu dữ liệu được định nghĩa riêng. Điều này cũng có nghĩa rằng nó cũng có dạng “Biến nội bộ” và “Biến toàn cục”. Dựa vào vị trí đặt của Struct thì chúng ta có thể suy ra đươc biến Struct này là biến nội bộ hay biến toàn cục. Tùy vào vị trí đặt Struct thì chúng ta có cách sử  dụng khác nhau\nNotice: Trong bài này mình tạm gọi Struct là 1 biến để ngắn gọn nhé.\nBiến Struct toàn cục: là loại biến đặt bên ngoài hàm, được khai báo sau khi khai báo thư viện và namspace, loại biến này sử dụng được cho mọi hàm trong chương trình và chúng ta gọi tên tiếng anh mĩ miều là external declaration \nBiến Struct cục bộ: là loại biến được đặt bên trong hàm, được khai báo trong 1 hàm cố định và không được truy xuất bởi hàm khác, nói cách khác đó là biến chỉ sử dụng được bởi các funtion đặt chung dấu {} với nó.\n\n\nVí dụ\n\n```\nint main()\n{\n    struct ID\n    {\n        int a;\n        int b;\n    };\n}\n```\n\nNhư các bạn thấy đấy, Struct cũng được máy tính đối xử như 1 biến vậy, nó có thể được khai báo cục bộ hoặc toàn cục. Với cách khai báo toàn cục thì nó có thể được sử dụng bởi tất cả các hàm. \nQuay trở lại với ngôn ngữ C++, ngôn ngữ này không khuyến khích sử dụng biến toàn cục (external variable) nhưng nó khuyến khích sử dụng các struct extenal variable (có thể gọi là cấu trúc toàn cục).\n\nBây giờ chúng ta lại nhìn cách mình sử dụng struct bênt trên. Cách mà mình khởi tạo 1 biến:\n\n```\ninflatable guest = \n{ \n    \"Glorious Gloria\",    //namevalue\n    1.88,                //volum value\n    29.99                //price value\n};    \n```\n\nGiống như cách bạn truyền tham số vào một mảng, bạn cần để trong một dấu {} và cách nhau bởi một dấuphẩy. Mỗi giá trị được đặt trong một dòng. Tuy nhiên bạn có thể đặt tất  cả vào cùng 1 dòng mà không xảy ra lỗi. Nhưng nhớ rằng phải ngăn cách chúng bằng dấu phẩy, đó là quy tắc nếu bạn không muốn gặp lỗi khi compile bằng bất cứ complier nào.\n\n    Inflatable duck = {“daphne”, 0.12, 9.98};\n\nBạn có  thể khởi tạo mỗi  giá trị của struct bằng các kiểu dữ liệu  thích hợp. Trong ví dụ mình khái báo bên trên, biến name mình đã khai báo một mãng kiểu char, nhưng nếu sử dụng C++ thì bạn có thể khai báo  kiểu string, điều này không ảnh hưởng tới cách mà chương trình  chạy.\n\nMỗi giá trị của Struct được đối xử như là một biến của kiểu dữ liệu. Như vậy, khi ta sử dụng biến pal.price thì đây là một biến kiểu double và pal.name là một kiểu char[]. Và khi mà ta sử dụng lệnh cout để xuất dữ liệu ra màn hình với biến pal.name thì máy tính sẽ tự động chọn kiểu string (hay char[]). Cũng như thế, pal.name cũng là một mảng ký tự và chúng ta có thể sử dụng nó như là một mảng. Khi bạn truy xuất giá trị tại pal.name[0] thì bạn sẽ nhận được một giá tị ‘A’, nhưng khi bạn truy xuất pal[0] thì nó hoàn toàn vô nghĩa bởi vì pal là một struct chứ không phải là một mảng(array).\n\n---\n\nKHAI BÁO STRUCT TRONG C++ 11\n----------------------------\n\n---\n\nGiống như mảng, C++11 mở rộng cách mà ta có thể khai báo và sử dụng struct một cách linh hoạt. Thay vì chúng ta cần phải sử dụng dấu “=” thì nay chúng ta có thể quên nó đi.\n\n    Inflatable duck {“daphne”, 0.12, 9.98};\n\nTiếp theo, mỗi thành phần chưa được gán trị  thay vì nó sẽ là một giá trị rác thì nay mặc định sẽ là 0. Ví dụ, khi mà khai báo một biến có kiểu inflatable mayor thì giá trị ta nhận về khi truy xuất mayor.price hay mayor.volume sẽ  là  0.\nTuy nhiên ta có mayor.name được định nghĩa là  một  mảng ký tự thì tất cả các byte trong mảng mayor.name sẽ được đặt là 0 (hoặc  gọi cách khác đây là ký tự NULL).\nCách mà ta khai báo biến mayor để có các giá trị trên là:\n\n    Inflatable mayor{};\n\nLIỆU STRUCT CÓ THỂ SỬ DỤNG ĐƯỢC CLASS STRING KHÔNG?\n---------------------------------------------------\n\nLiệu chúng ta có thể dùng các đối tượng bên trong Class String để sử dụng cho mảng ký tự name? Tất nhiên, bạn có thể khai báo một structure giống thế này:\n\n```\nstruct inflatable\n{\n\tstd::string name;\n\tfloat volume;\n\tdouble price;\n};\n```\n\nTất nhiên câu trả lời là có thể rồi trừ khi bạn đang sử dụng một IDE hay compiler bản cũ hoặc đã lỗi thời từ lâu thì nó không được hỗ trợ khai báo structure với class string.\n\nHãy chắc chắn rằng structure bạn khai báo có quyền truy cập vào namespace std. Bạn có thể khai báo sau khi khai báo thư viện hoặc trong khi khai báo struct như cách mà mình làm bên trên, sử  dụng: std: :string\n\nMỘT SỐ THUỘC TÍNH KHÁC CỦA STRUCT\n---------------------------------\n\nC++ tạo cho người dùng một môi trường đơn giản nhất có thể để sử dụng “built-in-type”. Ví dụ,  bạn có thể  sử  dụng cấu trúc như là một đối số, và bạn có thể sử dụng structure  như một kiểu dữ liệu của hàm  và return giá trị của  structure đó. Tất nhiên bạn có thể sử dụng các operator (=)  để gán một giá trị của struct cho một biến khác cùng với kiểu đã khai báo. Ví dụ: \n       \n    char[50] palprice = pal.prices;\n\nNhư chúng ta  thấy  đấy, các “member” được khai báo trong struct cũng được đối  xử như là một variable. Bây giờ chúng ta hãy xem ví  dụ tiếp theo bên dưới\n\n```\n#include  <iostream>\nusing namespace std;\nstruct inflatable\n{\n    char name[20];\n    float volume;\n    double price;\n};\n\nint main()\n{\n    inflatable bouquet =\n    {\n        \"sunflower\",\n        0.20,\n        12.49\n    };\n    inflatable pal =\n    {\n        \"Audacious Arthur\",\n        3.12,\n        32.99\n    };\n    inflatable choice;\n    cout << \"bouquet: \" << bouquet.name << \"for $\" << bouquet.price << endl;\n    choice = bouquet;\n    cout << \"choice: \" << choice.name << \"for $\" << choice.price << endl;\n    return 0;\n}\n```\n\nVà đây là kết quả của đoạn code bên trên:\n\n> Bouquet: sunflower for $12.49\n> Choice: sunflower for $12.49\n\nNhư bạn đã thấy, cả hai giá trị của Bouquet và Choice đều bằng nhau. Bạn có thể phối hợp định nghĩa 1 cấu trúc và gán thẳng variable cho nó. Để làm được việc này, bạn khai báo thẳng variable sau khi khai báo một struct\n\n```\ntruct perks\n{\n    int key_number;\n    char car[12];\n} mr_smith, ms_jones;\n```\n\nMặc dù cách này vẫn giúp chương trình hoạt động bình thường, tuy nhiên các lập trình viên đều chia ra vì viết giống vậy rất khó để theo dõi chương trình và sửa lỗi.\n\nMột cách khác là bạn có thể tạo dựng 1 struct không tên và gọi một variable sau khi đã định nghĩa xong struct. Như ví dụ dưới đây:\n\n```\nstruct perks\n{\n    int key_number;\n    char car[12];\n} mr_glitz =\n{\n    7,\n    \"Packard\"\n};\n```\n\nTrong đoạn code này:\n\n```\nstruct\n{\n    int x;\n    int y;\n} position;\n```\n\nChương trình sẽ tạo dựng một biến struct và gọi nó là position. Bạn có thể truy xuất các “member” của position bằng “membership operation”, ví dụ như là  position.x, nhưng nếu bạn sử  dụng cách khai báo này thì bạn sẽ chỉ có duy nhất một biên postion có thể sử dụng struct này. Và sau đó bạn không thể tạo một biến khác có thể sử dụng chung struct như thế. Nói cách khác, biến position là đặc biệt.\n\nMẢNG STRUCT\n-----------\n\nTrong struct inflatable được định nghĩa ở đầu  bàu có chứa một mảng (char name[]). Nó cũng có khả năng tạo mảng mà  các phần tử là struct. Kỹ thuật để tạo nên một mảng kiểu struct chính là cách mà ta hay sử dụng để tạo 1 mảng của 1 kiểu dữ liệu nào đó.\n\n```\nInflatable gifts[100]; // array of 100  inflatable structures\n```\n\nĐây là dòng lệnh để tạo ra một mảng có 100 phần tử kiểu > `inflatable`. Vì thế mỗi phần tử trong mảng từ `gifts[0]` tới `gifts[99]` đều  có kiểu của `struct inflatable`:\n\n    cin >> gifts[0].volume; // use volume member  of  first struct\n    cout << gifts[99].price  << endl; // display price member if last struct\n\nNhưng hãy nhớ rằng gifts là tên của mảng chứ không phải là variable, việc truy xuất gift.price sẽ vô nghĩa và bạn sẽ nhanh chóng bị báo lỗi bởi compiler.\nĐể khai báo một mảng struct, ta cũng  có thể ghép chúng lại bằng cách bên dưới:\n\n```\nInflatable guests[2] =        // khai báo mảng kiểu struct\n{\n    {“Bambi”, 0.5, 21.99},        //giá trị đầu tiên của mảng\n    {“Godzilla”, 2000, 565.99}    //giá trị tiếp theo\n}\n```\n\nNhư cách mọi người thường dùng, bạn có thể định nghĩa bằng cách bạn thích. Ví dụ, cả hai cách định nghĩa có thể đặt ở chung 1 dòng hay tách từng dòng để dễ đọc.\n\nVí dụ tiếp theo sẽ hướng dẫn cách mà bạn sẽ sử dụng và truy xuất dữ liệu sử dụng dấu chấm “.” (dot operation)\n\n```\n#include <iostream>\nstruct inflatable\n{\n    char name[20];\n    float volume;\n    double price;\n};\nint main()\n{\n    using namespace  std;\n    inflatable  guests[2] =\n    {\n        {\"Bambi, 0.5, 21.99\"},\n        {\"Godzilla, 2000, 565.99\"}\n    };\n    cout << \"The guests\" << guests[0].name << \" and \" << guests[1].name;\n    cout << \"\\n Have a  combined volume of \" << guests[0].volume + guests[1].volume << \" 2000.5 cubic feet.\\n\";\n    return 0;\n}\n```\n\nVà đây là kết quả sau khi chương trình chạy:\n\n> The guests Bambi and Godzilla\n> Have a  combined volume of 2000.5 cubic feet.\n\nBIT FIELDS TRONG STRUCT\n-----------------------\n\nC++ cũng như C cho phép bạn chỉ định  số lượng bit mà bạn muốn sử dụng. Điều này thực sự hữu dụng khi bạn tạo một data structure, bạn có thể chỉ định bạn cần bao nhiêu bộ nhớ. Vùng Fields này nên là một biến hoặc một kiểu dữ liệu ta không dùng tới. Ví dụ sau:\n\n```\nStruct torgle_register\n{\n    Unsigned in SN : 4;    // dùng 4 bit cho giá trị SN;\n    Unsigned  int : 4;    // 4 bit này không dùng tới\n    Bool goodIn :  1;    // valid input (1 bit)\n    Bool goodTorgle : 1    // successful torgling\n};\n```\n\nBạn có thể định nghĩa fields cực kỳ linh hoạt, và bạn có thể sử dụng ký hiệu để truy cập các byte field:\n\n```\nTorge_register tr = {14, true, false};\n…\nIf(tr.goodIn)\n…\n```\n\nBit Fields thường được sử dụng trong lập trình cấp thấp cho các vi xử lý. Tuy nhiên bạn có thể sử dụng nó như là 1 flag để đánh dấu khi sử  dụng pointer.\n\nUNIONS\n------\n\nUnion là một kiểu dữ liệu cũng  khá giống struct về cách định nghĩa cùng như cách sử dụng. Nhưng nó khác Struct tại một thời điểm nó chỉ lưu được một giá trị duy nhất.\nQuay trở lại các ví  dụ trước, ta có 1 struct tên `Inflatable` có chứa nhiều kiểu dữ liệu bên trong. Ta có gọi một “biến” với tên `pal` và ta  truy xuất dữ liệu theo `pal.name, pal.prices….` và dữ liệu được truy xuất được lưu vào các biến của `pal.name, pal.prices…`\n\n**Vậy  Union lưu dữ liệu  thế  nào?**\nUnion chỉ lưu 1 dữ liệu tại một thời  điểm. Để hiểu rõ hơn thì bạn hãy xem ví dụ bên dưới đây về union:\n\n```\nUnion one4all\n{\n    Int int_val;\n    Long  long_val;\n    Double double_val;\n};\n```\n\nNhìn sơ lược bạn có thể thấy rằng union one4all chỉ có thể lưu giữ 3 kiểu dữ liệu là interger, long và double. Và chúng ta hãy tiếp tục những dòng code tiếp theo:\n\n```\none4all pail;\npail.int_val = 15;\nCout << pail.int_val << endl;\npail.double_val =  1.38;\ncout << pail.double_val << endl;\ncout << pail.int_val << endl;\n```\n\nNhư chúng ta  thấy, pail chỉ lưu giá trị int tại 1 thời điểm và tại một thời điểm khác (`pail.double_val`) thì giá trị cuả int sẽ bị mất. Biến sẽ chỉ lưu trữ giá trị tại thời điểm nó được gọi. Bởi vì union chỉ lưu trữ một giá trị tại một thời  điểm, nó không có đủ bộ nhớ để giữ những giá trị khác. Vì thế, kích thước bộ nhớ của Union là kích thước của biến có kiểu dữ liệu lớn nhất.\n\nMục đích của việc sử dụng union là để tiết kiệm bộ nhớ khi mà dữ liệu đầu vào có thể  có  nhiều định dạng nhưng không bao giờ được sử dụng đồng thời. Ví dụ, giar sử bạn đang quản lý một “hỗn tạp” các kiểu dữ liệu, một vài thứ trong đó nên sử dụng int ID, một số khác thì dùng string ID, một khác  nữa là double, bla  bla bla. Nếu bạn sử  dụng các khai báo biến bình thường  thì bạn cần khai báo rất nhiều biến và rất nhiều kiểu dữ liệu. Tuy nhiên với union bạn có thể làm theo cách bên dưới đây:\n\n```\n#include <iostream>\nusing namespace std;\nstruct widget\n{\n    char brand[20];\n    int type;\n    union ID\n    {\n        long id_num;\n        char id_char[20];\n    } id_val;\n};\nint main()\n{\n    widget prize;\n    if (prize.type == 1)\n    {\n        cin >> prize.id_val.id_num;\n    }\n    else\n    {\n        cin >> prize.id_val.id_char;\n    }\n}\n```\n\nAnonymous union không có tên; bản chất đó là nhiều biến nhưng được lưu vào một vùng nhớ nhất định:\n\n```\nunion ID\n{\n    long id_num;\n    char id_char[20];\n} id_val;\n```\n\nBởi vì union là Anonymous, các biến id_num và id_char được đối xử như hai “biến con” của prize và được lưu trong 1 vùng nhớ nhất định. Nó  chỉ cần một cái tên trung gian để truy  xuất vào vùng nhớ đó (là id_num hay id_char) tùy thuộc vào lập trình viên chọn cái nào để sử dụng.\nUnion thường được  sử dụng để tiết kiệm bộ nhớ.  Nó có vẻ không cần thiết khi mà bộ nhớ RAM ngày nay  thực sự lớn và lên tới hàng gigabyte và hàng terabytes cho  ổ đĩa. Nhưng không dừng lại ở đó, hằng ngày có rất nhiều lập trình viên đang sử dụng union như cứu cánh trong lĩnh vực hệ thống nhúng, nơi mà bộ nhớ và cả ram bị giới hạn rất là nhiều.\n\n\n  [1]: http://daynhauhoc.com/t/de-quy-dich-boi-breakdown/5719\n","raw":"---json\n{\"id\":7092,\"layout\":\"Post\",\"route\":\"struct-la-gi-ban-chat-va-cach-su-dung\",\"title\":\"Struct là gì? bản chất và cách sử dụng\",\"tags\":[\"union\",\"data-structures\",\"struct\",\"c++\"],\"date\":\"2015-05-10T14:24:23.654Z\"}\n---\n\nSử dụng struct trong chương trình\n---------------------------------\n\nOHM, lần trước chúng ta đã bàn về [Đệ Quy][1] rồi, bây giờ chúng ta lại quay về vấn đề cơ bản của ngôn ngữ: STRUCT.\nTrong bài này mình sẽ  bàn về những vấn đề cơ bản nhất về struct và kèm theo những ví dụ cũng cơ bản không kém. Do bài dài nên mình không đủ thời gian dịch và update hằng ngày nên mọi người bookmark lại và đọc theo ngày nhé.\nBây giờ hãy mở đầu Struct bằng một ví dụ minh họa bên dưới nhé:\n\n```\n#include  <iostream>\nusing namespace std;\nstruct inflatable\n{\n    char name[20];\n    float volume;\n    double price;\n};\n\nint main()\n{\n    inflatable guest =\n    {\n        \"Glorious Gloria\",    //namevalue\n        1.88,                //volum value\n        29.99                //price value\n    };                        //guest is  structure variable of  type inflatable\n    inflatable pal =\n    {\n        \"Audacious Arthur\",\n        3.12,\n        32.99\n    };                        //pal is second variable of  type inflatable\n    //Note: som implementations require using static  inflatable guest =\n    cout << \"Expand your guest  list with \" << guest.name;\n    cout << \" and \" << pal.name << endl;\n    //pal.name is  the name member of the pal variable\n    cout << \"You can have both for $\" << guest.price + pal.price << endl;\n    return 0;\n}\n```\n\nCode mình build bằng Visual 2013 nên nếu  những ai build bằng IDE khác thì có thể thay đổi chút ít để phù hợp, và dưới đây là kết quả của đoạn code trên:\n\n> Expand your gues list with Glorious Gloria and Audacious Arthur!\n> You can have both for $62.98!\n\n\n**Lưu ý về chương trình**\nMột điều cực kỳ tối quan trọng là cách mà bạn khai báo dữ liệu Struct trong ví dụ trên. Có hai lựa chọn cho chương trình structur.cpp. Bạn có thể đặt khai báo bên trong hàm main() và ngoài hàm. Và bạn cũng nên nhớ rằng struct chúng ta cũng có thể gọi nó là 1 kiểu dữ liệu được định nghĩa riêng. Điều này cũng có nghĩa rằng nó cũng có dạng “Biến nội bộ” và “Biến toàn cục”. Dựa vào vị trí đặt của Struct thì chúng ta có thể suy ra đươc biến Struct này là biến nội bộ hay biến toàn cục. Tùy vào vị trí đặt Struct thì chúng ta có cách sử  dụng khác nhau\nNotice: Trong bài này mình tạm gọi Struct là 1 biến để ngắn gọn nhé.\nBiến Struct toàn cục: là loại biến đặt bên ngoài hàm, được khai báo sau khi khai báo thư viện và namspace, loại biến này sử dụng được cho mọi hàm trong chương trình và chúng ta gọi tên tiếng anh mĩ miều là external declaration \nBiến Struct cục bộ: là loại biến được đặt bên trong hàm, được khai báo trong 1 hàm cố định và không được truy xuất bởi hàm khác, nói cách khác đó là biến chỉ sử dụng được bởi các funtion đặt chung dấu {} với nó.\n\n\nVí dụ\n\n```\nint main()\n{\n    struct ID\n    {\n        int a;\n        int b;\n    };\n}\n```\n\nNhư các bạn thấy đấy, Struct cũng được máy tính đối xử như 1 biến vậy, nó có thể được khai báo cục bộ hoặc toàn cục. Với cách khai báo toàn cục thì nó có thể được sử dụng bởi tất cả các hàm. \nQuay trở lại với ngôn ngữ C++, ngôn ngữ này không khuyến khích sử dụng biến toàn cục (external variable) nhưng nó khuyến khích sử dụng các struct extenal variable (có thể gọi là cấu trúc toàn cục).\n\nBây giờ chúng ta lại nhìn cách mình sử dụng struct bênt trên. Cách mà mình khởi tạo 1 biến:\n\n```\ninflatable guest = \n{ \n    \"Glorious Gloria\",    //namevalue\n    1.88,                //volum value\n    29.99                //price value\n};    \n```\n\nGiống như cách bạn truyền tham số vào một mảng, bạn cần để trong một dấu {} và cách nhau bởi một dấuphẩy. Mỗi giá trị được đặt trong một dòng. Tuy nhiên bạn có thể đặt tất  cả vào cùng 1 dòng mà không xảy ra lỗi. Nhưng nhớ rằng phải ngăn cách chúng bằng dấu phẩy, đó là quy tắc nếu bạn không muốn gặp lỗi khi compile bằng bất cứ complier nào.\n\n    Inflatable duck = {“daphne”, 0.12, 9.98};\n\nBạn có  thể khởi tạo mỗi  giá trị của struct bằng các kiểu dữ liệu  thích hợp. Trong ví dụ mình khái báo bên trên, biến name mình đã khai báo một mãng kiểu char, nhưng nếu sử dụng C++ thì bạn có thể khai báo  kiểu string, điều này không ảnh hưởng tới cách mà chương trình  chạy.\n\nMỗi giá trị của Struct được đối xử như là một biến của kiểu dữ liệu. Như vậy, khi ta sử dụng biến pal.price thì đây là một biến kiểu double và pal.name là một kiểu char[]. Và khi mà ta sử dụng lệnh cout để xuất dữ liệu ra màn hình với biến pal.name thì máy tính sẽ tự động chọn kiểu string (hay char[]). Cũng như thế, pal.name cũng là một mảng ký tự và chúng ta có thể sử dụng nó như là một mảng. Khi bạn truy xuất giá trị tại pal.name[0] thì bạn sẽ nhận được một giá tị ‘A’, nhưng khi bạn truy xuất pal[0] thì nó hoàn toàn vô nghĩa bởi vì pal là một struct chứ không phải là một mảng(array).\n\n---\n\nKHAI BÁO STRUCT TRONG C++ 11\n----------------------------\n\n---\n\nGiống như mảng, C++11 mở rộng cách mà ta có thể khai báo và sử dụng struct một cách linh hoạt. Thay vì chúng ta cần phải sử dụng dấu “=” thì nay chúng ta có thể quên nó đi.\n\n    Inflatable duck {“daphne”, 0.12, 9.98};\n\nTiếp theo, mỗi thành phần chưa được gán trị  thay vì nó sẽ là một giá trị rác thì nay mặc định sẽ là 0. Ví dụ, khi mà khai báo một biến có kiểu inflatable mayor thì giá trị ta nhận về khi truy xuất mayor.price hay mayor.volume sẽ  là  0.\nTuy nhiên ta có mayor.name được định nghĩa là  một  mảng ký tự thì tất cả các byte trong mảng mayor.name sẽ được đặt là 0 (hoặc  gọi cách khác đây là ký tự NULL).\nCách mà ta khai báo biến mayor để có các giá trị trên là:\n\n    Inflatable mayor{};\n\nLIỆU STRUCT CÓ THỂ SỬ DỤNG ĐƯỢC CLASS STRING KHÔNG?\n---------------------------------------------------\n\nLiệu chúng ta có thể dùng các đối tượng bên trong Class String để sử dụng cho mảng ký tự name? Tất nhiên, bạn có thể khai báo một structure giống thế này:\n\n```\nstruct inflatable\n{\n\tstd::string name;\n\tfloat volume;\n\tdouble price;\n};\n```\n\nTất nhiên câu trả lời là có thể rồi trừ khi bạn đang sử dụng một IDE hay compiler bản cũ hoặc đã lỗi thời từ lâu thì nó không được hỗ trợ khai báo structure với class string.\n\nHãy chắc chắn rằng structure bạn khai báo có quyền truy cập vào namespace std. Bạn có thể khai báo sau khi khai báo thư viện hoặc trong khi khai báo struct như cách mà mình làm bên trên, sử  dụng: std: :string\n\nMỘT SỐ THUỘC TÍNH KHÁC CỦA STRUCT\n---------------------------------\n\nC++ tạo cho người dùng một môi trường đơn giản nhất có thể để sử dụng “built-in-type”. Ví dụ,  bạn có thể  sử  dụng cấu trúc như là một đối số, và bạn có thể sử dụng structure  như một kiểu dữ liệu của hàm  và return giá trị của  structure đó. Tất nhiên bạn có thể sử dụng các operator (=)  để gán một giá trị của struct cho một biến khác cùng với kiểu đã khai báo. Ví dụ: \n       \n    char[50] palprice = pal.prices;\n\nNhư chúng ta  thấy  đấy, các “member” được khai báo trong struct cũng được đối  xử như là một variable. Bây giờ chúng ta hãy xem ví  dụ tiếp theo bên dưới\n\n```\n#include  <iostream>\nusing namespace std;\nstruct inflatable\n{\n    char name[20];\n    float volume;\n    double price;\n};\n\nint main()\n{\n    inflatable bouquet =\n    {\n        \"sunflower\",\n        0.20,\n        12.49\n    };\n    inflatable pal =\n    {\n        \"Audacious Arthur\",\n        3.12,\n        32.99\n    };\n    inflatable choice;\n    cout << \"bouquet: \" << bouquet.name << \"for $\" << bouquet.price << endl;\n    choice = bouquet;\n    cout << \"choice: \" << choice.name << \"for $\" << choice.price << endl;\n    return 0;\n}\n```\n\nVà đây là kết quả của đoạn code bên trên:\n\n> Bouquet: sunflower for $12.49\n> Choice: sunflower for $12.49\n\nNhư bạn đã thấy, cả hai giá trị của Bouquet và Choice đều bằng nhau. Bạn có thể phối hợp định nghĩa 1 cấu trúc và gán thẳng variable cho nó. Để làm được việc này, bạn khai báo thẳng variable sau khi khai báo một struct\n\n```\ntruct perks\n{\n    int key_number;\n    char car[12];\n} mr_smith, ms_jones;\n```\n\nMặc dù cách này vẫn giúp chương trình hoạt động bình thường, tuy nhiên các lập trình viên đều chia ra vì viết giống vậy rất khó để theo dõi chương trình và sửa lỗi.\n\nMột cách khác là bạn có thể tạo dựng 1 struct không tên và gọi một variable sau khi đã định nghĩa xong struct. Như ví dụ dưới đây:\n\n```\nstruct perks\n{\n    int key_number;\n    char car[12];\n} mr_glitz =\n{\n    7,\n    \"Packard\"\n};\n```\n\nTrong đoạn code này:\n\n```\nstruct\n{\n    int x;\n    int y;\n} position;\n```\n\nChương trình sẽ tạo dựng một biến struct và gọi nó là position. Bạn có thể truy xuất các “member” của position bằng “membership operation”, ví dụ như là  position.x, nhưng nếu bạn sử  dụng cách khai báo này thì bạn sẽ chỉ có duy nhất một biên postion có thể sử dụng struct này. Và sau đó bạn không thể tạo một biến khác có thể sử dụng chung struct như thế. Nói cách khác, biến position là đặc biệt.\n\nMẢNG STRUCT\n-----------\n\nTrong struct inflatable được định nghĩa ở đầu  bàu có chứa một mảng (char name[]). Nó cũng có khả năng tạo mảng mà  các phần tử là struct. Kỹ thuật để tạo nên một mảng kiểu struct chính là cách mà ta hay sử dụng để tạo 1 mảng của 1 kiểu dữ liệu nào đó.\n\n```\nInflatable gifts[100]; // array of 100  inflatable structures\n```\n\nĐây là dòng lệnh để tạo ra một mảng có 100 phần tử kiểu > `inflatable`. Vì thế mỗi phần tử trong mảng từ `gifts[0]` tới `gifts[99]` đều  có kiểu của `struct inflatable`:\n\n    cin >> gifts[0].volume; // use volume member  of  first struct\n    cout << gifts[99].price  << endl; // display price member if last struct\n\nNhưng hãy nhớ rằng gifts là tên của mảng chứ không phải là variable, việc truy xuất gift.price sẽ vô nghĩa và bạn sẽ nhanh chóng bị báo lỗi bởi compiler.\nĐể khai báo một mảng struct, ta cũng  có thể ghép chúng lại bằng cách bên dưới:\n\n```\nInflatable guests[2] =        // khai báo mảng kiểu struct\n{\n    {“Bambi”, 0.5, 21.99},        //giá trị đầu tiên của mảng\n    {“Godzilla”, 2000, 565.99}    //giá trị tiếp theo\n}\n```\n\nNhư cách mọi người thường dùng, bạn có thể định nghĩa bằng cách bạn thích. Ví dụ, cả hai cách định nghĩa có thể đặt ở chung 1 dòng hay tách từng dòng để dễ đọc.\n\nVí dụ tiếp theo sẽ hướng dẫn cách mà bạn sẽ sử dụng và truy xuất dữ liệu sử dụng dấu chấm “.” (dot operation)\n\n```\n#include <iostream>\nstruct inflatable\n{\n    char name[20];\n    float volume;\n    double price;\n};\nint main()\n{\n    using namespace  std;\n    inflatable  guests[2] =\n    {\n        {\"Bambi, 0.5, 21.99\"},\n        {\"Godzilla, 2000, 565.99\"}\n    };\n    cout << \"The guests\" << guests[0].name << \" and \" << guests[1].name;\n    cout << \"\\n Have a  combined volume of \" << guests[0].volume + guests[1].volume << \" 2000.5 cubic feet.\\n\";\n    return 0;\n}\n```\n\nVà đây là kết quả sau khi chương trình chạy:\n\n> The guests Bambi and Godzilla\n> Have a  combined volume of 2000.5 cubic feet.\n\nBIT FIELDS TRONG STRUCT\n-----------------------\n\nC++ cũng như C cho phép bạn chỉ định  số lượng bit mà bạn muốn sử dụng. Điều này thực sự hữu dụng khi bạn tạo một data structure, bạn có thể chỉ định bạn cần bao nhiêu bộ nhớ. Vùng Fields này nên là một biến hoặc một kiểu dữ liệu ta không dùng tới. Ví dụ sau:\n\n```\nStruct torgle_register\n{\n    Unsigned in SN : 4;    // dùng 4 bit cho giá trị SN;\n    Unsigned  int : 4;    // 4 bit này không dùng tới\n    Bool goodIn :  1;    // valid input (1 bit)\n    Bool goodTorgle : 1    // successful torgling\n};\n```\n\nBạn có thể định nghĩa fields cực kỳ linh hoạt, và bạn có thể sử dụng ký hiệu để truy cập các byte field:\n\n```\nTorge_register tr = {14, true, false};\n…\nIf(tr.goodIn)\n…\n```\n\nBit Fields thường được sử dụng trong lập trình cấp thấp cho các vi xử lý. Tuy nhiên bạn có thể sử dụng nó như là 1 flag để đánh dấu khi sử  dụng pointer.\n\nUNIONS\n------\n\nUnion là một kiểu dữ liệu cũng  khá giống struct về cách định nghĩa cùng như cách sử dụng. Nhưng nó khác Struct tại một thời điểm nó chỉ lưu được một giá trị duy nhất.\nQuay trở lại các ví  dụ trước, ta có 1 struct tên `Inflatable` có chứa nhiều kiểu dữ liệu bên trong. Ta có gọi một “biến” với tên `pal` và ta  truy xuất dữ liệu theo `pal.name, pal.prices….` và dữ liệu được truy xuất được lưu vào các biến của `pal.name, pal.prices…`\n\n**Vậy  Union lưu dữ liệu  thế  nào?**\nUnion chỉ lưu 1 dữ liệu tại một thời  điểm. Để hiểu rõ hơn thì bạn hãy xem ví dụ bên dưới đây về union:\n\n```\nUnion one4all\n{\n    Int int_val;\n    Long  long_val;\n    Double double_val;\n};\n```\n\nNhìn sơ lược bạn có thể thấy rằng union one4all chỉ có thể lưu giữ 3 kiểu dữ liệu là interger, long và double. Và chúng ta hãy tiếp tục những dòng code tiếp theo:\n\n```\none4all pail;\npail.int_val = 15;\nCout << pail.int_val << endl;\npail.double_val =  1.38;\ncout << pail.double_val << endl;\ncout << pail.int_val << endl;\n```\n\nNhư chúng ta  thấy, pail chỉ lưu giá trị int tại 1 thời điểm và tại một thời điểm khác (`pail.double_val`) thì giá trị cuả int sẽ bị mất. Biến sẽ chỉ lưu trữ giá trị tại thời điểm nó được gọi. Bởi vì union chỉ lưu trữ một giá trị tại một thời  điểm, nó không có đủ bộ nhớ để giữ những giá trị khác. Vì thế, kích thước bộ nhớ của Union là kích thước của biến có kiểu dữ liệu lớn nhất.\n\nMục đích của việc sử dụng union là để tiết kiệm bộ nhớ khi mà dữ liệu đầu vào có thể  có  nhiều định dạng nhưng không bao giờ được sử dụng đồng thời. Ví dụ, giar sử bạn đang quản lý một “hỗn tạp” các kiểu dữ liệu, một vài thứ trong đó nên sử dụng int ID, một số khác thì dùng string ID, một khác  nữa là double, bla  bla bla. Nếu bạn sử  dụng các khai báo biến bình thường  thì bạn cần khai báo rất nhiều biến và rất nhiều kiểu dữ liệu. Tuy nhiên với union bạn có thể làm theo cách bên dưới đây:\n\n```\n#include <iostream>\nusing namespace std;\nstruct widget\n{\n    char brand[20];\n    int type;\n    union ID\n    {\n        long id_num;\n        char id_char[20];\n    } id_val;\n};\nint main()\n{\n    widget prize;\n    if (prize.type == 1)\n    {\n        cin >> prize.id_val.id_num;\n    }\n    else\n    {\n        cin >> prize.id_val.id_char;\n    }\n}\n```\n\nAnonymous union không có tên; bản chất đó là nhiều biến nhưng được lưu vào một vùng nhớ nhất định:\n\n```\nunion ID\n{\n    long id_num;\n    char id_char[20];\n} id_val;\n```\n\nBởi vì union là Anonymous, các biến id_num và id_char được đối xử như hai “biến con” của prize và được lưu trong 1 vùng nhớ nhất định. Nó  chỉ cần một cái tên trung gian để truy  xuất vào vùng nhớ đó (là id_num hay id_char) tùy thuộc vào lập trình viên chọn cái nào để sử dụng.\nUnion thường được  sử dụng để tiết kiệm bộ nhớ.  Nó có vẻ không cần thiết khi mà bộ nhớ RAM ngày nay  thực sự lớn và lên tới hàng gigabyte và hàng terabytes cho  ổ đĩa. Nhưng không dừng lại ở đó, hằng ngày có rất nhiều lập trình viên đang sử dụng union như cứu cánh trong lĩnh vực hệ thống nhúng, nơi mà bộ nhớ và cả ram bị giới hạn rất là nhiều.\n\n\n  [1]: http://daynhauhoc.com/t/de-quy-dich-boi-breakdown/5719\n","__filename":"posts/7092.md","__url":"/struct-la-gi-ban-chat-va-cach-su-dung/","__resourceUrl":"/struct-la-gi-ban-chat-va-cach-su-dung/index.html","__dataUrl":"/struct-la-gi-ban-chat-va-cach-su-dung/index.html.172445a580cb55c9f0f086df600e6be3.json","type":"Post"}}}</script><script src="/dnh-blog/manifest.a34ddb3a795eea5fe3bc.js"></script><script src="/dnh-blog/statinamic-bundle.ddb866315dc127da0a97.js"></script><script src="/dnh-blog/statinamic-client.769b5cc947c5dd5c23db.js"></script></body></html>