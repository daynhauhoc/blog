{"head":{"layout":"Post","route":"lam-sao-de-su-dung-bien-hieu-qua-hon-part2","title":"Làm sao để sử dụng biến hiệu quả hơn (part2)","tags":["coding-style"],"date":"2015-05-06T03:16:39.897Z","description":"Bài [viết trước][1] mình đã nói về cách khai báo biến và khởi tạo biến và bài viết này sẽ nói về cách chọn phạm vi biến sao cho code hiệu…"},"body":"<p>Bài <a href=\"\">viết trước</a> mình đã nói về cách khai báo biến và khởi tạo biến và bài viết này sẽ nói về cách chọn phạm vi biến sao cho code hiệu quả, dễ đọc, dễ hiểu và tất nhiên là dễ debug :blush:</p>\n<h2 id=\"part2-phm-vi-bin-scope\"><a href=\"#part2-phm-vi-bin-scope\" class=\"statinamic-HeadingAnchor\">#</a>#Part2: Phạm vi biến (Scope)</h2>\n<div align=center><img src='/uploads/default/2986/5e46151fe3050079.png' width=\"500\" height=\"429\"> <br></div>\n<p>##Hãy để tham chiếu (reference)  đến các biến gần nhau</p>\n<p>Có một phương pháp để tính toán mức độ gần nhau của các tham chiếu/lời gọi biến đó là ước tính số span của biến . Đây là ví dụ về số span:</p>\n<pre><code>a=0;  &lt;--- Tham chiếu đến a lần 1\nb=0; &lt;--- Tham chiếu đến b lần 1\nc=0;&lt;--- Tham chiếu đến c lần 1\na= b + c;  &lt;--- Tham chiếu đến a lần 2, Tham chiếu đến b lần 2, Tham chiếu đến c lần 2\n</code></pre>\n<p>Trong trường hợp này, có 2 dòng nằm giữa tham chiếu đến biến <code>a</code> thứ nhất và thứ hai, vậy <code>a</code> có số span là 2, tương tự ta có số span của b và c lần lượt là 1 và 0. Và đây là một ví dụ khác</p>\n<pre><code>a = 0;\nb = 0;\nc = 0;\nb = a + 1;\nb = b / c;\n</code></pre>\n<p>Trong trường hợp này, có 1 dòng giữa tham chiếu đến <code>b</code> thứ nhất và thứ hai nên nó có span là 1. Và không có dòng nào giữa tham chiếu thứ hai và tham chiếu thứ ba, vậy có span là 0.</p>\n<p>Số span trung bình được tính toán dựa trên những span riêng lẻ. Trong ví dụ 2, với b, (1+0)/2 = 0.5, vậy số span trung bình của b là 0.5. Khi mà bạn giữ các tham chiếu đến biến gần nhau, bạn có thể giúp người đọc code của bạn tập trung vào một phần của code, còn  nếu bạn gọi biến cách xa nhau, bạn sẽ bắt người đọc lục tung cả chương trình. Vì thế lợi ích chính của việc sắp xếp biến gần nhau là tăng khả năng đọc code rõ ràng và dễ hiểu hơn.</p>\n<p>##Hãy giữ cho biến &quot;sống&quot; trong thời gian ít nhất có thể</p>\n<p>Ở đây ta có thêm một khái niệm nữa là &quot;live time&quot; là tổng số dòng lệnh mà biến được sử dụng. Biến tồn tại từ dòng lệnh đầu tiên mà nó được gọi đến và nó kết thúc ở dòng lệnh cuối cùng mà nó được gọi đến.</p>\n<p>Không giống như span, live time của biến không bị ảnh hưởng bởi số lần biến được sử dụng từ lần đầu tới lần cuối mà biến được gọi đến. Nếu biến được gọi lần đầu tiên ở dòng 1 và lần cuối cùng ở dòng 25 thì nó sẽ tồn tại trong 25 dòng lệnh. Nếu chỉ có 2 dòng trong đó biến được sử dụng thì nó có span trung bình là 23 dòng lệnh. Nếu biến đã được dùng ở mỗi dòng từ dòng 1 đến 25, nó sẽ có số span trung bình là 0 dòng lệnh, nhưng nó vấn sẽ có live time là 25 dòng lệnh. Hình 10-1 minh họa cả 2 thông số span và live time.</p>\n<div align=center><img src=\"/uploads/default/2982/f2e568955025434a.jpg\" width=\"500\" height=\"429\"> <br> <br>\"Live time\" thể hiện tuổi thọ của biến, \"Span\"  là số \"bước\" nó thể hiện độ gần nhau của cách tham chiếu đến biến <br></div>\n<p>Tóm lại, cũng như với span, mục tiêu cần quan tâm với live time đó là giữ con số đó NHỎ,  tức là hãy làm cho biến &quot;chết sớm&quot; nhất có thể.\n##Tính toán thời gian tồn tại của biến</p>\n<p>Bạn có thể tính live time của biến bằng cách đếm số dòng giữa lần đầu và lần cuối gọi biến (bao gồm cả lần đầu và lần cuối). Đây là ví dụ khi để  biến &quot;sống quá dai&quot;.</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">// khởi tạo tất cả các biến</span>\n<span class=\"hljs-number\">2</span> recordIndex= <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-number\">3</span> total = <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-number\">4</span> done = <span class=\"hljs-keyword\">false</span>;\n    ...\n<span class=\"hljs-number\">26</span> <span class=\"hljs-keyword\">while</span> ( recordIndex &lt; recordCount ) {\n<span class=\"hljs-number\">27</span> ...\n<span class=\"hljs-number\">28</span> recordIndex = recordIndex +<span class=\"hljs-number\">1</span>;    **&lt;--<span class=\"hljs-number\">1</span>**\n    ...\n<span class=\"hljs-number\">64</span> <span class=\"hljs-keyword\">while</span> (!done) {\n    ...\n<span class=\"hljs-number\">69</span> <span class=\"hljs-keyword\">if</span> ( total &gt; projectedTotal ) {         **&lt;--<span class=\"hljs-number\">2</span>**\n<span class=\"hljs-number\">70</span>     done=<span class=\"hljs-keyword\">true</span>;            **&lt;--<span class=\"hljs-number\">3</span>**\n(<span class=\"hljs-number\">1</span>) lần cuối gọi recordIndex.\n(<span class=\"hljs-number\">2</span>) lần cuối gọi total.\n(<span class=\"hljs-number\">3</span>) lần cuối gọi done.</code></pre>\n<p>Đây là live time của 3 biến trong ví dụ này:</p>\n<ul>\n<li>recordIndex: ( line 28 - line 2 + 1 ) = 27 </li>\n<li>total:  ( line 69 - line 3 + 1 ) = 67 </li>\n<li>done: ( line 70 - line 4 + 1 ) = 67</li>\n<li>Live Time trung bình: ( 27 + 67 + 67 ) / 3 ≈ 54</li>\n</ul>\n<p>Còn đây là bản sửa lại:</p>\n<pre><code class=\"hljs language-java\">...\n<span class=\"hljs-number\">25</span>  recordIndex = <span class=\"hljs-number\">0</span>;       &lt;-- <span class=\"hljs-number\">1</span>\n<span class=\"hljs-number\">26</span>  <span class=\"hljs-keyword\">while</span> ( recordIndex &lt; recordCount ) {\n<span class=\"hljs-number\">27</span>  ...\n<span class=\"hljs-number\">28</span>     recordIndex = recordIndex + <span class=\"hljs-number\">1</span>;\n       ...\n<span class=\"hljs-number\">62</span>  total = <span class=\"hljs-number\">0</span>;       &lt;-- <span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">63</span>  done = <span class=\"hljs-keyword\">false</span>;       &lt;-- <span class=\"hljs-number\">2</span>\n<span class=\"hljs-number\">64</span>  <span class=\"hljs-keyword\">while</span> ( !done ) {\n       ...\n<span class=\"hljs-number\">69</span>     <span class=\"hljs-keyword\">if</span> ( total &gt; projectedTotal ) {\n<span class=\"hljs-number\">70</span>        done = <span class=\"hljs-keyword\">true</span>;\n(<span class=\"hljs-number\">1</span>)Khởi tạo recordIndex được chuyển xuống từ dòng <span class=\"hljs-number\">3</span>.\n(<span class=\"hljs-number\">2</span>)Khởi tạo total và done được chuyển xuống từ dòng <span class=\"hljs-number\">4</span> and <span class=\"hljs-number\">5</span></code></pre>\n<p>Đây là thời gian tồn tại của biến trong ví dụ:</p>\n<ul>\n<li>recordIndex: ( line 28 - line 25 + 1 ) = 4 </li>\n<li>total: ( line 69 - line 62 + 1 ) = 8 </li>\n<li>done :  ( line 70 - line 63 + 1 ) = 8</li>\n<li>Live Time trung bình: ( 4 + 4+ 8 ) / 3 ≈ 7</li>\n</ul>\n<p>Như đã thấy, ví dụ thứ 2 tốt hơn ví dụ thứ nhất bởi khởi tạo biến được biểu diễn gần nhau ở nơi biến được sử dụng. Sự khác nhau của hai live time trung bình thật sự rất đáng chú ý: 54 và 7</p>\n<p>Một con số làm nên sự khác biệt code tốt và không tốt? Mặc dù các nhà nghiên cứu chưa có con số nào chính xác nhưng hoàn toàn có thể tin rằng: live time với span càng nhỏ thì càng tốt.</p>\n<p>Nếu bạn thử có áp dụng khái niệm span và live time vào biến toàn cục thì bạn sẽ được con số rất lớn, đây là một trong nhiều lí do ta nên tránh dùng biến toàn cục khi có thể dùng biến cục bộ.</p>\n<p>#Một số thủ thuật làm nhỏ &quot;địa bàn&quot; của biến</p>\n<p>Đây là một số thủ thuật đặc biệt để giúp bạn thu gọn tầm hoạt động của biến lại:</p>\n<p><strong>Khởi tạo biến được dùng trong vòng lặp ngay trước vòng lặp đó chứ đừng đặt ở đầu hàm chứa vòng lặp đó</strong>. Việc này sẽ có ích khi bạn sửa đổi vòng lặp, bạn sẽ nhớ phải thay đổi cả các khởi tạo vòng lặp.</p>\n<p><strong>Chỉ gán giá trị cho biến khi nó được sử dụng.</strong>  Nếu gán bừa bãi sau này bạn sẽ gặp khó khăn khi đọc code.</p>\n<p><strong>Nhóm những câu lệnh liên quan lại với nhau</strong>. Các ví dụ sau sẽ minh hoạ việc nhóm các tham chiếu đến các biến lại với nhau làm cho chúng dễ tìm thấy hơn. Đầu tiên là ví dụ của việc vi phạm nguyên tắc này:</p>\n<pre><code class=\"hljs language-c\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">SummarizeData</span><span class=\"hljs-params\">(...)</span> </span>{\n   ...\n   GetOldData( oldData, &amp;numOldData );      **&lt;-- <span class=\"hljs-number\">1</span>**\n   GetNewData( newData, &amp;numNewData );         |\n   totalOldData = Sum( oldData, numOldData );  |\n   totalNewData = Sum( newData, numNewData );  |\n   PrintOldDataSummary( oldData, totalOldData, numOldData );\n   PrintNewDataSummary( newData, totalNewData, numNewData );\n   SaveOldDataSummary( totalOldData, numOldData );\n   SaveNewDataSummary( totalNewData, numNewData );       **&lt;-- <span class=\"hljs-number\">1</span>**\n   ...\n}\n\n(<span class=\"hljs-number\">1</span>)Các câu lệnh sử dụng <span class=\"hljs-number\">2</span> tập hợp biến</code></pre>\n<p>Trong ví dụ này, bạn ném các biến oldData, newData, numOldData, numNewData, totalOldData vào một block. Ví dụ sau sẽ để 3 biến trong một block:</p>\n<pre><code class=\"hljs language-c\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">SummarizeData</span><span class=\"hljs-params\">( ... )</span> </span>{\n   GetOldData( oldData, &amp;numOldData );       &lt;-- <span class=\"hljs-number\">1</span>\n   totalOldData = Sum( oldData, numOldData );  |\n   PrintOldDataSummary( oldData, totalOldData, numOldData );\n   SaveOldDataSummary( totalOldData, numOldData );       &lt;-- <span class=\"hljs-number\">1</span>\n   ...\n   GetNewData( newData, &amp;numNewData );       &lt;-- <span class=\"hljs-number\">2</span>\n   totalNewData = Sum( newData, numNewData );  |\n   PrintNewDataSummary( newData, totalNewData, numNewData );\n   SaveNewDataSummary( totalNewData, numNewData );       &lt;-- <span class=\"hljs-number\">2</span>\n   ...\n}\n\n(<span class=\"hljs-number\">1</span>)Các câu lệnh sử dụng oldData.\n\n(<span class=\"hljs-number\">2</span>)Các câu lệnh sử dụng newData.</code></pre>\n<p>Khi mà code bị lỗi thì việc tách như trên sẽ giúp ta sửa dễ dàng sửa lỗi hơn và cả khi bạn muốn chia code này ra thành các hàm thì rõ ràng  cách viết thứ hai này sẽ tách nhanh hơn cách thứ nhất.</p>\n<p><strong>Phá những nhóm câu lệnh có liên quan để đưa vào các hàm riêng</strong>. Một biến trong một hàm sẽ có khuynh hướng làm span và live time nhỏ hơn. Bằng cách phá nhóm câu lệnh ra như vậy bạn làm dảm &quot;địa bàn hoạt động&quot; của các biến rất nhiều.</p>\n<p><strong>Bắt đầu với phạm vi nhỏ nhất có thể, chỉ mở rộng khi nào thật cần thiết.</strong> Việc thu nhỏ phạm vi một biến đã được mở rộng thì khó hơn rất nhiều việc mở rộng phạm vi của biến đang có phạm vi nhỏ, đưa một biến toàn cục thành một biến class thì đương nhiên sẽ khó hơn rất nhiều với việc đưa biến class thành biến toàn cục. Với lí do đó, hãy ưu tiên cho phạm vi nhỏ nhất có thể: một biến cục bộ cho mỗi vòng lặp, một biến cục bộ cho một hàm, rồi biến private cho class, rồi đến biến protected, rồi package( nếu ngôn ngữ của bạn hỗ trợ nó), và tất nhiên biến toàn cục là phương án cuối cùng!</p>\n<p>Đối với nhiều lập trình viên, việc thu nhỏ phạm vi biến hay không còn phụ thuộc vào  quan điểm của họ về &quot;sự tiện lợi&quot; và &quot;sự dễ quản lí&quot;. Một số lập trình viên dùng rất nhiều biến toàn cục vì nó có thể truy cập từ bất cứ đâu mà không bị mấy cái quy định về phạm vi biến làm phiền. Trong suy nghĩ của họ, sự tiện lợi đó quan trọng hơn cả những rủi ro cực kì rắc rối.</p>\n<p>Những lập trình viên khác thì thích giữ các biến càng cục bộ càng tốt bởi vì nó giúp cho code dễ quản lí hơn. Càng ẩn đi nhiều thông tin thì bạn càng dễ tập trung hơn vào một thứ trong một thời điểm. Như thế có thể giúp bạn tránh những lỗi do bạn quên mất một trong số hàng tá thông tin mà bạn phải nhớ cùng lúc.</p>\n<p>Sự khác biệt giữa triết lí &quot;thuận tiện&quot; và triết lí &quot;dễ quản lí&quot; nhấn mạnh sự khác nhau trong viết và đọc chương trình. Mở rộng hết mức phạm vi biến có thể làm cho việc viết chương trình dễ hơn nhiều nhưng một chương trình mà một hàm cũng có thể gọi các biến từ bất kì đâu sẽ rất khó để tìm ra đâu là yếu tố mà những hàm đó thật sự sử dụng. Trong một chương trình như thế, bạn không thể hiểu chỉ một hàm mà phải hiểu toàn bộ chương trình. Một chương trình như vậy thì rất khó đọc, rất khó Debug, cũng như rất khó để chỉnh sửa.</p>\n<p>Tóm lại, bạn nên khai báo/sử dụng mỗi biến làm sao cho nó được nhìn thấy trong đoạn code nhỏ nhất có thể. Rồi bạn sẽ nhận ra rằng bạn rất hiếm khi  bạn sử dụng một biến toàn cục một cách đơn thuần :blush:</p>\n<hr>\n<p>Bài viết có tham khảo một số nội dung trong cuốn Code Complete và các tài liệu khác :blush:</p>\n<hr>\n<p>Part 1 ở đây: <a href=\"http://daynhauhoc.com/t/lam-sao-de-su-dung-bien-hieu-qua-hon-part1/6921\">http://daynhauhoc.com/t/lam-sao-de-su-dung-bien-hieu-qua-hon-part1/6921</a>\nPart3 ở đây:  <a href=\"http://daynhauhoc.com/t/lam-sao-de-su-dung-bien-hieu-qua-hon-part3/6992\">http://daynhauhoc.com/t/lam-sao-de-su-dung-bien-hieu-qua-hon-part3/6992</a>\nPart4 ở đây: <a href=\"http://daynhauhoc.com/t/lam-sao-de-su-dung-bien-hieu-qua-hon-part-4/7063\">http://daynhauhoc.com/t/lam-sao-de-su-dung-bien-hieu-qua-hon-part-4/7063</a>\n[1]: <a href=\"http://daynhauhoc.com/t/lam-sao-de-su-dung-bien-hieu-qua-hon-part1/6921\">http://daynhauhoc.com/t/lam-sao-de-su-dung-bien-hieu-qua-hon-part1/6921</a></p>\n","rawBody":"\n\nBài [viết trước][1] mình đã nói về cách khai báo biến và khởi tạo biến và bài viết này sẽ nói về cách chọn phạm vi biến sao cho code hiệu quả, dễ đọc, dễ hiểu và tất nhiên là dễ debug :blush:\n\n#Part2: Phạm vi biến (Scope)\n----------------\n<div align=center><img src='/uploads/default/2986/5e46151fe3050079.png' width=\"500\" height=\"429\"> <br></div>\n\n##Hãy để tham chiếu (reference)  đến các biến gần nhau\n\nCó một phương pháp để tính toán mức độ gần nhau của các tham chiếu/lời gọi biến đó là ước tính số span của biến . Đây là ví dụ về số span:\n\n```\na=0;  <--- Tham chiếu đến a lần 1\nb=0; <--- Tham chiếu đến b lần 1\nc=0;<--- Tham chiếu đến c lần 1\na= b + c;  <--- Tham chiếu đến a lần 2, Tham chiếu đến b lần 2, Tham chiếu đến c lần 2\n```\nTrong trường hợp này, có 2 dòng nằm giữa tham chiếu đến biến `a` thứ nhất và thứ hai, vậy `a` có số span là 2, tương tự ta có số span của b và c lần lượt là 1 và 0. Và đây là một ví dụ khác\n\n```\na = 0;\nb = 0;\nc = 0;\nb = a + 1;\nb = b / c;\n```\n\nTrong trường hợp này, có 1 dòng giữa tham chiếu đến `b` thứ nhất và thứ hai nên nó có span là 1. Và không có dòng nào giữa tham chiếu thứ hai và tham chiếu thứ ba, vậy có span là 0.\n\nSố span trung bình được tính toán dựa trên những span riêng lẻ. Trong ví dụ 2, với b, (1+0)/2 = 0.5, vậy số span trung bình của b là 0.5. Khi mà bạn giữ các tham chiếu đến biến gần nhau, bạn có thể giúp người đọc code của bạn tập trung vào một phần của code, còn  nếu bạn gọi biến cách xa nhau, bạn sẽ bắt người đọc lục tung cả chương trình. Vì thế lợi ích chính của việc sắp xếp biến gần nhau là tăng khả năng đọc code rõ ràng và dễ hiểu hơn.\n\n##Hãy giữ cho biến \"sống\" trong thời gian ít nhất có thể\n\nỞ đây ta có thêm một khái niệm nữa là \"live time\" là tổng số dòng lệnh mà biến được sử dụng. Biến tồn tại từ dòng lệnh đầu tiên mà nó được gọi đến và nó kết thúc ở dòng lệnh cuối cùng mà nó được gọi đến.\n\nKhông giống như span, live time của biến không bị ảnh hưởng bởi số lần biến được sử dụng từ lần đầu tới lần cuối mà biến được gọi đến. Nếu biến được gọi lần đầu tiên ở dòng 1 và lần cuối cùng ở dòng 25 thì nó sẽ tồn tại trong 25 dòng lệnh. Nếu chỉ có 2 dòng trong đó biến được sử dụng thì nó có span trung bình là 23 dòng lệnh. Nếu biến đã được dùng ở mỗi dòng từ dòng 1 đến 25, nó sẽ có số span trung bình là 0 dòng lệnh, nhưng nó vấn sẽ có live time là 25 dòng lệnh. Hình 10-1 minh họa cả 2 thông số span và live time.\n\n<div align=center><img src=\"/uploads/default/2982/f2e568955025434a.jpg\" width=\"500\" height=\"429\"> <br> <br>\"Live time\" thể hiện tuổi thọ của biến, \"Span\"  là số \"bước\" nó thể hiện độ gần nhau của cách tham chiếu đến biến <br></div>\n\nTóm lại, cũng như với span, mục tiêu cần quan tâm với live time đó là giữ con số đó NHỎ,  tức là hãy làm cho biến \"chết sớm\" nhất có thể.\n##Tính toán thời gian tồn tại của biến\n\nBạn có thể tính live time của biến bằng cách đếm số dòng giữa lần đầu và lần cuối gọi biến (bao gồm cả lần đầu và lần cuối). Đây là ví dụ khi để  biến \"sống quá dai\".\n\n```java\n1 // khởi tạo tất cả các biến\n2 recordIndex= 0;\n3 total = 0;\n4 done = false;\n    ...\n26 while ( recordIndex < recordCount ) {\n27 ...\n28 recordIndex = recordIndex +1;    **<--1**\n    ...\n64 while (!done) {\n    ...\n69 if ( total > projectedTotal ) {         **<--2**\n70     done=true;            **<--3**\n(1) lần cuối gọi recordIndex.\n(2) lần cuối gọi total.\n(3) lần cuối gọi done.\n```\n\nĐây là live time của 3 biến trong ví dụ này:\n\n\n* recordIndex: ( line 28 - line 2 + 1 ) = 27 \n* total:  ( line 69 - line 3 + 1 ) = 67 \n* done: ( line 70 - line 4 + 1 ) = 67\n* Live Time trung bình: ( 27 + 67 + 67 ) / 3 ≈ 54\n\nCòn đây là bản sửa lại:\n\n```java\n...\n25  recordIndex = 0;       <-- 1\n26  while ( recordIndex < recordCount ) {\n27  ...\n28     recordIndex = recordIndex + 1;\n       ...\n62  total = 0;       <-- 2\n63  done = false;       <-- 2\n64  while ( !done ) {\n       ...\n69     if ( total > projectedTotal ) {\n70        done = true;\n(1)Khởi tạo recordIndex được chuyển xuống từ dòng 3.\n(2)Khởi tạo total và done được chuyển xuống từ dòng 4 and 5\n```\n\nĐây là thời gian tồn tại của biến trong ví dụ:\n\n\n* recordIndex: ( line 28 - line 25 + 1 ) = 4 \n* total: ( line 69 - line 62 + 1 ) = 8 \n* done :  ( line 70 - line 63 + 1 ) = 8\n* Live Time trung bình: ( 4 + 4+ 8 ) / 3 ≈ 7\n\nNhư đã thấy, ví dụ thứ 2 tốt hơn ví dụ thứ nhất bởi khởi tạo biến được biểu diễn gần nhau ở nơi biến được sử dụng. Sự khác nhau của hai live time trung bình thật sự rất đáng chú ý: 54 và 7\n\nMột con số làm nên sự khác biệt code tốt và không tốt? Mặc dù các nhà nghiên cứu chưa có con số nào chính xác nhưng hoàn toàn có thể tin rằng: live time với span càng nhỏ thì càng tốt.\n\nNếu bạn thử có áp dụng khái niệm span và live time vào biến toàn cục thì bạn sẽ được con số rất lớn, đây là một trong nhiều lí do ta nên tránh dùng biến toàn cục khi có thể dùng biến cục bộ.\n\n#Một số thủ thuật làm nhỏ \"địa bàn\" của biến\n\nĐây là một số thủ thuật đặc biệt để giúp bạn thu gọn tầm hoạt động của biến lại:\n\n**Khởi tạo biến được dùng trong vòng lặp ngay trước vòng lặp đó chứ đừng đặt ở đầu hàm chứa vòng lặp đó**. Việc này sẽ có ích khi bạn sửa đổi vòng lặp, bạn sẽ nhớ phải thay đổi cả các khởi tạo vòng lặp. \n\n**Chỉ gán giá trị cho biến khi nó được sử dụng.**  Nếu gán bừa bãi sau này bạn sẽ gặp khó khăn khi đọc code.\n\n**Nhóm những câu lệnh liên quan lại với nhau**. Các ví dụ sau sẽ minh hoạ việc nhóm các tham chiếu đến các biến lại với nhau làm cho chúng dễ tìm thấy hơn. Đầu tiên là ví dụ của việc vi phạm nguyên tắc này:\n\n```c\nvoid SummarizeData(...) {\n   ...\n   GetOldData( oldData, &numOldData );      **<-- 1**\n   GetNewData( newData, &numNewData );         |\n   totalOldData = Sum( oldData, numOldData );  |\n   totalNewData = Sum( newData, numNewData );  |\n   PrintOldDataSummary( oldData, totalOldData, numOldData );\n   PrintNewDataSummary( newData, totalNewData, numNewData );\n   SaveOldDataSummary( totalOldData, numOldData );\n   SaveNewDataSummary( totalNewData, numNewData );       **<-- 1**\n   ...\n}\n\n(1)Các câu lệnh sử dụng 2 tập hợp biến\n```\nTrong ví dụ này, bạn ném các biến oldData, newData, numOldData, numNewData, totalOldData vào một block. Ví dụ sau sẽ để 3 biến trong một block:\n\n```c\nvoid SummarizeData( ... ) {\n   GetOldData( oldData, &numOldData );       <-- 1\n   totalOldData = Sum( oldData, numOldData );  |\n   PrintOldDataSummary( oldData, totalOldData, numOldData );\n   SaveOldDataSummary( totalOldData, numOldData );       <-- 1\n   ...\n   GetNewData( newData, &numNewData );       <-- 2\n   totalNewData = Sum( newData, numNewData );  |\n   PrintNewDataSummary( newData, totalNewData, numNewData );\n   SaveNewDataSummary( totalNewData, numNewData );       <-- 2\n   ...\n}\n\n(1)Các câu lệnh sử dụng oldData.\n\n(2)Các câu lệnh sử dụng newData.\n```\nKhi mà code bị lỗi thì việc tách như trên sẽ giúp ta sửa dễ dàng sửa lỗi hơn và cả khi bạn muốn chia code này ra thành các hàm thì rõ ràng  cách viết thứ hai này sẽ tách nhanh hơn cách thứ nhất.\n\n**Phá những nhóm câu lệnh có liên quan để đưa vào các hàm riêng**. Một biến trong một hàm sẽ có khuynh hướng làm span và live time nhỏ hơn. Bằng cách phá nhóm câu lệnh ra như vậy bạn làm dảm \"địa bàn hoạt động\" của các biến rất nhiều.\n\n**Bắt đầu với phạm vi nhỏ nhất có thể, chỉ mở rộng khi nào thật cần thiết.** Việc thu nhỏ phạm vi một biến đã được mở rộng thì khó hơn rất nhiều việc mở rộng phạm vi của biến đang có phạm vi nhỏ, đưa một biến toàn cục thành một biến class thì đương nhiên sẽ khó hơn rất nhiều với việc đưa biến class thành biến toàn cục. Với lí do đó, hãy ưu tiên cho phạm vi nhỏ nhất có thể: một biến cục bộ cho mỗi vòng lặp, một biến cục bộ cho một hàm, rồi biến private cho class, rồi đến biến protected, rồi package( nếu ngôn ngữ của bạn hỗ trợ nó), và tất nhiên biến toàn cục là phương án cuối cùng!\n\n\nĐối với nhiều lập trình viên, việc thu nhỏ phạm vi biến hay không còn phụ thuộc vào  quan điểm của họ về \"sự tiện lợi\" và \"sự dễ quản lí\". Một số lập trình viên dùng rất nhiều biến toàn cục vì nó có thể truy cập từ bất cứ đâu mà không bị mấy cái quy định về phạm vi biến làm phiền. Trong suy nghĩ của họ, sự tiện lợi đó quan trọng hơn cả những rủi ro cực kì rắc rối.\n\nNhững lập trình viên khác thì thích giữ các biến càng cục bộ càng tốt bởi vì nó giúp cho code dễ quản lí hơn. Càng ẩn đi nhiều thông tin thì bạn càng dễ tập trung hơn vào một thứ trong một thời điểm. Như thế có thể giúp bạn tránh những lỗi do bạn quên mất một trong số hàng tá thông tin mà bạn phải nhớ cùng lúc.\n\nSự khác biệt giữa triết lí \"thuận tiện\" và triết lí \"dễ quản lí\" nhấn mạnh sự khác nhau trong viết và đọc chương trình. Mở rộng hết mức phạm vi biến có thể làm cho việc viết chương trình dễ hơn nhiều nhưng một chương trình mà một hàm cũng có thể gọi các biến từ bất kì đâu sẽ rất khó để tìm ra đâu là yếu tố mà những hàm đó thật sự sử dụng. Trong một chương trình như thế, bạn không thể hiểu chỉ một hàm mà phải hiểu toàn bộ chương trình. Một chương trình như vậy thì rất khó đọc, rất khó Debug, cũng như rất khó để chỉnh sửa.\n\nTóm lại, bạn nên khai báo/sử dụng mỗi biến làm sao cho nó được nhìn thấy trong đoạn code nhỏ nhất có thể. Rồi bạn sẽ nhận ra rằng bạn rất hiếm khi  bạn sử dụng một biến toàn cục một cách đơn thuần :blush: \n\n-----------\n\n\nBài viết có tham khảo một số nội dung trong cuốn Code Complete và các tài liệu khác :blush: \n\n\n------------\nPart 1 ở đây: http://daynhauhoc.com/t/lam-sao-de-su-dung-bien-hieu-qua-hon-part1/6921\nPart3 ở đây:  http://daynhauhoc.com/t/lam-sao-de-su-dung-bien-hieu-qua-hon-part3/6992\nPart4 ở đây: http://daynhauhoc.com/t/lam-sao-de-su-dung-bien-hieu-qua-hon-part-4/7063\n  [1]: http://daynhauhoc.com/t/lam-sao-de-su-dung-bien-hieu-qua-hon-part1/6921\n","raw":"---json\n{\"layout\":\"Post\",\"route\":\"lam-sao-de-su-dung-bien-hieu-qua-hon-part2\",\"title\":\"Làm sao để sử dụng biến hiệu quả hơn (part2)\",\"tags\":[\"coding-style\"],\"date\":\"2015-05-06T03:16:39.897Z\"}\n---\n\n\nBài [viết trước][1] mình đã nói về cách khai báo biến và khởi tạo biến và bài viết này sẽ nói về cách chọn phạm vi biến sao cho code hiệu quả, dễ đọc, dễ hiểu và tất nhiên là dễ debug :blush:\n\n#Part2: Phạm vi biến (Scope)\n----------------\n<div align=center><img src='/uploads/default/2986/5e46151fe3050079.png' width=\"500\" height=\"429\"> <br></div>\n\n##Hãy để tham chiếu (reference)  đến các biến gần nhau\n\nCó một phương pháp để tính toán mức độ gần nhau của các tham chiếu/lời gọi biến đó là ước tính số span của biến . Đây là ví dụ về số span:\n\n```\na=0;  <--- Tham chiếu đến a lần 1\nb=0; <--- Tham chiếu đến b lần 1\nc=0;<--- Tham chiếu đến c lần 1\na= b + c;  <--- Tham chiếu đến a lần 2, Tham chiếu đến b lần 2, Tham chiếu đến c lần 2\n```\nTrong trường hợp này, có 2 dòng nằm giữa tham chiếu đến biến `a` thứ nhất và thứ hai, vậy `a` có số span là 2, tương tự ta có số span của b và c lần lượt là 1 và 0. Và đây là một ví dụ khác\n\n```\na = 0;\nb = 0;\nc = 0;\nb = a + 1;\nb = b / c;\n```\n\nTrong trường hợp này, có 1 dòng giữa tham chiếu đến `b` thứ nhất và thứ hai nên nó có span là 1. Và không có dòng nào giữa tham chiếu thứ hai và tham chiếu thứ ba, vậy có span là 0.\n\nSố span trung bình được tính toán dựa trên những span riêng lẻ. Trong ví dụ 2, với b, (1+0)/2 = 0.5, vậy số span trung bình của b là 0.5. Khi mà bạn giữ các tham chiếu đến biến gần nhau, bạn có thể giúp người đọc code của bạn tập trung vào một phần của code, còn  nếu bạn gọi biến cách xa nhau, bạn sẽ bắt người đọc lục tung cả chương trình. Vì thế lợi ích chính của việc sắp xếp biến gần nhau là tăng khả năng đọc code rõ ràng và dễ hiểu hơn.\n\n##Hãy giữ cho biến \"sống\" trong thời gian ít nhất có thể\n\nỞ đây ta có thêm một khái niệm nữa là \"live time\" là tổng số dòng lệnh mà biến được sử dụng. Biến tồn tại từ dòng lệnh đầu tiên mà nó được gọi đến và nó kết thúc ở dòng lệnh cuối cùng mà nó được gọi đến.\n\nKhông giống như span, live time của biến không bị ảnh hưởng bởi số lần biến được sử dụng từ lần đầu tới lần cuối mà biến được gọi đến. Nếu biến được gọi lần đầu tiên ở dòng 1 và lần cuối cùng ở dòng 25 thì nó sẽ tồn tại trong 25 dòng lệnh. Nếu chỉ có 2 dòng trong đó biến được sử dụng thì nó có span trung bình là 23 dòng lệnh. Nếu biến đã được dùng ở mỗi dòng từ dòng 1 đến 25, nó sẽ có số span trung bình là 0 dòng lệnh, nhưng nó vấn sẽ có live time là 25 dòng lệnh. Hình 10-1 minh họa cả 2 thông số span và live time.\n\n<div align=center><img src=\"/uploads/default/2982/f2e568955025434a.jpg\" width=\"500\" height=\"429\"> <br> <br>\"Live time\" thể hiện tuổi thọ của biến, \"Span\"  là số \"bước\" nó thể hiện độ gần nhau của cách tham chiếu đến biến <br></div>\n\nTóm lại, cũng như với span, mục tiêu cần quan tâm với live time đó là giữ con số đó NHỎ,  tức là hãy làm cho biến \"chết sớm\" nhất có thể.\n##Tính toán thời gian tồn tại của biến\n\nBạn có thể tính live time của biến bằng cách đếm số dòng giữa lần đầu và lần cuối gọi biến (bao gồm cả lần đầu và lần cuối). Đây là ví dụ khi để  biến \"sống quá dai\".\n\n```java\n1 // khởi tạo tất cả các biến\n2 recordIndex= 0;\n3 total = 0;\n4 done = false;\n    ...\n26 while ( recordIndex < recordCount ) {\n27 ...\n28 recordIndex = recordIndex +1;    **<--1**\n    ...\n64 while (!done) {\n    ...\n69 if ( total > projectedTotal ) {         **<--2**\n70     done=true;            **<--3**\n(1) lần cuối gọi recordIndex.\n(2) lần cuối gọi total.\n(3) lần cuối gọi done.\n```\n\nĐây là live time của 3 biến trong ví dụ này:\n\n\n* recordIndex: ( line 28 - line 2 + 1 ) = 27 \n* total:  ( line 69 - line 3 + 1 ) = 67 \n* done: ( line 70 - line 4 + 1 ) = 67\n* Live Time trung bình: ( 27 + 67 + 67 ) / 3 ≈ 54\n\nCòn đây là bản sửa lại:\n\n```java\n...\n25  recordIndex = 0;       <-- 1\n26  while ( recordIndex < recordCount ) {\n27  ...\n28     recordIndex = recordIndex + 1;\n       ...\n62  total = 0;       <-- 2\n63  done = false;       <-- 2\n64  while ( !done ) {\n       ...\n69     if ( total > projectedTotal ) {\n70        done = true;\n(1)Khởi tạo recordIndex được chuyển xuống từ dòng 3.\n(2)Khởi tạo total và done được chuyển xuống từ dòng 4 and 5\n```\n\nĐây là thời gian tồn tại của biến trong ví dụ:\n\n\n* recordIndex: ( line 28 - line 25 + 1 ) = 4 \n* total: ( line 69 - line 62 + 1 ) = 8 \n* done :  ( line 70 - line 63 + 1 ) = 8\n* Live Time trung bình: ( 4 + 4+ 8 ) / 3 ≈ 7\n\nNhư đã thấy, ví dụ thứ 2 tốt hơn ví dụ thứ nhất bởi khởi tạo biến được biểu diễn gần nhau ở nơi biến được sử dụng. Sự khác nhau của hai live time trung bình thật sự rất đáng chú ý: 54 và 7\n\nMột con số làm nên sự khác biệt code tốt và không tốt? Mặc dù các nhà nghiên cứu chưa có con số nào chính xác nhưng hoàn toàn có thể tin rằng: live time với span càng nhỏ thì càng tốt.\n\nNếu bạn thử có áp dụng khái niệm span và live time vào biến toàn cục thì bạn sẽ được con số rất lớn, đây là một trong nhiều lí do ta nên tránh dùng biến toàn cục khi có thể dùng biến cục bộ.\n\n#Một số thủ thuật làm nhỏ \"địa bàn\" của biến\n\nĐây là một số thủ thuật đặc biệt để giúp bạn thu gọn tầm hoạt động của biến lại:\n\n**Khởi tạo biến được dùng trong vòng lặp ngay trước vòng lặp đó chứ đừng đặt ở đầu hàm chứa vòng lặp đó**. Việc này sẽ có ích khi bạn sửa đổi vòng lặp, bạn sẽ nhớ phải thay đổi cả các khởi tạo vòng lặp. \n\n**Chỉ gán giá trị cho biến khi nó được sử dụng.**  Nếu gán bừa bãi sau này bạn sẽ gặp khó khăn khi đọc code.\n\n**Nhóm những câu lệnh liên quan lại với nhau**. Các ví dụ sau sẽ minh hoạ việc nhóm các tham chiếu đến các biến lại với nhau làm cho chúng dễ tìm thấy hơn. Đầu tiên là ví dụ của việc vi phạm nguyên tắc này:\n\n```c\nvoid SummarizeData(...) {\n   ...\n   GetOldData( oldData, &numOldData );      **<-- 1**\n   GetNewData( newData, &numNewData );         |\n   totalOldData = Sum( oldData, numOldData );  |\n   totalNewData = Sum( newData, numNewData );  |\n   PrintOldDataSummary( oldData, totalOldData, numOldData );\n   PrintNewDataSummary( newData, totalNewData, numNewData );\n   SaveOldDataSummary( totalOldData, numOldData );\n   SaveNewDataSummary( totalNewData, numNewData );       **<-- 1**\n   ...\n}\n\n(1)Các câu lệnh sử dụng 2 tập hợp biến\n```\nTrong ví dụ này, bạn ném các biến oldData, newData, numOldData, numNewData, totalOldData vào một block. Ví dụ sau sẽ để 3 biến trong một block:\n\n```c\nvoid SummarizeData( ... ) {\n   GetOldData( oldData, &numOldData );       <-- 1\n   totalOldData = Sum( oldData, numOldData );  |\n   PrintOldDataSummary( oldData, totalOldData, numOldData );\n   SaveOldDataSummary( totalOldData, numOldData );       <-- 1\n   ...\n   GetNewData( newData, &numNewData );       <-- 2\n   totalNewData = Sum( newData, numNewData );  |\n   PrintNewDataSummary( newData, totalNewData, numNewData );\n   SaveNewDataSummary( totalNewData, numNewData );       <-- 2\n   ...\n}\n\n(1)Các câu lệnh sử dụng oldData.\n\n(2)Các câu lệnh sử dụng newData.\n```\nKhi mà code bị lỗi thì việc tách như trên sẽ giúp ta sửa dễ dàng sửa lỗi hơn và cả khi bạn muốn chia code này ra thành các hàm thì rõ ràng  cách viết thứ hai này sẽ tách nhanh hơn cách thứ nhất.\n\n**Phá những nhóm câu lệnh có liên quan để đưa vào các hàm riêng**. Một biến trong một hàm sẽ có khuynh hướng làm span và live time nhỏ hơn. Bằng cách phá nhóm câu lệnh ra như vậy bạn làm dảm \"địa bàn hoạt động\" của các biến rất nhiều.\n\n**Bắt đầu với phạm vi nhỏ nhất có thể, chỉ mở rộng khi nào thật cần thiết.** Việc thu nhỏ phạm vi một biến đã được mở rộng thì khó hơn rất nhiều việc mở rộng phạm vi của biến đang có phạm vi nhỏ, đưa một biến toàn cục thành một biến class thì đương nhiên sẽ khó hơn rất nhiều với việc đưa biến class thành biến toàn cục. Với lí do đó, hãy ưu tiên cho phạm vi nhỏ nhất có thể: một biến cục bộ cho mỗi vòng lặp, một biến cục bộ cho một hàm, rồi biến private cho class, rồi đến biến protected, rồi package( nếu ngôn ngữ của bạn hỗ trợ nó), và tất nhiên biến toàn cục là phương án cuối cùng!\n\n\nĐối với nhiều lập trình viên, việc thu nhỏ phạm vi biến hay không còn phụ thuộc vào  quan điểm của họ về \"sự tiện lợi\" và \"sự dễ quản lí\". Một số lập trình viên dùng rất nhiều biến toàn cục vì nó có thể truy cập từ bất cứ đâu mà không bị mấy cái quy định về phạm vi biến làm phiền. Trong suy nghĩ của họ, sự tiện lợi đó quan trọng hơn cả những rủi ro cực kì rắc rối.\n\nNhững lập trình viên khác thì thích giữ các biến càng cục bộ càng tốt bởi vì nó giúp cho code dễ quản lí hơn. Càng ẩn đi nhiều thông tin thì bạn càng dễ tập trung hơn vào một thứ trong một thời điểm. Như thế có thể giúp bạn tránh những lỗi do bạn quên mất một trong số hàng tá thông tin mà bạn phải nhớ cùng lúc.\n\nSự khác biệt giữa triết lí \"thuận tiện\" và triết lí \"dễ quản lí\" nhấn mạnh sự khác nhau trong viết và đọc chương trình. Mở rộng hết mức phạm vi biến có thể làm cho việc viết chương trình dễ hơn nhiều nhưng một chương trình mà một hàm cũng có thể gọi các biến từ bất kì đâu sẽ rất khó để tìm ra đâu là yếu tố mà những hàm đó thật sự sử dụng. Trong một chương trình như thế, bạn không thể hiểu chỉ một hàm mà phải hiểu toàn bộ chương trình. Một chương trình như vậy thì rất khó đọc, rất khó Debug, cũng như rất khó để chỉnh sửa.\n\nTóm lại, bạn nên khai báo/sử dụng mỗi biến làm sao cho nó được nhìn thấy trong đoạn code nhỏ nhất có thể. Rồi bạn sẽ nhận ra rằng bạn rất hiếm khi  bạn sử dụng một biến toàn cục một cách đơn thuần :blush: \n\n-----------\n\n\nBài viết có tham khảo một số nội dung trong cuốn Code Complete và các tài liệu khác :blush: \n\n\n------------\nPart 1 ở đây: http://daynhauhoc.com/t/lam-sao-de-su-dung-bien-hieu-qua-hon-part1/6921\nPart3 ở đây:  http://daynhauhoc.com/t/lam-sao-de-su-dung-bien-hieu-qua-hon-part3/6992\nPart4 ở đây: http://daynhauhoc.com/t/lam-sao-de-su-dung-bien-hieu-qua-hon-part-4/7063\n  [1]: http://daynhauhoc.com/t/lam-sao-de-su-dung-bien-hieu-qua-hon-part1/6921\n","__filename":"6936.md","__url":"/lam-sao-de-su-dung-bien-hieu-qua-hon-part2/","__resourceUrl":"/lam-sao-de-su-dung-bien-hieu-qua-hon-part2/index.html","__dataUrl":"/lam-sao-de-su-dung-bien-hieu-qua-hon-part2/index.html.36d9bda6ebb334c11685da15ddf9282c.json"}