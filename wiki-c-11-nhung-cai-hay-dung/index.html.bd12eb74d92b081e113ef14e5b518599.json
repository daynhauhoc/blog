{"head":{"id":2944,"layout":"Post","route":"wiki-c-11-nhung-cai-hay-dung","title":"[Wiki] C++11 những cái hay dùng","tags":["wiki","c","c++"],"date":"2014-12-23T11:03:55.579Z","views":979,"likes":12,"description":"Bài tham khảo từ link: http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer\n\nSử dụng auto\n\nTrong C…","author":{"name":"","avatar":"/user_avatar/daynhauhoc.com/crossover/{size}/2342_1.png","username":"crossover"}},"body":"\n<p>Bài tham khảo từ link: <br><a href=\"http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer\" class=\"onebox\" target=\"_blank\">http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer</a></p>\n\n<p><strong>Sử dụng auto</strong></p>\n\n<p>Trong C++11 từ khóa auto được dùng để compiler có thể tự nhận diện type của dữ liệu đầu vào thông qua rvalue</p>\n\n<p>VD:</p>\n\n<pre><code>auto a = 1; // is equal with int a = 1\nauto a = 1f // is equal with float a = 1.f\nauto a = new foo(); // is equal with *a = new foo();</code></pre>\n\n<p>Có một lưu ý là khi sử dụng auto cho biến bất kì thì ta luôn phải initialize cho biến đó.<br>VD: <code>auto a; // error</code></p>\n\n<p><strong>Sử dụng nullptr</strong></p>\n\n<p>Để gán giá trị null cho con trỏ</p>\n\n<pre><code>int *p = nullptr;</code></pre>\n\n<p><strong>ForEach</strong></p>\n\n<p>Duyệt tất cả các phần tử của mảng</p>\n\n<p>VD<br></p>\n\n<p></p><pre><code class=\"lang-auto\">int arr[5] = {1, 2, 3, 4, 5};\nfor( auto &amp;a : arr)\n{\n    cout&lt;&lt; a &lt;&lt; endl; // in ra màn hình 1, 2, 3, 4, 5\n}</code></pre>\n\n<p><strong>Override và final</strong></p>\n\n<p>Cái này là một định danh.<br>Giả sử với vd sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">class B\n{\npublic:\n    virtual void f(short)\n    {\n        std::cout &lt;&lt; \"B::f\" &lt;&lt; std::endl;\n    }\n};\n\nclass D : public B\n{\npublic:\n    virtual void f(int)\n    {\n        std::cout &lt;&lt; \"D::f\" &lt;&lt; std::endl;\n    }\n};</code></pre>\n\n<p>Trường hợp này, function f ở class D là overload (vì param truyền vào là khác kiểu nhau).<br>Hoặc với vd khác:</p>\n\n<p></p><pre><code class=\"lang-auto\">class B\n{\npublic:\n    virtual void f(int) const\n    {\n        std::cout &lt;&lt; \"B::f \" &lt;&lt; std::endl;\n    }\n};\n\nclass D : public B\n{\npublic:\n    virtual void f(int)\n    {\n        std::cout &lt;&lt; \"D::f\" &lt;&lt; std::endl;\n    }\n};</code></pre>\n\n<p>Ở trường hợp này function f ở class D vẫn là overload chứ ko phải là override. Để tránh gây nhầm lẫn, C++11 thêm định danh là override và final giống như trong java. 2 từ khóa này có thể đi liền nhau \"override final\"</p>\n\n<p></p><pre><code class=\"lang-auto\">class B\n{\npublic:\n    virtual void f(short)\n    {\n        std::cout &lt;&lt; \"B::f\" &lt;&lt; std::endl;\n    }\n    void g(short)\n    {\n        std::cout &lt;&lt; \"B::g\" &lt;&lt; std::endl;\n    }\n};\n\nclass D : public B\n{\npublic:\n    virtual void f(int) override\n    {\n        std::cout &lt;&lt; \"D::f\" &lt;&lt; std::endl;\n    }\n    virtual void g(int) override\n    {\n        std::cout &lt;&lt; \"D::g\" &lt;&lt; std::endl;   // error\n    }\n};</code></pre>\n\n<p>Lưu ý: override chỉ có tác dụng nếu function ở class base là virtual.</p>\n\n<p><strong>Enum class</strong></p>\n\n<p>VD có 2 enum</p>\n\n<p></p><pre><code class=\"lang-auto\">enum TV { on, off};\nenum LAMP { on, off};</code></pre>\n\n<p>Cả 2 enum này đều có key giống nhau, dẫn đến compiler không phân biệt <br>được. Cách giải quyết ở phiên bản cũ là dùng namespace, tuy nhiên ở <br>C++11 cái này đơn giản hơn bằng cách sử dụng enum class như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">enum class TV\n{\n    on, off\n};\nenum class LAMP\n{\n    on, off\n};\n\nTV::on;\nLAMP::on; // no error</code></pre>\n\n<p><strong>Lambda</strong></p>\n\n<p>Đây là điểm mới mà C++03 không có</p>\n\n<p>Cấu trúc nó là <a> capture-list </a> { body };<br>VD:</p>\n\n<p></p><pre><code class=\"lang-auto\">int a = 10;\nauto func1 = [=]()\n{\n    int x = a;\n    std::cout&lt;&lt; x &lt;&lt; std::endl;\n    //a += 10; // error\n};\nauto func2 = [&amp;]()\n{\n    a += 10;\n};\n\nfunc1(); // x = 10;\nfunc2(); // a = 20;</code></pre>\n\n<p><code>[&amp;]</code> sẽ giúp complier hiểu được là biến a được khai báo<br>bên ngoài lambda function sẽ được tham chiếu vào trong lambda function. <br>Còn <code>[=]</code> có nghĩa là copy giá trị của a vào trong hàm lambda, tuy nhiên<br> không thể thay đổi giá trị của a. (chỉ có tác dụng copy).</p>\n","rawBody":"\n<p>Bài tham khảo từ link: <br><a href=\"http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer\" class=\"onebox\" target=\"_blank\">http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer</a></p>\n\n<p><strong>Sử dụng auto</strong></p>\n\n<p>Trong C++11 từ khóa auto được dùng để compiler có thể tự nhận diện type của dữ liệu đầu vào thông qua rvalue</p>\n\n<p>VD:</p>\n\n<pre><code>auto a = 1; // is equal with int a = 1\nauto a = 1f // is equal with float a = 1.f\nauto a = new foo(); // is equal with *a = new foo();</code></pre>\n\n<p>Có một lưu ý là khi sử dụng auto cho biến bất kì thì ta luôn phải initialize cho biến đó.<br>VD: <code>auto a; // error</code></p>\n\n<p><strong>Sử dụng nullptr</strong></p>\n\n<p>Để gán giá trị null cho con trỏ</p>\n\n<pre><code>int *p = nullptr;</code></pre>\n\n<p><strong>ForEach</strong></p>\n\n<p>Duyệt tất cả các phần tử của mảng</p>\n\n<p>VD<br></p>\n\n<p></p><pre><code class=\"lang-auto\">int arr[5] = {1, 2, 3, 4, 5};\nfor( auto &amp;a : arr)\n{\n    cout&lt;&lt; a &lt;&lt; endl; // in ra màn hình 1, 2, 3, 4, 5\n}</code></pre>\n\n<p><strong>Override và final</strong></p>\n\n<p>Cái này là một định danh.<br>Giả sử với vd sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">class B\n{\npublic:\n    virtual void f(short)\n    {\n        std::cout &lt;&lt; \"B::f\" &lt;&lt; std::endl;\n    }\n};\n\nclass D : public B\n{\npublic:\n    virtual void f(int)\n    {\n        std::cout &lt;&lt; \"D::f\" &lt;&lt; std::endl;\n    }\n};</code></pre>\n\n<p>Trường hợp này, function f ở class D là overload (vì param truyền vào là khác kiểu nhau).<br>Hoặc với vd khác:</p>\n\n<p></p><pre><code class=\"lang-auto\">class B\n{\npublic:\n    virtual void f(int) const\n    {\n        std::cout &lt;&lt; \"B::f \" &lt;&lt; std::endl;\n    }\n};\n\nclass D : public B\n{\npublic:\n    virtual void f(int)\n    {\n        std::cout &lt;&lt; \"D::f\" &lt;&lt; std::endl;\n    }\n};</code></pre>\n\n<p>Ở trường hợp này function f ở class D vẫn là overload chứ ko phải là override. Để tránh gây nhầm lẫn, C++11 thêm định danh là override và final giống như trong java. 2 từ khóa này có thể đi liền nhau \"override final\"</p>\n\n<p></p><pre><code class=\"lang-auto\">class B\n{\npublic:\n    virtual void f(short)\n    {\n        std::cout &lt;&lt; \"B::f\" &lt;&lt; std::endl;\n    }\n    void g(short)\n    {\n        std::cout &lt;&lt; \"B::g\" &lt;&lt; std::endl;\n    }\n};\n\nclass D : public B\n{\npublic:\n    virtual void f(int) override\n    {\n        std::cout &lt;&lt; \"D::f\" &lt;&lt; std::endl;\n    }\n    virtual void g(int) override\n    {\n        std::cout &lt;&lt; \"D::g\" &lt;&lt; std::endl;   // error\n    }\n};</code></pre>\n\n<p>Lưu ý: override chỉ có tác dụng nếu function ở class base là virtual.</p>\n\n<p><strong>Enum class</strong></p>\n\n<p>VD có 2 enum</p>\n\n<p></p><pre><code class=\"lang-auto\">enum TV { on, off};\nenum LAMP { on, off};</code></pre>\n\n<p>Cả 2 enum này đều có key giống nhau, dẫn đến compiler không phân biệt <br>được. Cách giải quyết ở phiên bản cũ là dùng namespace, tuy nhiên ở <br>C++11 cái này đơn giản hơn bằng cách sử dụng enum class như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">enum class TV\n{\n    on, off\n};\nenum class LAMP\n{\n    on, off\n};\n\nTV::on;\nLAMP::on; // no error</code></pre>\n\n<p><strong>Lambda</strong></p>\n\n<p>Đây là điểm mới mà C++03 không có</p>\n\n<p>Cấu trúc nó là <a> capture-list </a> { body };<br>VD:</p>\n\n<p></p><pre><code class=\"lang-auto\">int a = 10;\nauto func1 = [=]()\n{\n    int x = a;\n    std::cout&lt;&lt; x &lt;&lt; std::endl;\n    //a += 10; // error\n};\nauto func2 = [&amp;]()\n{\n    a += 10;\n};\n\nfunc1(); // x = 10;\nfunc2(); // a = 20;</code></pre>\n\n<p><code>[&amp;]</code> sẽ giúp complier hiểu được là biến a được khai báo<br>bên ngoài lambda function sẽ được tham chiếu vào trong lambda function. <br>Còn <code>[=]</code> có nghĩa là copy giá trị của a vào trong hàm lambda, tuy nhiên<br> không thể thay đổi giá trị của a. (chỉ có tác dụng copy).</p>\n","raw":"---json\n{\"id\":2944,\"layout\":\"Post\",\"route\":\"wiki-c-11-nhung-cai-hay-dung\",\"title\":\"[Wiki] C++11 những cái hay dùng\",\"tags\":[\"wiki\",\"c\",\"c++\"],\"date\":\"2014-12-23T11:03:55.579Z\",\"views\":979,\"likes\":12,\"description\":\"Bài tham khảo từ link: http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer\\n\\nSử dụng auto\\n\\nTrong C…\",\"author\":{\"name\":\"\",\"avatar\":\"/user_avatar/daynhauhoc.com/crossover/{size}/2342_1.png\",\"username\":\"crossover\"}}\n---\n\n<p>Bài tham khảo từ link: <br><a href=\"http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer\" class=\"onebox\" target=\"_blank\">http://www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer</a></p>\n\n<p><strong>Sử dụng auto</strong></p>\n\n<p>Trong C++11 từ khóa auto được dùng để compiler có thể tự nhận diện type của dữ liệu đầu vào thông qua rvalue</p>\n\n<p>VD:</p>\n\n<pre><code>auto a = 1; // is equal with int a = 1\nauto a = 1f // is equal with float a = 1.f\nauto a = new foo(); // is equal with *a = new foo();</code></pre>\n\n<p>Có một lưu ý là khi sử dụng auto cho biến bất kì thì ta luôn phải initialize cho biến đó.<br>VD: <code>auto a; // error</code></p>\n\n<p><strong>Sử dụng nullptr</strong></p>\n\n<p>Để gán giá trị null cho con trỏ</p>\n\n<pre><code>int *p = nullptr;</code></pre>\n\n<p><strong>ForEach</strong></p>\n\n<p>Duyệt tất cả các phần tử của mảng</p>\n\n<p>VD<br></p>\n\n<p></p><pre><code class=\"lang-auto\">int arr[5] = {1, 2, 3, 4, 5};\nfor( auto &amp;a : arr)\n{\n    cout&lt;&lt; a &lt;&lt; endl; // in ra màn hình 1, 2, 3, 4, 5\n}</code></pre>\n\n<p><strong>Override và final</strong></p>\n\n<p>Cái này là một định danh.<br>Giả sử với vd sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">class B\n{\npublic:\n    virtual void f(short)\n    {\n        std::cout &lt;&lt; \"B::f\" &lt;&lt; std::endl;\n    }\n};\n\nclass D : public B\n{\npublic:\n    virtual void f(int)\n    {\n        std::cout &lt;&lt; \"D::f\" &lt;&lt; std::endl;\n    }\n};</code></pre>\n\n<p>Trường hợp này, function f ở class D là overload (vì param truyền vào là khác kiểu nhau).<br>Hoặc với vd khác:</p>\n\n<p></p><pre><code class=\"lang-auto\">class B\n{\npublic:\n    virtual void f(int) const\n    {\n        std::cout &lt;&lt; \"B::f \" &lt;&lt; std::endl;\n    }\n};\n\nclass D : public B\n{\npublic:\n    virtual void f(int)\n    {\n        std::cout &lt;&lt; \"D::f\" &lt;&lt; std::endl;\n    }\n};</code></pre>\n\n<p>Ở trường hợp này function f ở class D vẫn là overload chứ ko phải là override. Để tránh gây nhầm lẫn, C++11 thêm định danh là override và final giống như trong java. 2 từ khóa này có thể đi liền nhau \"override final\"</p>\n\n<p></p><pre><code class=\"lang-auto\">class B\n{\npublic:\n    virtual void f(short)\n    {\n        std::cout &lt;&lt; \"B::f\" &lt;&lt; std::endl;\n    }\n    void g(short)\n    {\n        std::cout &lt;&lt; \"B::g\" &lt;&lt; std::endl;\n    }\n};\n\nclass D : public B\n{\npublic:\n    virtual void f(int) override\n    {\n        std::cout &lt;&lt; \"D::f\" &lt;&lt; std::endl;\n    }\n    virtual void g(int) override\n    {\n        std::cout &lt;&lt; \"D::g\" &lt;&lt; std::endl;   // error\n    }\n};</code></pre>\n\n<p>Lưu ý: override chỉ có tác dụng nếu function ở class base là virtual.</p>\n\n<p><strong>Enum class</strong></p>\n\n<p>VD có 2 enum</p>\n\n<p></p><pre><code class=\"lang-auto\">enum TV { on, off};\nenum LAMP { on, off};</code></pre>\n\n<p>Cả 2 enum này đều có key giống nhau, dẫn đến compiler không phân biệt <br>được. Cách giải quyết ở phiên bản cũ là dùng namespace, tuy nhiên ở <br>C++11 cái này đơn giản hơn bằng cách sử dụng enum class như sau:</p>\n\n<p></p><pre><code class=\"lang-auto\">enum class TV\n{\n    on, off\n};\nenum class LAMP\n{\n    on, off\n};\n\nTV::on;\nLAMP::on; // no error</code></pre>\n\n<p><strong>Lambda</strong></p>\n\n<p>Đây là điểm mới mà C++03 không có</p>\n\n<p>Cấu trúc nó là <a> capture-list </a> { body };<br>VD:</p>\n\n<p></p><pre><code class=\"lang-auto\">int a = 10;\nauto func1 = [=]()\n{\n    int x = a;\n    std::cout&lt;&lt; x &lt;&lt; std::endl;\n    //a += 10; // error\n};\nauto func2 = [&amp;]()\n{\n    a += 10;\n};\n\nfunc1(); // x = 10;\nfunc2(); // a = 20;</code></pre>\n\n<p><code>[&amp;]</code> sẽ giúp complier hiểu được là biến a được khai báo<br>bên ngoài lambda function sẽ được tham chiếu vào trong lambda function. <br>Còn <code>[=]</code> có nghĩa là copy giá trị của a vào trong hàm lambda, tuy nhiên<br> không thể thay đổi giá trị của a. (chỉ có tác dụng copy).</p>\n","__filename":"posts/2944.md","__url":"/wiki-c-11-nhung-cai-hay-dung/","__resourceUrl":"/wiki-c-11-nhung-cai-hay-dung/index.html","__dataUrl":"/wiki-c-11-nhung-cai-hay-dung/index.html.bd12eb74d92b081e113ef14e5b518599.json"}