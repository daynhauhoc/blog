{"head":{"id":8257,"layout":"Post","route":"nghe-thuat-cua-code-de-doc-phan-1","title":"Nghệ thuật của code \"dễ đọc\" (Phần 1)","tags":["codingstyle"],"date":"2015-06-13T16:43:14.561Z","description":"Chào các bạn, hôm nọ mình có đọc được bài http&#x3A;//daynhauhoc.com/t/lam-sao-de-su-dung-bien-hieu-qua-hon-part1/6921 của anh thanhmssl10…"},"body":"<p>Chào các bạn, hôm nọ mình có đọc được bài <a href=\"http://daynhauhoc.com/t/lam-sao-de-su-dung-bien-hieu-qua-hon-part1/6921\">http://daynhauhoc.com/t/lam-sao-de-su-dung-bien-hieu-qua-hon-part1/6921</a> của anh thanhmssl10 và thấy rất hay. Tiện đây mình cũng đang đọc một quyển sách là <strong>&quot;The art of readable code&quot;</strong> và mình cũng muốn dịch nó để mọi người cùng tham khảo. Mình đang đọc được 50% thôi và áp dụng cũng chưa được nhiều nhưng sau một thời gian áp dụng những tip trong quyển sách này thì mình cũng thấy code của mình cũng phần nào dễ hiểu hơn, thời gian người khác bỏ ra để review code cũng giảm đi đáng kể. Ok bắt đầu thôi.</p>\n<h2 id=\"chng-1--code-nn-d-hiu\"><a href=\"http://daynhauhoc.com/#chng-1--code-nn-d-hiu\" class=\"statinamic-HeadingAnchor\">#</a>Chương 1 : Code nên dễ hiểu.</h2>\n<h3 id=\"phn-1--iu-g-khin-code-tr-nn-tt-hn\"><a href=\"http://daynhauhoc.com/#phn-1--iu-g-khin-code-tr-nn-tt-hn\" class=\"statinamic-HeadingAnchor\">#</a>Phần 1 : Điều gì khiến code trở nên &quot;tốt hơn&quot;.</h3>\n<p>Nhiều lập trình viên viết code theo cảm giác và trực giác. Tất cả chúng ta đều biết đoạn code như thế này:</p>\n<pre><code>for (Node* node = list-&gt;head; node != NULL; node = node-&gt;next)\n    Print(node-&gt;data);\n</code></pre>\n<p>luôn tốt hơn đoạn code như thế này:</p>\n<pre><code>Node* node = list-&gt;head;  \nif (node == NULL)  \n    return;\n\nwhile (node-&gt;next != NULL) {  \n    Print(node-&gt;data);  \n    node = node-&gt;next;  \n}\n\nif (node != NULL)  \nPrint(node-&gt;data);  \n</code></pre>\n<p>Ngay cả khi hai đoạn code trên đều làm cùng một việc và đều cho ra kết quả như nhau. Nhưng nhiều khi sẽ có những lựa chọn khó khăn hơn. Ví dụ như đoạn code sau:</p>\n<pre><code>return exponent &gt;= 0 ? mantissa * (1 &lt;&lt; exponent) : mantissa / (1 &lt;&lt; -exponent);\n</code></pre>\n<p>có thể tốt hơn hoặc tệ hơn đoạn code sau:</p>\n<pre><code>if (exponent &gt;= 0) {\n    return mantissa * (1 &lt;&lt; exponent);\n} else {\n    return mantissa / (1 &lt;&lt; -exponent);\n}\n</code></pre>\n<p>Đoạn code thứ nhất trông ngắn gọn hơn, nhưng đoạn code thứ hai trông có vẻ dễ hiểu hơn. Vậy thì code ngắn gọn hay code dễ đọc quan trọng hơn? Nói chung, bạn nên tự đặt ra câu hỏi &quot;Mình sẽ làm thế nào để viết code cho một thứ gì đó?&quot;.</p>\n<h3 id=\"phn-2--nh-l-c-bn-ca-vic-d-c\"><a href=\"http://daynhauhoc.com/#phn-2--nh-l-c-bn-ca-vic-d-c\" class=\"statinamic-HeadingAnchor\">#</a>Phần 2 : Định lý cơ bản của việc &quot;dễ đọc&quot;.</h3>\n<p>KEY IDEA của phần này là <strong>&quot;Code nên viết làm sao để giảm thiểu thời gian người khác bỏ ra để hiểu nó&quot;</strong>.</p>\n<p>Để dễ hiểu hơn cho KEY IDEA mình xin lấy một ví dụ:</p>\n<blockquote>\n<p>Bạn có một người đồng nghiệp và bạn có thể đo được khoảng thời gian người đó bỏ ra để &quot;thực sự hiểu&quot; được đoạn code của bạn có mục đích gì. Khoảng thời gian mà người đó bỏ ra chính là cái mà bạn cần thu nhỏ lại. Khi người đó thực sự hiểu thì anh ta có thể chỉnh sửa, tìm ra bug và biết cách làm thế nào để đoạn code đó tương tác với phần code còn lại.</p>\n</blockquote>\n<p>Và bây giờ có thể bạn sẽ tự đặt ra câu hỏi:</p>\n<blockquote>\n<p>Sao cần phải quan tâm có ai đó có thể hiểu được code của tôi? Tôi là người duy nhất sử dụng đoạn code đó.</p>\n</blockquote>\n<p>Ngay cả khi bạn là người duy nhất trong dự án đó, và dự án đó đáng để bạn theo đuổi. Khi <strong>&quot;người nào đó&quot;</strong> lại chính là bạn 6 tháng sau đó, khi bạn nhìn vào chính đoạn code của mình và cảm thấy nó chả có tí gì <strong>&quot;thân thiện&quot;</strong> cả. Và bạn cũng chẳng biết được có ai đó join vào dự án của bạn hay không, hoặc những đoạn code <strong>&quot;bỏ đi&quot;</strong> ấy có thể được tái sử dụng ở một dự án nào đó. Đó chính là những lý do vì sao bạn nên tìm cách làm giảm thời gian người khác bỏ ra để hiểu được đoạn code đó.</p>\n<h3 id=\"phn-3--t-hn-c-lun-l-tt-hn-hay-khng\"><a href=\"http://daynhauhoc.com/#phn-3--t-hn-c-lun-l-tt-hn-hay-khng\" class=\"statinamic-HeadingAnchor\">#</a>Phần 3 : Ít hơn có luôn là tốt hơn hay không?</h3>\n<p>Thường thì khi giải quyết một vấn đề, bạn viết càng ít code càng tốt và việc bỏ thời gian đọc 2000 dòng có thể là nhanh hơn là đọc 5000 dòng.</p>\n<p>Nhưng ít dòng hơn chưa chắc đã là tốt hơn. Ví dụ đoạn code sau</p>\n<pre><code>assert((!(bucket = FindBucket(key))) || !bucket-&gt;IsOccupied());\n</code></pre>\n<p>sẽ mất ít thời gian để hiểu hơn nếu nó được chia thành hai dòng như sau:</p>\n<pre><code>bucket = FindBucket(key);\nif (bucket != NULL) assert(!bucket-&gt;IsOccupied());\n</code></pre>\n<p>Tương tự như vậy, một dòng comment cũng có thể giúp bạn hiểu nhanh hơn</p>\n<pre><code>// Fast version of &quot;hash = (65599 * hash) + c&quot;\nhash = (hash &lt;&lt; 6) + (hash &lt;&lt; 16) - hash + c;\n</code></pre>\n<p>Do đó, giảm thiểu dòng code là một mục tiêu rất tốt nhưng giảm thiểu thời gian để đọc hiểu được chúng còn tốt hơn.</p>\n<h3 id=\"phn-4--mc-tiu-gim-thi-gian-hiu-code-c-nh-hng-g-n-cc-mc-tiu-khc-khng\"><a href=\"http://daynhauhoc.com/#phn-4--mc-tiu-gim-thi-gian-hiu-code-c-nh-hng-g-n-cc-mc-tiu-khc-khng\" class=\"statinamic-HeadingAnchor\">#</a>Phần 4 : Mục tiêu &quot;giảm thời gian hiểu code&quot; có ảnh hưởng gì đến các mục tiêu khác không?</h3>\n<p>Bạn có thể còn nhiều mục tiêu khác ngoài mục tiêu nói trên như hiệu suất tốt hơn, kiến trúc tốt hơn, test đơn giản hơn,... Nhưng các tác giả đã phát hiện ra rằng mục tiêu &quot;giảm thời gian hiểu code&quot; không ảnh hưởng nhiều đến tất cả các mục tiêu khác. Ngay cả trong mục tiêu &quot;highly optimized code&quot; thì vẫn có cách để làm cho nó vừa tốt và vừa dễ đọc. Và những đoạn code dễ hiểu thường là những đoạn code có kiến trúc tốt và đơn giản trong việc test.</p>\n<p>Ok vậy là hết phần thứ nhất của cuốn sách. Mình cũng không giỏi dịch thuật lắm nên nếu mọi người có ý kiến gì đóng góp thì cứ nói nhé mình sẽ sửa ngay khi có thể. Hẹn gặp lại ở phần sau.</p>\n","rawBody":"\nChào các bạn, hôm nọ mình có đọc được bài http://daynhauhoc.com/t/lam-sao-de-su-dung-bien-hieu-qua-hon-part1/6921 của anh thanhmssl10 và thấy rất hay. Tiện đây mình cũng đang đọc một quyển sách là **\"The art of readable code\"** và mình cũng muốn dịch nó để mọi người cùng tham khảo. Mình đang đọc được 50% thôi và áp dụng cũng chưa được nhiều nhưng sau một thời gian áp dụng những tip trong quyển sách này thì mình cũng thấy code của mình cũng phần nào dễ hiểu hơn, thời gian người khác bỏ ra để review code cũng giảm đi đáng kể. Ok bắt đầu thôi.\n\n##Chương 1 : Code nên dễ hiểu.\n\n###Phần 1 : Điều gì khiến code trở nên \"tốt hơn\".\n\nNhiều lập trình viên viết code theo cảm giác và trực giác. Tất cả chúng ta đều biết đoạn code như thế này:  \n\n    for (Node* node = list->head; node != NULL; node = node->next)\n        Print(node->data);\n\nluôn tốt hơn đoạn code như thế này:\n\n    Node* node = list->head;  \n    if (node == NULL)  \n        return;\n\n    while (node->next != NULL) {  \n        Print(node->data);  \n        node = node->next;  \n    }\n  \n    if (node != NULL)  \n    Print(node->data);  \n\nNgay cả khi hai đoạn code trên đều làm cùng một việc và đều cho ra kết quả như nhau. Nhưng nhiều khi sẽ có những lựa chọn khó khăn hơn. Ví dụ như đoạn code sau:\n\n    return exponent >= 0 ? mantissa * (1 << exponent) : mantissa / (1 << -exponent);\n\ncó thể tốt hơn hoặc tệ hơn đoạn code sau:\n\n    if (exponent >= 0) {\n        return mantissa * (1 << exponent);\n    } else {\n        return mantissa / (1 << -exponent);\n    }\n\nĐoạn code thứ nhất trông ngắn gọn hơn, nhưng đoạn code thứ hai trông có vẻ dễ hiểu hơn. Vậy thì code ngắn gọn hay code dễ đọc quan trọng hơn? Nói chung, bạn nên tự đặt ra câu hỏi \"Mình sẽ làm thế nào để viết code cho một thứ gì đó?\".\n\n###Phần 2 : Định lý cơ bản của việc \"dễ đọc\".\nKEY IDEA của phần này là **\"Code nên viết làm sao để giảm thiểu thời gian người khác bỏ ra để hiểu nó\"**.\n\nĐể dễ hiểu hơn cho KEY IDEA mình xin lấy một ví dụ:\n\n>Bạn có một người đồng nghiệp và bạn có thể đo được khoảng thời gian người đó bỏ ra để \"thực sự hiểu\" được đoạn code của bạn có mục đích gì. Khoảng thời gian mà người đó bỏ ra chính là cái mà bạn cần thu nhỏ lại. Khi người đó thực sự hiểu thì anh ta có thể chỉnh sửa, tìm ra bug và biết cách làm thế nào để đoạn code đó tương tác với phần code còn lại.\n\nVà bây giờ có thể bạn sẽ tự đặt ra câu hỏi:\n>Sao cần phải quan tâm có ai đó có thể hiểu được code của tôi? Tôi là người duy nhất sử dụng đoạn code đó.\n\nNgay cả khi bạn là người duy nhất trong dự án đó, và dự án đó đáng để bạn theo đuổi. Khi **\"người nào đó\"** lại chính là bạn 6 tháng sau đó, khi bạn nhìn vào chính đoạn code của mình và cảm thấy nó chả có tí gì **\"thân thiện\"** cả. Và bạn cũng chẳng biết được có ai đó join vào dự án của bạn hay không, hoặc những đoạn code **\"bỏ đi\"** ấy có thể được tái sử dụng ở một dự án nào đó. Đó chính là những lý do vì sao bạn nên tìm cách làm giảm thời gian người khác bỏ ra để hiểu được đoạn code đó.\n\n###Phần 3 : Ít hơn có luôn là tốt hơn hay không?\nThường thì khi giải quyết một vấn đề, bạn viết càng ít code càng tốt và việc bỏ thời gian đọc 2000 dòng có thể là nhanh hơn là đọc 5000 dòng.\n\nNhưng ít dòng hơn chưa chắc đã là tốt hơn. Ví dụ đoạn code sau\n\n    assert((!(bucket = FindBucket(key))) || !bucket->IsOccupied());\n\nsẽ mất ít thời gian để hiểu hơn nếu nó được chia thành hai dòng như sau:\n\n    bucket = FindBucket(key);\n    if (bucket != NULL) assert(!bucket->IsOccupied());\n\nTương tự như vậy, một dòng comment cũng có thể giúp bạn hiểu nhanh hơn\n\n    // Fast version of \"hash = (65599 * hash) + c\"\n    hash = (hash << 6) + (hash << 16) - hash + c;\n\nDo đó, giảm thiểu dòng code là một mục tiêu rất tốt nhưng giảm thiểu thời gian để đọc hiểu được chúng còn tốt hơn.\n\n###Phần 4 : Mục tiêu \"giảm thời gian hiểu code\" có ảnh hưởng gì đến các mục tiêu khác không?\nBạn có thể còn nhiều mục tiêu khác ngoài mục tiêu nói trên như hiệu suất tốt hơn, kiến trúc tốt hơn, test đơn giản hơn,... Nhưng các tác giả đã phát hiện ra rằng mục tiêu \"giảm thời gian hiểu code\" không ảnh hưởng nhiều đến tất cả các mục tiêu khác. Ngay cả trong mục tiêu \"highly optimized code\" thì vẫn có cách để làm cho nó vừa tốt và vừa dễ đọc. Và những đoạn code dễ hiểu thường là những đoạn code có kiến trúc tốt và đơn giản trong việc test.\n\nOk vậy là hết phần thứ nhất của cuốn sách. Mình cũng không giỏi dịch thuật lắm nên nếu mọi người có ý kiến gì đóng góp thì cứ nói nhé mình sẽ sửa ngay khi có thể. Hẹn gặp lại ở phần sau.\n","raw":"---json\n{\"id\":8257,\"layout\":\"Post\",\"route\":\"nghe-thuat-cua-code-de-doc-phan-1\",\"title\":\"Nghệ thuật của code \\\"dễ đọc\\\" (Phần 1)\",\"tags\":[\"codingstyle\"],\"date\":\"2015-06-13T16:43:14.561Z\"}\n---\n\nChào các bạn, hôm nọ mình có đọc được bài http://daynhauhoc.com/t/lam-sao-de-su-dung-bien-hieu-qua-hon-part1/6921 của anh thanhmssl10 và thấy rất hay. Tiện đây mình cũng đang đọc một quyển sách là **\"The art of readable code\"** và mình cũng muốn dịch nó để mọi người cùng tham khảo. Mình đang đọc được 50% thôi và áp dụng cũng chưa được nhiều nhưng sau một thời gian áp dụng những tip trong quyển sách này thì mình cũng thấy code của mình cũng phần nào dễ hiểu hơn, thời gian người khác bỏ ra để review code cũng giảm đi đáng kể. Ok bắt đầu thôi.\n\n##Chương 1 : Code nên dễ hiểu.\n\n###Phần 1 : Điều gì khiến code trở nên \"tốt hơn\".\n\nNhiều lập trình viên viết code theo cảm giác và trực giác. Tất cả chúng ta đều biết đoạn code như thế này:  \n\n    for (Node* node = list->head; node != NULL; node = node->next)\n        Print(node->data);\n\nluôn tốt hơn đoạn code như thế này:\n\n    Node* node = list->head;  \n    if (node == NULL)  \n        return;\n\n    while (node->next != NULL) {  \n        Print(node->data);  \n        node = node->next;  \n    }\n  \n    if (node != NULL)  \n    Print(node->data);  \n\nNgay cả khi hai đoạn code trên đều làm cùng một việc và đều cho ra kết quả như nhau. Nhưng nhiều khi sẽ có những lựa chọn khó khăn hơn. Ví dụ như đoạn code sau:\n\n    return exponent >= 0 ? mantissa * (1 << exponent) : mantissa / (1 << -exponent);\n\ncó thể tốt hơn hoặc tệ hơn đoạn code sau:\n\n    if (exponent >= 0) {\n        return mantissa * (1 << exponent);\n    } else {\n        return mantissa / (1 << -exponent);\n    }\n\nĐoạn code thứ nhất trông ngắn gọn hơn, nhưng đoạn code thứ hai trông có vẻ dễ hiểu hơn. Vậy thì code ngắn gọn hay code dễ đọc quan trọng hơn? Nói chung, bạn nên tự đặt ra câu hỏi \"Mình sẽ làm thế nào để viết code cho một thứ gì đó?\".\n\n###Phần 2 : Định lý cơ bản của việc \"dễ đọc\".\nKEY IDEA của phần này là **\"Code nên viết làm sao để giảm thiểu thời gian người khác bỏ ra để hiểu nó\"**.\n\nĐể dễ hiểu hơn cho KEY IDEA mình xin lấy một ví dụ:\n\n>Bạn có một người đồng nghiệp và bạn có thể đo được khoảng thời gian người đó bỏ ra để \"thực sự hiểu\" được đoạn code của bạn có mục đích gì. Khoảng thời gian mà người đó bỏ ra chính là cái mà bạn cần thu nhỏ lại. Khi người đó thực sự hiểu thì anh ta có thể chỉnh sửa, tìm ra bug và biết cách làm thế nào để đoạn code đó tương tác với phần code còn lại.\n\nVà bây giờ có thể bạn sẽ tự đặt ra câu hỏi:\n>Sao cần phải quan tâm có ai đó có thể hiểu được code của tôi? Tôi là người duy nhất sử dụng đoạn code đó.\n\nNgay cả khi bạn là người duy nhất trong dự án đó, và dự án đó đáng để bạn theo đuổi. Khi **\"người nào đó\"** lại chính là bạn 6 tháng sau đó, khi bạn nhìn vào chính đoạn code của mình và cảm thấy nó chả có tí gì **\"thân thiện\"** cả. Và bạn cũng chẳng biết được có ai đó join vào dự án của bạn hay không, hoặc những đoạn code **\"bỏ đi\"** ấy có thể được tái sử dụng ở một dự án nào đó. Đó chính là những lý do vì sao bạn nên tìm cách làm giảm thời gian người khác bỏ ra để hiểu được đoạn code đó.\n\n###Phần 3 : Ít hơn có luôn là tốt hơn hay không?\nThường thì khi giải quyết một vấn đề, bạn viết càng ít code càng tốt và việc bỏ thời gian đọc 2000 dòng có thể là nhanh hơn là đọc 5000 dòng.\n\nNhưng ít dòng hơn chưa chắc đã là tốt hơn. Ví dụ đoạn code sau\n\n    assert((!(bucket = FindBucket(key))) || !bucket->IsOccupied());\n\nsẽ mất ít thời gian để hiểu hơn nếu nó được chia thành hai dòng như sau:\n\n    bucket = FindBucket(key);\n    if (bucket != NULL) assert(!bucket->IsOccupied());\n\nTương tự như vậy, một dòng comment cũng có thể giúp bạn hiểu nhanh hơn\n\n    // Fast version of \"hash = (65599 * hash) + c\"\n    hash = (hash << 6) + (hash << 16) - hash + c;\n\nDo đó, giảm thiểu dòng code là một mục tiêu rất tốt nhưng giảm thiểu thời gian để đọc hiểu được chúng còn tốt hơn.\n\n###Phần 4 : Mục tiêu \"giảm thời gian hiểu code\" có ảnh hưởng gì đến các mục tiêu khác không?\nBạn có thể còn nhiều mục tiêu khác ngoài mục tiêu nói trên như hiệu suất tốt hơn, kiến trúc tốt hơn, test đơn giản hơn,... Nhưng các tác giả đã phát hiện ra rằng mục tiêu \"giảm thời gian hiểu code\" không ảnh hưởng nhiều đến tất cả các mục tiêu khác. Ngay cả trong mục tiêu \"highly optimized code\" thì vẫn có cách để làm cho nó vừa tốt và vừa dễ đọc. Và những đoạn code dễ hiểu thường là những đoạn code có kiến trúc tốt và đơn giản trong việc test.\n\nOk vậy là hết phần thứ nhất của cuốn sách. Mình cũng không giỏi dịch thuật lắm nên nếu mọi người có ý kiến gì đóng góp thì cứ nói nhé mình sẽ sửa ngay khi có thể. Hẹn gặp lại ở phần sau.\n","__filename":"posts/8257.md","__url":"/nghe-thuat-cua-code-de-doc-phan-1/","__resourceUrl":"/nghe-thuat-cua-code-de-doc-phan-1/index.html","__dataUrl":"/nghe-thuat-cua-code-de-doc-phan-1/index.html.4714acaf7418167f3a69a9501d95515f.json"}