{"head":{"id":2518,"layout":"Post","route":"hay-dung-std-vector-thay-vi-cap-phat-dong-mot-mang","title":"Hãy dùng std::vector thay vì cấp phát động một mảng","tags":["c++"],"date":"2014-12-10T07:21:19.571Z","description":"Dùng thư viện STL sẽ giúp ích rất nhiều trong việc lập trình trong C++, việc coding sẽ trở nên dễ dàng nếu bạn biết tận dụng các lớp và tính…"},"body":"<p>Dùng thư viện STL sẽ giúp ích rất nhiều trong việc lập trình trong C++, việc coding sẽ trở nên dễ dàng nếu bạn biết tận dụng các lớp và tính năng mà thư viện STL cung cấp, ở bài này mình sẽ giới thiệu cách sử dụng std::vector thay thế cho việc cấp phát động, trong trường hợp bạn không muốn tạo vùng nhớ trên stack và bạn muốn hủy vùng nhớ sau khi kết thúc hàm hoặc ra ngoài phạm vi của scope giới hạn bằng cặp ngoặc { ... }</p>\n<p><strong>Cấp phát bộ nhớ theo cách thông thường</strong></p>\n<p>Thông thường nếu bạn muốn cấp phát động một vùng nhớ để sử dụng thì bạn sẽ làm như sau:</p>\n<pre><code class=\"hljs language-c\"><span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">char</span> *dataBuffer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">char</span>[<span class=\"hljs-number\">1000</span>];\n\n<span class=\"hljs-comment\">// Do something here</span>\n\n<span class=\"hljs-keyword\">delete</span> [] dataBuffer;</code></pre>\n<p>Việc làm này có một số bất lợi sau:</p>\n<ul>\n<li>Cú pháp khá phức tạp</li>\n<li>Quên delete vùng nhớ đã cấp phát</li>\n<li>Nhầm lẫn giữa delete và delete [] có thể dẫn tới rò rỉ bộ nhớ</li>\n<li>Việc delete hai lần có thể dẫn tới lỗi không lường trước được</li>\n<li>Exception trong quá trình xử lý giữa vùng cấp phát và xóa vùng nhớ sẽ gây rò rỉ vùng nhớ</li>\n</ul>\n<p><strong>Một cách làm khác bằng cách sử dụng std::vector</strong></p>\n<p>Nhờ việc sắp sếp bộ nhớ của std::vector là liền kề nhau nên ta có thể dùng nó như một mảng các phần tử</p>\n<pre><code class=\"hljs language-c\"><span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">char</span>&gt; dataBuffer(<span class=\"hljs-number\">1000</span>);\n\n<span class=\"hljs-comment\">// Do something</span></code></pre>\n<p>Lợi thế:</p>\n<ul>\n<li>Đơn giản và gọn gàng</li>\n<li>Tự động dọn dẹp vùng nhớ sau khi sử dụng xong</li>\n<li>Exception xãy ra thì vector vẫn được hủy</li>\n<li>Tận dụng được các phương thức mà std::vector cung cấp</li>\n<li>Thư viện giải thuật của STL cung cấp nhiều giải thuật và tính năng cho std::vector như sorting, sum, for_each, ...</li>\n</ul>\n<p><strong>Truy xuất vùng nhớ của std::vector như thế nào?</strong></p>\n<ul>\n<li>\n<p>Truy xuất các phần tử trong dataBuffer: tương tự với mảng, std::vector cung cấp operator[] để truy xuất tới các phần tử VD: dataBuffer[0] = &#x27;a&#x27;;</p>\n</li>\n<li>\n<p>Truyền dataBuffer tới các hàm trong C: giả sử mình có hàm như sau proccess(unsigned char *data); thì để truyền vector dataBuffer vào hàm này mình có thể làm như sau:</p>\n</li>\n</ul>\n<pre><code class=\"hljs language-c\">process(&amp;dataBuffer[0]);\nHoặc\nprocess(&amp;dataBuffer.front());</code></pre>\n<p>Có nhiều phương thức tiện lợi trong std::vector bạn có thể tìm hiểu ở đây:</p>\n<ul>\n<li><a href=\"http://www.cplusplus.com/reference/vector/vector/\">http://www.cplusplus.com/reference/vector/vector/</a></li>\n</ul>\n","rawBody":"\nDùng thư viện STL sẽ giúp ích rất nhiều trong việc lập trình trong C++, việc coding sẽ trở nên dễ dàng nếu bạn biết tận dụng các lớp và tính năng mà thư viện STL cung cấp, ở bài này mình sẽ giới thiệu cách sử dụng std::vector thay thế cho việc cấp phát động, trong trường hợp bạn không muốn tạo vùng nhớ trên stack và bạn muốn hủy vùng nhớ sau khi kết thúc hàm hoặc ra ngoài phạm vi của scope giới hạn bằng cặp ngoặc { ... }\n\n**Cấp phát bộ nhớ theo cách thông thường**\n\nThông thường nếu bạn muốn cấp phát động một vùng nhớ để sử dụng thì bạn sẽ làm như sau:\n```c\nunsigned char *dataBuffer = new unsigned char[1000];\n\n// Do something here\n\ndelete [] dataBuffer;\n```\nViệc làm này có một số bất lợi sau:\n\n - Cú pháp khá phức tạp\n - Quên delete vùng nhớ đã cấp phát\n - Nhầm lẫn giữa delete và delete [] có thể dẫn tới rò rỉ bộ nhớ\n - Việc delete hai lần có thể dẫn tới lỗi không lường trước được\n - Exception trong quá trình xử lý giữa vùng cấp phát và xóa vùng nhớ sẽ gây rò rỉ vùng nhớ\n\n**Một cách làm khác bằng cách sử dụng std::vector**\n\nNhờ việc sắp sếp bộ nhớ của std::vector là liền kề nhau nên ta có thể dùng nó như một mảng các phần tử \n```c\nstd::vector<unsigned char> dataBuffer(1000);\n\n// Do something\n```\nLợi thế:\n\n - Đơn giản và gọn gàng\n - Tự động dọn dẹp vùng nhớ sau khi sử dụng xong\n - Exception xãy ra thì vector vẫn được hủy\n - Tận dụng được các phương thức mà std::vector cung cấp\n - Thư viện giải thuật của STL cung cấp nhiều giải thuật và tính năng cho std::vector như sorting, sum, for_each, ...\n\n**Truy xuất vùng nhớ của std::vector như thế nào?**\n\n - Truy xuất các phần tử trong dataBuffer: tương tự với mảng, std::vector cung cấp operator[] để truy xuất tới các phần tử VD: dataBuffer[0] = 'a';\n\n - Truyền dataBuffer tới các hàm trong C: giả sử mình có hàm như sau proccess(unsigned char *data); thì để truyền vector dataBuffer vào hàm này mình có thể làm như sau:\n```c\nprocess(&dataBuffer[0]);\nHoặc\nprocess(&dataBuffer.front());\n```\n\nCó nhiều phương thức tiện lợi trong std::vector bạn có thể tìm hiểu ở đây:\n\n- http://www.cplusplus.com/reference/vector/vector/\n","raw":"---json\n{\"id\":2518,\"layout\":\"Post\",\"route\":\"hay-dung-std-vector-thay-vi-cap-phat-dong-mot-mang\",\"title\":\"Hãy dùng std::vector thay vì cấp phát động một mảng\",\"tags\":[\"c++\"],\"date\":\"2014-12-10T07:21:19.571Z\"}\n---\n\nDùng thư viện STL sẽ giúp ích rất nhiều trong việc lập trình trong C++, việc coding sẽ trở nên dễ dàng nếu bạn biết tận dụng các lớp và tính năng mà thư viện STL cung cấp, ở bài này mình sẽ giới thiệu cách sử dụng std::vector thay thế cho việc cấp phát động, trong trường hợp bạn không muốn tạo vùng nhớ trên stack và bạn muốn hủy vùng nhớ sau khi kết thúc hàm hoặc ra ngoài phạm vi của scope giới hạn bằng cặp ngoặc { ... }\n\n**Cấp phát bộ nhớ theo cách thông thường**\n\nThông thường nếu bạn muốn cấp phát động một vùng nhớ để sử dụng thì bạn sẽ làm như sau:\n```c\nunsigned char *dataBuffer = new unsigned char[1000];\n\n// Do something here\n\ndelete [] dataBuffer;\n```\nViệc làm này có một số bất lợi sau:\n\n - Cú pháp khá phức tạp\n - Quên delete vùng nhớ đã cấp phát\n - Nhầm lẫn giữa delete và delete [] có thể dẫn tới rò rỉ bộ nhớ\n - Việc delete hai lần có thể dẫn tới lỗi không lường trước được\n - Exception trong quá trình xử lý giữa vùng cấp phát và xóa vùng nhớ sẽ gây rò rỉ vùng nhớ\n\n**Một cách làm khác bằng cách sử dụng std::vector**\n\nNhờ việc sắp sếp bộ nhớ của std::vector là liền kề nhau nên ta có thể dùng nó như một mảng các phần tử \n```c\nstd::vector<unsigned char> dataBuffer(1000);\n\n// Do something\n```\nLợi thế:\n\n - Đơn giản và gọn gàng\n - Tự động dọn dẹp vùng nhớ sau khi sử dụng xong\n - Exception xãy ra thì vector vẫn được hủy\n - Tận dụng được các phương thức mà std::vector cung cấp\n - Thư viện giải thuật của STL cung cấp nhiều giải thuật và tính năng cho std::vector như sorting, sum, for_each, ...\n\n**Truy xuất vùng nhớ của std::vector như thế nào?**\n\n - Truy xuất các phần tử trong dataBuffer: tương tự với mảng, std::vector cung cấp operator[] để truy xuất tới các phần tử VD: dataBuffer[0] = 'a';\n\n - Truyền dataBuffer tới các hàm trong C: giả sử mình có hàm như sau proccess(unsigned char *data); thì để truyền vector dataBuffer vào hàm này mình có thể làm như sau:\n```c\nprocess(&dataBuffer[0]);\nHoặc\nprocess(&dataBuffer.front());\n```\n\nCó nhiều phương thức tiện lợi trong std::vector bạn có thể tìm hiểu ở đây:\n\n- http://www.cplusplus.com/reference/vector/vector/\n","__filename":"posts/2518.md","__url":"/hay-dung-std-vector-thay-vi-cap-phat-dong-mot-mang/","__resourceUrl":"/hay-dung-std-vector-thay-vi-cap-phat-dong-mot-mang/index.html","__dataUrl":"/hay-dung-std-vector-thay-vi-cap-phat-dong-mot-mang/index.html.03a956e4447bb45a6d3aa1e000473825.json"}