{"head":{"layout":"Post","route":"nhung-kinh-nghiem-voi-lap-trinh-android-phan-ii","title":"Những kinh nghiệm với lập trình Android - Phần II","tags":["android"],"date":"2015-08-17T09:02:33.249Z","description":"Sử dụng thư viện Volley hoặc OkHttp thay vì tự viết một HTTP client của riêng bạn\n\nQua quá trình sử dụng, mình nhận thấy rằng để viết một…"},"body":"<h2 id=\"s-dng-th-vin-volley-hoc-okhttp-thay-v-t-vit-mt-http-client-ca-ring-bn\"><a href=\"#s-dng-th-vin-volley-hoc-okhttp-thay-v-t-vit-mt-http-client-ca-ring-bn\" class=\"statinamic-HeadingAnchor\">#</a>Sử dụng thư viện Volley hoặc OkHttp thay vì tự viết một HTTP client của riêng bạn</h2>\n<p>Qua quá trình sử dụng, mình nhận thấy rằng để viết một HTTP client đơn giản cho riêng mình, ta cần phải sử lí một loạt các thao tác sau:</p>\n<pre><code>ResponseData responseData = new ResponseData();\nString data = generalRequest.toString();\nif (!Utility.isNetworkConnected(mContext)) {\n    responseData.setStatus(Response.CLIENT_ERROR_NO_CONNECTION);\n    return responseReceiver.parseResponse(idLoader, responseData, requestType);\n}\n\nString url;\nif (Method.POST == generalRequest.getMethod()) {\n    url = Config.SERVER_URL;\n} else {\n    url = Config.IMAGE_SERVER_URL + data;\n}\n\nContentResponse outData = sendRequest(url, generalRequest.getMethod(), data, timeoutConnect, timeoutRead);\nif (outData.status == Response.CLIENT_SUCCESS) {\n    responseData.setStatus(Response.CLIENT_SUCCESS);\n    responseData.setText(outData.content);\n    if (requestType == RequestType.JSON &amp;&amp; responseData.getText() != null) {\n        try {\n            responseData.makeJSONObject();\n            int code = getResponseCode(responseData.getJSONObject());\n            if (code == Response.SERVER_BLOCKED_USER || code == Response.SERVER_USER_NOT_EXIST) {\n                sendBroadcastHasBlockAndDeactive(code);\n            }\n        } catch (JSONException e) {\n            e.printStackTrace();\n            outData.status = Response.CLIENT_ERROR_PARSE_JSON;\n            responseData.setStatus(outData.status);\n        }\n    }\n} else {\n    responseData.setStatus(outData.status);\n}\nif (responseReceiver == null)\n    return null;\n\nreturn responseReceiver.parseResponse(idLoader, responseData, requestType);\n</code></pre>\n<p>Quá nhiều dòng code cho một chức năng. Chưa kể bạn còn phải quan tâm rất nhiều thứ khác nữa để tạo ra được một thư viện http tuyệt vời cho riêng bạn. Mình đã từng nếm trái đắng, siêu đắng khi tự viết một framework liên kết với raspberry pi. Tất cả mọi chuyện kết thúc khi mình chuyển qua dùng okhttp với vài ba dòng lệnh đơn giản:</p>\n<pre><code>public static final MediaType JSON  = MediaType.parse(&quot;application/json; charset=utf-8&quot;);\n\nOkHttpClient client = new OkHttpClient();\n\nString post(String url, String json) throws IOException {\n    RequestBody body = RequestBody.create(JSON, json);\n    Request request = new Request.Builder().url(url).post(body).build();\n    Response response = client.newCall(request).execute();\n    return response.body().string();\n}\n</code></pre>\n<h2 id=\"gi-cho-file-colorsxml-ca-bn-hu-ch-hn-bng-cch-s-dng-bng-mu\"><a href=\"#gi-cho-file-colorsxml-ca-bn-hu-ch-hn-bng-cch-s-dng-bng-mu\" class=\"statinamic-HeadingAnchor\">#</a>Giữ cho file colors.xml của bạn hữu ích hơn bằng cách sử dụng bảng màu</h2>\n<p>Đây là một ví dụ về file colors.xml của mình.</p>\n<pre><code>&lt;!-- Palette --&gt;\n&lt;color name=&quot;primary&quot;&gt;#FFC0392B&lt;/color&gt;\n&lt;color name=&quot;primary_dark&quot;&gt;#FFD32F2F&lt;/color&gt;\n&lt;color name=&quot;primary_light&quot;&gt;#FFFFCDD2&lt;/color&gt;\n&lt;color name=&quot;secondary&quot;&gt;#FF449D44&lt;/color&gt;\n&lt;color name=&quot;secondary_light&quot;&gt;#FF6EC02B&lt;/color&gt;\n&lt;color name=&quot;divider&quot;&gt;#FFB6B6B6&lt;/color&gt;\n&lt;color name=&quot;divider_highlight&quot;&gt;#FFFFFFFF&lt;/color&gt;\n\n &lt;!-- Text view --&gt;\n&lt;color name=&quot;icons&quot;&gt;#FFFFFFFF&lt;/color&gt;\n&lt;color name=&quot;secondary_text&quot;&gt;#FFB0ADAD&lt;/color&gt;\n&lt;color name=&quot;secondary_text_highlight&quot;&gt;#FFDADADA&lt;/color&gt;\n&lt;color name=&quot;primary_text&quot;&gt;#FF595959&lt;/color&gt;\n&lt;color name=&quot;primary_text_highlight&quot;&gt;#FF929292&lt;/color&gt;\n</code></pre>\n<p>Theo đó thì từng màu được định nghĩa sẽ có những ý nghĩa khác nhau như sau:</p>\n<ul>\n<li><strong>primary</strong>: Màu chủ đạo của ứng dụng. Thông thường màu này sẽ nằm trên navigation bar, các text view là title của màn hình.</li>\n<li><strong>primary_dark</strong>: Ít khi được dùng nhưng thường có để làm nổi bật màu <em>primary</em></li>\n<li><strong>primary_light</strong>: Ít khi được dùng nhưng thường có để làm nổi bật màu <em>primary</em></li>\n<li><strong>secondary</strong>: Màu thứ hai được dùng nhiều trong ứng dụng. Màu này sẽ nằm ở các đoạn text được highlight hoặc những vị trí thấp hơn tone màu <em>primary</em></li>\n<li><strong>secondary_light</strong>: Ít khi được dùng nhưng thường có để làm nổi bật màu <em>secondary</em></li>\n<li><strong>divider</strong>: Dành cho các vách ngăn, đường viền của các view.</li>\n<li><strong>divider_highlight</strong>: Dành cho những cách ngăn nhạt màu hơn. Thường được dùng khi màu nền không phải là màu đơn sắc.</li>\n<li><strong>icons</strong>: Màu chủ đạo dành cho icon, chữ nằm trên nền có màu. Thông thường toàn bộ nút trong ứng dụng sẽ sử dụng màu này.</li>\n<li><strong>primary_text</strong>: Các phần chữ nội dung có tone màu chính.</li>\n<li><strong>primary_text_highlight</strong>: Nhấn mạnh màu <em>primary_text</em></li>\n<li><strong>secondary_text</strong>: Các phần chữ nội dung có tone màu yếu hơn.</li>\n<li><strong>secondary_text_highlight</strong>: Nhấn mạnh màu <em>secondary_text</em></li>\n</ul>\n<p>####Các trường hợp tuyệt đối tránh trong colors.xml</p>\n<p><strong>1.Định nghĩa màu</strong>\nLàm thế nào để bạn phân biệt được giữa màu xám, màu xám nhạt, màu xám nhạt hơn chút nữa?</p>\n<pre><code>&lt;color name=&quot;gray&quot;&gt;#FFDADADA&lt;/color&gt;\n&lt;color name=&quot;gray_light&quot;&gt;#FFDBDBDB&lt;/color&gt;\n&lt;color name=&quot;gray_more_light&quot;&gt;#FFDCDCDC&lt;/color&gt;\n</code></pre>\n<p><strong>2.Khai báo màu đã được định nghĩa trong Android</strong>\nChắc chắn là chúng ta sẽ không bao giờ định nghĩa là màu <code>transparent</code> rồi.</p>\n<h2 id=\"hy-cho-dimensxml-hc-theo-colorsxml\"><a href=\"#hy-cho-dimensxml-hc-theo-colorsxml\" class=\"statinamic-HeadingAnchor\">#</a>Hãy cho dimens.xml học theo colors.xml</h2>\n<p>Một ví dụ cho cách định nghĩa dimen:</p>\n<pre><code>&lt;!-- font sizes --&gt;\n&lt;dimen name=&quot;font_larger&quot;&gt;22sp&lt;/dimen&gt;\n&lt;dimen name=&quot;font_large&quot;&gt;18sp&lt;/dimen&gt;\n&lt;dimen name=&quot;font_normal&quot;&gt;15sp&lt;/dimen&gt;\n&lt;dimen name=&quot;font_small&quot;&gt;12sp&lt;/dimen&gt;\n\n&lt;!-- typical spacing between two views --&gt;\n&lt;dimen name=&quot;spacing_huge&quot;&gt;40dp&lt;/dimen&gt;\n&lt;dimen name=&quot;spacing_large&quot;&gt;24dp&lt;/dimen&gt;\n&lt;dimen name=&quot;spacing_normal&quot;&gt;14dp&lt;/dimen&gt;\n&lt;dimen name=&quot;spacing_small&quot;&gt;10dp&lt;/dimen&gt;\n&lt;dimen name=&quot;spacing_tiny&quot;&gt;4dp&lt;/dimen&gt;\n\n&lt;!-- typical sizes of views --&gt;\n&lt;dimen name=&quot;button_height_tall&quot;&gt;60dp&lt;/dimen&gt;\n&lt;dimen name=&quot;button_height_normal&quot;&gt;40dp&lt;/dimen&gt;\n&lt;dimen name=&quot;button_height_short&quot;&gt;32dp&lt;/dimen&gt;\n</code></pre>\n<p>Với cách định nghĩa này, bạn sẽ không cần phải định nghĩa quá nhiều những thông số dimen với nhau. Thông thường thì một view sẽ có kích thước tương quan với các view bên cạnh nó. Nhất là khi bạn phải thực hiện code trên nhiều kích thước thiết bị. Định nghĩa như thế này sẽ giúp bạn thu nhỏ hoặc phóng to các thành phần trong màn hình của bạn được dễ dàng hơn.</p>\n","rawBody":"\nSử dụng thư viện Volley hoặc OkHttp thay vì tự viết một HTTP client của riêng bạn\n---\nQua quá trình sử dụng, mình nhận thấy rằng để viết một HTTP client đơn giản cho riêng mình, ta cần phải sử lí một loạt các thao tác sau:\n```\nResponseData responseData = new ResponseData();\nString data = generalRequest.toString();\nif (!Utility.isNetworkConnected(mContext)) {\n    responseData.setStatus(Response.CLIENT_ERROR_NO_CONNECTION);\n    return responseReceiver.parseResponse(idLoader, responseData, requestType);\n}\n\nString url;\nif (Method.POST == generalRequest.getMethod()) {\n    url = Config.SERVER_URL;\n} else {\n    url = Config.IMAGE_SERVER_URL + data;\n}\n\nContentResponse outData = sendRequest(url, generalRequest.getMethod(), data, timeoutConnect, timeoutRead);\nif (outData.status == Response.CLIENT_SUCCESS) {\n    responseData.setStatus(Response.CLIENT_SUCCESS);\n    responseData.setText(outData.content);\n    if (requestType == RequestType.JSON && responseData.getText() != null) {\n        try {\n            responseData.makeJSONObject();\n            int code = getResponseCode(responseData.getJSONObject());\n            if (code == Response.SERVER_BLOCKED_USER || code == Response.SERVER_USER_NOT_EXIST) {\n                sendBroadcastHasBlockAndDeactive(code);\n            }\n        } catch (JSONException e) {\n            e.printStackTrace();\n            outData.status = Response.CLIENT_ERROR_PARSE_JSON;\n            responseData.setStatus(outData.status);\n        }\n    }\n} else {\n    responseData.setStatus(outData.status);\n}\nif (responseReceiver == null)\n    return null;\n\nreturn responseReceiver.parseResponse(idLoader, responseData, requestType);\n```\nQuá nhiều dòng code cho một chức năng. Chưa kể bạn còn phải quan tâm rất nhiều thứ khác nữa để tạo ra được một thư viện http tuyệt vời cho riêng bạn. Mình đã từng nếm trái đắng, siêu đắng khi tự viết một framework liên kết với raspberry pi. Tất cả mọi chuyện kết thúc khi mình chuyển qua dùng okhttp với vài ba dòng lệnh đơn giản:\n```\npublic static final MediaType JSON  = MediaType.parse(\"application/json; charset=utf-8\");\n\nOkHttpClient client = new OkHttpClient();\n\nString post(String url, String json) throws IOException {\n    RequestBody body = RequestBody.create(JSON, json);\n    Request request = new Request.Builder().url(url).post(body).build();\n    Response response = client.newCall(request).execute();\n    return response.body().string();\n}\n```\n\nGiữ cho file colors.xml của bạn hữu ích hơn bằng cách sử dụng bảng màu\n---\nĐây là một ví dụ về file colors.xml của mình.\n```\n<!-- Palette -->\n<color name=\"primary\">#FFC0392B</color>\n<color name=\"primary_dark\">#FFD32F2F</color>\n<color name=\"primary_light\">#FFFFCDD2</color>\n<color name=\"secondary\">#FF449D44</color>\n<color name=\"secondary_light\">#FF6EC02B</color>\n<color name=\"divider\">#FFB6B6B6</color>\n<color name=\"divider_highlight\">#FFFFFFFF</color>\n\n <!-- Text view -->\n<color name=\"icons\">#FFFFFFFF</color>\n<color name=\"secondary_text\">#FFB0ADAD</color>\n<color name=\"secondary_text_highlight\">#FFDADADA</color>\n<color name=\"primary_text\">#FF595959</color>\n<color name=\"primary_text_highlight\">#FF929292</color>\n```\nTheo đó thì từng màu được định nghĩa sẽ có những ý nghĩa khác nhau như sau:\n\n * **primary**: Màu chủ đạo của ứng dụng. Thông thường màu này sẽ nằm trên navigation bar, các text view là title của màn hình.\n* **primary_dark**: Ít khi được dùng nhưng thường có để làm nổi bật màu *primary*\n* **primary_light**: Ít khi được dùng nhưng thường có để làm nổi bật màu *primary*\n * **secondary**: Màu thứ hai được dùng nhiều trong ứng dụng. Màu này sẽ nằm ở các đoạn text được highlight hoặc những vị trí thấp hơn tone màu *primary*\n* **secondary_light**: Ít khi được dùng nhưng thường có để làm nổi bật màu *secondary*\n * **divider**: Dành cho các vách ngăn, đường viền của các view.\n* **divider_highlight**: Dành cho những cách ngăn nhạt màu hơn. Thường được dùng khi màu nền không phải là màu đơn sắc.\n * **icons**: Màu chủ đạo dành cho icon, chữ nằm trên nền có màu. Thông thường toàn bộ nút trong ứng dụng sẽ sử dụng màu này.\n * **primary_text**: Các phần chữ nội dung có tone màu chính.\n* **primary_text_highlight**: Nhấn mạnh màu *primary_text*\n * **secondary_text**: Các phần chữ nội dung có tone màu yếu hơn.\n* **secondary_text_highlight**: Nhấn mạnh màu *secondary_text*\n\n####Các trường hợp tuyệt đối tránh trong colors.xml\n\n**1.Định nghĩa màu**\nLàm thế nào để bạn phân biệt được giữa màu xám, màu xám nhạt, màu xám nhạt hơn chút nữa?\n```\n<color name=\"gray\">#FFDADADA</color>\n<color name=\"gray_light\">#FFDBDBDB</color>\n<color name=\"gray_more_light\">#FFDCDCDC</color>\n```\n**2.Khai báo màu đã được định nghĩa trong Android**\nChắc chắn là chúng ta sẽ không bao giờ định nghĩa là màu `transparent` rồi.\n\nHãy cho dimens.xml học theo colors.xml\n---\n\nMột ví dụ cho cách định nghĩa dimen:\n```\n<!-- font sizes -->\n<dimen name=\"font_larger\">22sp</dimen>\n<dimen name=\"font_large\">18sp</dimen>\n<dimen name=\"font_normal\">15sp</dimen>\n<dimen name=\"font_small\">12sp</dimen>\n\n<!-- typical spacing between two views -->\n<dimen name=\"spacing_huge\">40dp</dimen>\n<dimen name=\"spacing_large\">24dp</dimen>\n<dimen name=\"spacing_normal\">14dp</dimen>\n<dimen name=\"spacing_small\">10dp</dimen>\n<dimen name=\"spacing_tiny\">4dp</dimen>\n\n<!-- typical sizes of views -->\n<dimen name=\"button_height_tall\">60dp</dimen>\n<dimen name=\"button_height_normal\">40dp</dimen>\n<dimen name=\"button_height_short\">32dp</dimen>\n```\nVới cách định nghĩa này, bạn sẽ không cần phải định nghĩa quá nhiều những thông số dimen với nhau. Thông thường thì một view sẽ có kích thước tương quan với các view bên cạnh nó. Nhất là khi bạn phải thực hiện code trên nhiều kích thước thiết bị. Định nghĩa như thế này sẽ giúp bạn thu nhỏ hoặc phóng to các thành phần trong màn hình của bạn được dễ dàng hơn.\n","raw":"---json\n{\"layout\":\"Post\",\"route\":\"nhung-kinh-nghiem-voi-lap-trinh-android-phan-ii\",\"title\":\"Những kinh nghiệm với lập trình Android - Phần II\",\"tags\":[\"android\"],\"date\":\"2015-08-17T09:02:33.249Z\"}\n---\n\nSử dụng thư viện Volley hoặc OkHttp thay vì tự viết một HTTP client của riêng bạn\n---\nQua quá trình sử dụng, mình nhận thấy rằng để viết một HTTP client đơn giản cho riêng mình, ta cần phải sử lí một loạt các thao tác sau:\n```\nResponseData responseData = new ResponseData();\nString data = generalRequest.toString();\nif (!Utility.isNetworkConnected(mContext)) {\n    responseData.setStatus(Response.CLIENT_ERROR_NO_CONNECTION);\n    return responseReceiver.parseResponse(idLoader, responseData, requestType);\n}\n\nString url;\nif (Method.POST == generalRequest.getMethod()) {\n    url = Config.SERVER_URL;\n} else {\n    url = Config.IMAGE_SERVER_URL + data;\n}\n\nContentResponse outData = sendRequest(url, generalRequest.getMethod(), data, timeoutConnect, timeoutRead);\nif (outData.status == Response.CLIENT_SUCCESS) {\n    responseData.setStatus(Response.CLIENT_SUCCESS);\n    responseData.setText(outData.content);\n    if (requestType == RequestType.JSON && responseData.getText() != null) {\n        try {\n            responseData.makeJSONObject();\n            int code = getResponseCode(responseData.getJSONObject());\n            if (code == Response.SERVER_BLOCKED_USER || code == Response.SERVER_USER_NOT_EXIST) {\n                sendBroadcastHasBlockAndDeactive(code);\n            }\n        } catch (JSONException e) {\n            e.printStackTrace();\n            outData.status = Response.CLIENT_ERROR_PARSE_JSON;\n            responseData.setStatus(outData.status);\n        }\n    }\n} else {\n    responseData.setStatus(outData.status);\n}\nif (responseReceiver == null)\n    return null;\n\nreturn responseReceiver.parseResponse(idLoader, responseData, requestType);\n```\nQuá nhiều dòng code cho một chức năng. Chưa kể bạn còn phải quan tâm rất nhiều thứ khác nữa để tạo ra được một thư viện http tuyệt vời cho riêng bạn. Mình đã từng nếm trái đắng, siêu đắng khi tự viết một framework liên kết với raspberry pi. Tất cả mọi chuyện kết thúc khi mình chuyển qua dùng okhttp với vài ba dòng lệnh đơn giản:\n```\npublic static final MediaType JSON  = MediaType.parse(\"application/json; charset=utf-8\");\n\nOkHttpClient client = new OkHttpClient();\n\nString post(String url, String json) throws IOException {\n    RequestBody body = RequestBody.create(JSON, json);\n    Request request = new Request.Builder().url(url).post(body).build();\n    Response response = client.newCall(request).execute();\n    return response.body().string();\n}\n```\n\nGiữ cho file colors.xml của bạn hữu ích hơn bằng cách sử dụng bảng màu\n---\nĐây là một ví dụ về file colors.xml của mình.\n```\n<!-- Palette -->\n<color name=\"primary\">#FFC0392B</color>\n<color name=\"primary_dark\">#FFD32F2F</color>\n<color name=\"primary_light\">#FFFFCDD2</color>\n<color name=\"secondary\">#FF449D44</color>\n<color name=\"secondary_light\">#FF6EC02B</color>\n<color name=\"divider\">#FFB6B6B6</color>\n<color name=\"divider_highlight\">#FFFFFFFF</color>\n\n <!-- Text view -->\n<color name=\"icons\">#FFFFFFFF</color>\n<color name=\"secondary_text\">#FFB0ADAD</color>\n<color name=\"secondary_text_highlight\">#FFDADADA</color>\n<color name=\"primary_text\">#FF595959</color>\n<color name=\"primary_text_highlight\">#FF929292</color>\n```\nTheo đó thì từng màu được định nghĩa sẽ có những ý nghĩa khác nhau như sau:\n\n * **primary**: Màu chủ đạo của ứng dụng. Thông thường màu này sẽ nằm trên navigation bar, các text view là title của màn hình.\n* **primary_dark**: Ít khi được dùng nhưng thường có để làm nổi bật màu *primary*\n* **primary_light**: Ít khi được dùng nhưng thường có để làm nổi bật màu *primary*\n * **secondary**: Màu thứ hai được dùng nhiều trong ứng dụng. Màu này sẽ nằm ở các đoạn text được highlight hoặc những vị trí thấp hơn tone màu *primary*\n* **secondary_light**: Ít khi được dùng nhưng thường có để làm nổi bật màu *secondary*\n * **divider**: Dành cho các vách ngăn, đường viền của các view.\n* **divider_highlight**: Dành cho những cách ngăn nhạt màu hơn. Thường được dùng khi màu nền không phải là màu đơn sắc.\n * **icons**: Màu chủ đạo dành cho icon, chữ nằm trên nền có màu. Thông thường toàn bộ nút trong ứng dụng sẽ sử dụng màu này.\n * **primary_text**: Các phần chữ nội dung có tone màu chính.\n* **primary_text_highlight**: Nhấn mạnh màu *primary_text*\n * **secondary_text**: Các phần chữ nội dung có tone màu yếu hơn.\n* **secondary_text_highlight**: Nhấn mạnh màu *secondary_text*\n\n####Các trường hợp tuyệt đối tránh trong colors.xml\n\n**1.Định nghĩa màu**\nLàm thế nào để bạn phân biệt được giữa màu xám, màu xám nhạt, màu xám nhạt hơn chút nữa?\n```\n<color name=\"gray\">#FFDADADA</color>\n<color name=\"gray_light\">#FFDBDBDB</color>\n<color name=\"gray_more_light\">#FFDCDCDC</color>\n```\n**2.Khai báo màu đã được định nghĩa trong Android**\nChắc chắn là chúng ta sẽ không bao giờ định nghĩa là màu `transparent` rồi.\n\nHãy cho dimens.xml học theo colors.xml\n---\n\nMột ví dụ cho cách định nghĩa dimen:\n```\n<!-- font sizes -->\n<dimen name=\"font_larger\">22sp</dimen>\n<dimen name=\"font_large\">18sp</dimen>\n<dimen name=\"font_normal\">15sp</dimen>\n<dimen name=\"font_small\">12sp</dimen>\n\n<!-- typical spacing between two views -->\n<dimen name=\"spacing_huge\">40dp</dimen>\n<dimen name=\"spacing_large\">24dp</dimen>\n<dimen name=\"spacing_normal\">14dp</dimen>\n<dimen name=\"spacing_small\">10dp</dimen>\n<dimen name=\"spacing_tiny\">4dp</dimen>\n\n<!-- typical sizes of views -->\n<dimen name=\"button_height_tall\">60dp</dimen>\n<dimen name=\"button_height_normal\">40dp</dimen>\n<dimen name=\"button_height_short\">32dp</dimen>\n```\nVới cách định nghĩa này, bạn sẽ không cần phải định nghĩa quá nhiều những thông số dimen với nhau. Thông thường thì một view sẽ có kích thước tương quan với các view bên cạnh nó. Nhất là khi bạn phải thực hiện code trên nhiều kích thước thiết bị. Định nghĩa như thế này sẽ giúp bạn thu nhỏ hoặc phóng to các thành phần trong màn hình của bạn được dễ dàng hơn.\n","__filename":"11235.md","__url":"/nhung-kinh-nghiem-voi-lap-trinh-android-phan-ii/","__resourceUrl":"/nhung-kinh-nghiem-voi-lap-trinh-android-phan-ii/index.html","__dataUrl":"/nhung-kinh-nghiem-voi-lap-trinh-android-phan-ii/index.html.aa0493a7c09bc73379f9fadebc590bae.json"}