<!doctype html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><link rel="stylesheet" href="/dnh-blog/statinamic-client.8f85673b22610b6fe2de.css" /><meta data-react-helmet="true" property="og:site_name" content="Dạy nhau học Blog"/><meta data-react-helmet="true" name="twitter:site" content="@johndoe"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" property="og:title" content="Đệ quy - dịch bởi @breakdown"/><meta data-react-helmet="true" property="og:url" content="/de-quy-dich-boi-breakdown/"/><meta data-react-helmet="true" property="og:description" content="Đây là một bài viết hay được dịch bởi @breakdown. Bài viết được lấy từ sách: &quot;C Primer Plus 6th Edition&quot;

* * *

Đệ Quy (Recursion)

Hôm nay…"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:title" content="Đệ quy - dịch bởi @breakdown"/><meta data-react-helmet="true" name="twitter:creator" content="@undefined"/><meta data-react-helmet="true" name="twitter:description" content="Đây là một bài viết hay được dịch bởi @breakdown. Bài viết được lấy từ sách: &quot;C Primer Plus 6th Edition&quot;

* * *

Đệ Quy (Recursion)

Hôm nay…"/><meta data-react-helmet="true" name="description" content="Đây là một bài viết hay được dịch bởi @breakdown. Bài viết được lấy từ sách: &quot;C Primer Plus 6th Edition&quot;

* * *

Đệ Quy (Recursion)

Hôm nay…"/><title data-react-helmet="true">Đệ quy - dịch bởi @breakdown</title><link data-react-helmet="true" rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Condensed:400,400italic,700,700italic|Open+Sans:300|Roboto+Slab:400,300&amp;subset=latin,vietnamese"/><link data-react-helmet="true" rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css"/></head><body><div id="statinamic"><div data-reactroot="" data-reactid="1" data-react-checksum="617470636"><!-- react-empty: 2 --><div class="_14ntp" data-reactid="3"><div data-reactid="4"><div data-reactid="5"><!-- react-empty: 6 --><a class="DiFw-" href="/dnh-blog/" data-reactid="7">← Trang chủ</a><div class="_3ISzd" data-reactid="8"><div class="cmhKZ" data-reactid="9"><h1 data-reactid="10">Đệ quy - dịch bởi @breakdown</h1><div data-reactid="11"><p>Đây là một bài viết hay được dịch bởi @breakdown. Bài viết được lấy từ sách: &quot;C Primer Plus 6th Edition&quot;</p>
<hr>
<h2 id="-quy-recursion"><a href="#-quy-recursion" class="statinamic-HeadingAnchor">#</a>Đệ Quy (Recursion)</h2>
<p>Hôm nay chúng ta sẽ quay lại với ĐỆ QUY. Thực chất đệ quy không phức tạp như mọi người nghĩ, đệ quy cũng chỉ là một hàm nhưng hàm này đặc biệt hơn những hàm khác. Hàm đệ quy tự gọi chính nó.

Do cách thức đặc biệt này của đệ quy nên xảy ra rất nhiều vấn đề xung quanh đệ quy. Vấn đề đầu tiên mà mọi người nghĩ tới có lẽ sẽ là làm sao để hàm đệ quy này không gọi lại nó nữa. Chúng ta gọi việc này là điều kiện chấm dứt đệ quy.

Như chúng ta đã bàn bạc bên tr��n, đệ quy có tính chất cũng khá giống vòng lặp, và có thể sử dụng được ở mọi nơi mà vòng lặp có thể sử dụng. Đôi khi cách sử dụng vòng lặp rõ ràng và ngắn gọn, nhưng cách dùng đệ quy còn rõ ràng, ngắn gọn hơn rất nhiều.

Recursion Revealed -- Tính chất &quot;Đảo&quot; của đệ quy</p>
<hr>
<p>Bây giờ chúng ta hãy đi sâu và xem cách thức mà một hàm đệ quy thực thi và kết quả của hàm đệ quy.

Trong đoạn code bên dưới, chúng ta thấy được hàm main() sẽ gọi một hàm mang tên up_and_down. Trong bài này mình sẽ gọi đây là &quot;lần đầu tiên gọi hàm&quot;. Tiếp theo đó hàm up_and_down() sẽ gọi lại chính nó với tham số truyền vào là n+1, mình sẽ gọi đây là &quot;lần thứ hai gọi hàm&quot;, cứ thế tiếp tục mọi ngừoi theo cách đó nhé.<br>
Ở trong ví dụ bên dưới, hàm up_and_down() sẽ tự gọi nó 4 lần, mình gọi mỗi lần là 1 level, cứ thế mà tăng lên. Ở trong ví dụ mình có sử dụng operation &amp;, để hiểu rõ thêm chức năng của operation này, bạn có thể theo dõi ở các bài viết sau. Ở bài viết này mình chỉ nói sơ qua Operation &amp; lấy địa chỉ của biến lưu trữ trong bộ nhớ máy tính. Để sử dụng operation &amp;, trong hàm printf mình phải xuất dạng %p, nếu các bạn không thể sử dụng %p thì có thể dùng %lu hoặc %u để thay thế.

Chương trình recur.c</p>
<pre><code>/* recur.c -- */ 
#include &lt;stdio.h&gt; 
void up_and_down(int); 
int main(void) 
{ 
    up_and_down(1); 
    return 0; 
} 
void up_and_down(int n) 
{ 
    printf(&quot;Level %d: n location %p\n&quot;, n, &amp;n); // 1 
    if (n &lt; 4) 
        up_and_down(n+1); 
    printf(&quot;LEVEL %d: n location %p\n&quot;, n, &amp;n); // 2 
} 
</code></pre>
<p>Trong ví dụ trên Output sẽ như thế này:</p>
<blockquote>
<p>Level 1: n location 0x0012ff48
Level 2: n location 0x0012ff3c
Level 3: n location 0x0012ff30
Level 4: n location 0x0012ff24
LEVEL 4: n location 0x0012ff24
LEVEL 3: n location 0x0012ff30
LEVEL 2: n location 0x0012ff3c
LEVEL 1: n location 0x0012ff48</p>
</blockquote>
<p>Bây giờ chúng ta hãy bàn về cách mà đệ quy hoạt động.

Ban đầu, chúng ta xem trong hàm main() có lời gọi hàm up_and_down() với tham số truyền vào là 1 ( up_and_down(1) ). Vậy nghĩa là n trong hàm up_and_down() sẽ bằng 1.<br>
Như đã nói bên trên, mình sẽ gọi đây là Level 1, để xác nhận gọi hàm thành công, mình sẽ in ra dòng Level 1: n location 0x0012ff48 nhờ câu lệnh: <code>printf(&quot;Level %d: n location %p\n&quot;, n, &amp;n);</code>. Tiếp tới máy sẽ tiếp tục chạy câu lệnh tiếp theo là câu lệnh <code>if (n &lt; 4)</code>; Tại câu lệnh này, máy sẽ xét điều kiện n có nhỏ hơn 4 không, nếu đúng thì sẽ tiếp tục gọi hàm <code>up_and_down(n+1);</code>. Tại đây như các bạn đã thấy, hàm <code>up_and_down(n);</code> gọi <code>up_and_down(n+1);</code>. hay có thể gọi <code>up_and_down(2);</code> do <code>n = 1, n + 1 =2</code>. Lần này mình sẽ gọi đây là lần gọi hàm thứ hai (hay Level 2).

Ở Level 2, do cùng cách thức hoạt động nên hàm này sẽ thực thi giống như trên mình đã nói, và sẽ gọi tiếp hàm thứ 3, hàm thứ 4...(gọi là Level 3, Level 4). Trong đoạn code này  mình chỉ giới hạn đệ quy gọi hàm 4 lần, vậy tại Level 4 sẽ kết thúc gọi hàm (điều kiện if sai nên không còn lời gọi hàm nữa
)

Vậy là tới đây chúng ta đã giải quyết 1/2 chặn đường của Output rồi. Khi code chạy tới đây thì Output sẽ giống thế này:</p>
<blockquote>
<p>Level 1: n location 0x0012ff48
Level 2: n location 0x0012ff3c
Level 3: n location 0x0012ff30</p>
</blockquote>
<p>Level 4: n location 0x0012ff24
------ket qua chay toi day-------
LEVEL 4: n location 0x0012ff24
LEVEL 3: n location 0x0012ff30
LEVEL 2: n location 0x0012ff3c
LEVEL 1: n location 0x0012ff48<br>
Vậy tại sao trong OUTPUT của chươn trình lại còn có thêm kết quả bên dưới. Đây là vấn đề của đệ quy, khi chạy tới bên trên thì đệ quy up_and_down() vẫn chưa hết nhiệm vụ của nó. Hãy xem lại đệ quy còn 1 đoạn chương trình bên dưới nữa:</p>
<pre><code>if (n &lt; 4) 
up_and_down(n+1); 
printf(&quot;LEVEL %d: n location %p\n&quot;, n, &amp;n); // 2 
</code></pre>
<p>Chúng ta quay lại giá trị n tại Level 4. Lúc này n đang giữ giá trị là 4, vậy nghĩa là điều kiện if trong hàm up_and_down() không còn đúng nữa, vì thế chúng ta không còn lời gọi hàm nào nữa ở đây. Chúng ta đều biết chương trình là một tập các lệnh dành cho máy tính, máy tính thực thi các lệnh từ trên xuống dưới và không bỏ xót lệnh nào. Vì thế khi chạy tới Level 4 thì máy tính cũng  mới chỉ chạy xong lệnh <code>up_and_down(n+1)</code>, và lúc này vẫn còn <code>printf(&quot;LEVEL %d: n location %p\n&quot;, n, &amp;n);</code>.

Khi Level 4 không còn lời gọi hàm, thì nó còn 1 lệnh in, và máy tính sẽ thực hiện lệnh in này. Đó là nguyên nhân tại sao Level 4 lại được in 2 lần, vì trước tiên máy sẽ in <code>//1</code> và sau đó máy sẽ in <code>//2</code>. Thế là kết thúc Level 4.

Nhưng hãy tưởng tượng, khi bạn sử dụng một hàm bình thường, cái bạn cần là &quot;trả trị&quot;, đệ quy cũng thế. Level 1 gọi Level 2, chờ level 2 trả trị về, level 2 gọi level 3 chờ level 3 trả trị về, level 3 gọi level 4 chờ level 4 trả trị về... Cứ tiếp thế. Vậy nghĩa là hàm a gọi hàm b thì phải chờ hàm b thực thi xong và &quot;trả trị&quot; về và hàm a mới có thể tiếp tục thực hiện các câu lệnh tiếp theo trong hàm.

Trở về quá trình hoạt động của hàm up_and_down(), chúng ta nhớ ra rằng các level của đệ quy trước đó chỉ mới thực hiện tới <code>up_and_down(n+1)</code> và nó còn 1 dòng lệnh cuối cùng nữa <code>printf(&quot;LEVEL %d: n location %p\n&quot;, n, &amp;n);</code>. Vì thế nên khi đệ quy Level 4 thực thi xong, &quot;quyền kiểm soát&quot; sẽ được giao cho Level 3, level 3 lại thực hiện lệnh in cuối cùng và trả quyền này về level 2, level 2 trả về level 1 và level 1 trả về main() rồi kết thúc chương trình.

Lưu ý rằng mỗi level của đệ quy đều sử dụng biến private n. Thông qua địa chỉ của biến n thì ta có thể gọi n (phần này liên quan đến con trỏ pointer nên mình không đề cập ở đây). Ở mỗi hệ thống thì địa chỉ này có thể khác nhau.<br>
Ohm, Nếu cái lý giải bên trên khó hiểu với bạn, thì hãy thử tưởng tượng; Bạn cài đặt các hàm như ham1(), ham2(), ham3(), ham4() với nội dung sau đây:</p>
<pre><code>int ham1(){ ham2(); printf(&quot;hello, im in level 1!!!!\n&quot;); return 0;} 
int ham2(){ ham3(); printf(&quot;hello, im in level 2!!!!\n&quot;); return 0;} 
int ham3(){ ham4(); printf(&quot;hello, im in level 3!!!!\n&quot;); return 0;} 
int ham4(){ printf(&quot;hello, im in level 4!!!!\n&quot;);return 0;} 
 
int main(){ ham1(); return 0;} 
</code></pre>
<p>Kết quả nhận được:</p>
<blockquote>
<p>hello, im in level 4!!!!
hello, im in level 3!!!!
hello, im in level 2!!!!
hello, im in level 1!!!!</p>
</blockquote>
<p>Như chúng ta thấy cách thức của các hàm ham1-4 rất giống cách thức hoạt động của đệ quy. Đệ quy thực sự chỉ là cách viết gọn của 4 ham có cùng cách thức hoạt động thôi.<br>
Nguyên tắc cơ bản của đệ quy</p>
<hr>
<p>Chúng ta đã biết cách thức hoạt động của đê quy, nếu bạn là người mới biết sử dụng đệ quy, bạn sẽ thấy đệ quy khá là khó để sử dụng và cũng khá rắc rối để hiểu. Bây giờ mình sẽ đưa ra một vấn đề chủ chốt của đệ quy.

Đầu tiên, như đã nói bên trên, Đệ quy là hàm tự gọi nó, và nó sẽ cứ thế cho tới khi một điều kiện nào đó thỏa. Như ở ví dụ trên, khi n &gt;= 4 thì sẽ không có lời gọi hàm đệ quy nào nữa. Nhưng tại sao n lại bằng 4? Tất nhiên là do trong mỗi lần đệ quy, chúng ta tăng n lên 1 và cứ thế n sẽ là bằng 4. Như cách mình đã nói bên trên, mỗi hàm &quot;sẽ chờ&quot; hàm được gọi thực thi xong thì hàm đó mới thực thi tiếp. Vậy nghĩa là phải có &quot;một chỗ nào đó&quot; chứa biến số n. Đó là nguyên nhân tại sao biến số n lại có 4 địa chỉ khác nhau trong OUTPUT.

Bây gườ chúng ta hãy xem 4 biến số đó như thế nào.</p>
<pre><code>        variables:                |    n     n     n     n 
after level 1 call                |    1                 
after level 2 call                |    1    2         
after level 3 call                |    1    2    3     
after level 4 call                |    1    2    3    4     
 after return from level 4        |    1    2    3     
 after return from level 3        |    1    2         
 after return from level 2        |    1             
 after return from level 1        |
</code></pre>
<p>Cũng khá dễ tưởng tượng đúng không nào? Vậy tại sao 1 biến số n mà có tới 4 giá trị, máy tính lưu trữ ra sao. Mình sẽ bàn tiếp trong bài tới. Bài này chỉ để đệ quy thôi nhé.

Thứ hai, trong mỗi lần gọi hàm thì hàm được gọi sẽ trả trị (chúng ta hay gọi là return). Cứ thế thì level 4 sẽ trả trị về level 3, 3 trả về 2, 2 trả về 1, 1 trả về main(). Chúng ta không thể trả vượt cấp ngay về main() được.

Thứ ba, hàm đệ quy thực hiện theo điều kiện, điều kiện nào đến trước sẽ được thực hiện trước, điều kiện nào đến sau sẽ thực hiện sau, mình đã giải thích bên trên.<br>
Thứ tư, điều kiện được gọi sau khi gọi hàm đệ quy sẽ được thực hiện khi hàm đệ quy đó nhận được trị trả về của hàm đệ quy nó gọi. Ví dụ, điều kiện in ở #2 được thực hiện sau khi quá trình gọi hàm đệ quy kết thúc và được thực thi thông qua các lệnh: Level 4, Level 3, Level2, Level1. Chức năng này của đệ quy thực sự hữu dụng trong các chương trình phải xử lý các tiến trình liên quan đến revelsals.

Thứ năm, mặc dầu mỗi Level của đệ quy có biến của riêng nó, nhưng code thì lại được dùng chung. Code là một chuỗi các hướng dẫn cho máy tính, và lời gọi hàm đơn giản di chuyển đến điểm bắt đầu của chuỗi các hướng dẫn đó. Ngoài việc tạo ra biến riếng cho mỗi lần gọi hàm, đệ quy giống như vòng lặp. Thực tế, đôi khi đệ quy có thể được dùng thay cho vòng lặp và ngược lại.

Cuối cùng, hàm đệ quy phải có một điều kiện để ngăn chặn tiến trình gọi hàm. Thông thường các lập trình viên sử dụng if else. Để làm việc này, mỗi lần gọi đệ quy ta phải đưa vào một tham số khác với tham số trước đó (như ở trên là n và n + 1). Trong ví dụ trên các tham số được đưa vào mỗi lần gọi hàm là 1, 2, 3, 4; Bạn có thể xem lại bảng variable bên trên để hiểu rõ thêm.<br>
Đệ quy Đuôi---Tail Recursion</p>
<hr>
<p>Cách đơn giản để sử dụng một hàm đệ quy là sử dụng nó ngay return statement. Đây được gọi là đệ quy đuôi, có thể gọi là tail recursion hay end recursion. Đệ quy đuôi là một cách đơn giản và nó hoạt động khá giống vòng lặp.

Ở ví dụ dưới đây, mình sẽ làm một bài toán tính giá trị giai thừa của một số; Ví dụ 3! = 1 <em> 2 </em> 3</p>
<pre><code>// factor.c 
#include &lt;stdio.h&gt; 
long fact(int n); 
long rfact(int n); 
int main(void) 
{ 
    int num; 
    printf(&quot;This program calculates factorials.\n&quot;); 
    printf(&quot;Enter a value in the range 0-12 (q to quit):\n&quot;); 
    while (scanf(&quot;%d&quot;, &amp;num) == 1) 
    { 
        if (num &lt; 0) 
            printf(&quot;No negative numbers, please.\n&quot;); 
        else if (num &gt; 12) 
            printf(&quot;Keep input under 13.\n&quot;); 
        else 
        { 
            printf(&quot;loop: %d factorial = %ld\n&quot;, 
                    num, fact(num)); 
            printf(&quot;recursion: %d factorial = %ld\n&quot;, 
                    num, rfact(num)); 
        } 
        printf(&quot;Enter a value in the range 0-12 (q to quit):\n&quot;); 
    } 
    printf(&quot;Bye.\n&quot;); 
    return 0; 
} 
long fact(int n) 
{ 
    long ans; 
    // loop-based function 
    for (ans = 1; n &gt; 1; n--) 
        ans *= n; 
    return ans; 
} 
long rfact(int n) // recursive version 
{ 
    long ans; 
    if (n &gt; 0) 
        ans= n * rfact(n-1); 
    else 
        ans = 1; 
    return ans; 
} 
</code></pre>
<p>Chương trình này của mình chỉ giới hạn nhập số interger có giá trị giao động từ 0 tới 12. Vì giá trị của 12! lên tới nữa tỉ, giá trị này thực sự lớn hơn kiểu long của máy tính, và nếu như bạn muốn sử dụng số lớn hơn 12! thì bạn chắc phải dùng kiểu double hoặc long long.

Dưới đây là kết quả sau khi kết thúc chương trình trên:</p>
<blockquote>
<p>This program calculates factorials.
Enter a value in the range 0-12 (q to quit):
5
loop: 5 factorial = 120
recursion: 5 factorial = 120
Enter a value in the range 0-12 (q to quit):
10
loop: 10 factorial = 3628800
recursion: 10 factorial = 3628800
Enter a value in the range 0-12 (q to quit):
q
Bye.</p>
</blockquote>
<p>Ở hàm mình sử dụng vòng lặp, máu tính sẽ khởi tạo một biến tên ans = 1, sau đó nhân với các số nguyên từ 2 tới n (hoặc từ n về 2 - nói chính xác là thế). Về mặt kỹ thuật thì phải từ n về 1, nhưng số nào nhân với 1 cũng sẽ bằng chính nó, việc này trở lên vô nghĩa trong lập trình.

Bây giờ hãy xem cách mà đệ quy thực hiện. Hướng làm khi tính giai thừa của một số n! là n! = n * (n -1)!.

Hãy xem ví dụ sau:</p>
<pre><code>3!  = 3 * (3-1)! 
    = 3 * 2!
</code></pre>
<p>Ta xem</p>
<pre><code>2!  = 2 * (2 - 1)! 
    = 2 * 1! 
</code></pre>
<p>Ta có <code>1! = 1</code>

Vậy có đúng là <code>3! = 3 * 2 * 1.</code>

Quay trở lại vấn đề, ta thấy được công thức này là cách để chúng ta tiếp cận và sử dụng đệ quy trong bài toán tìm số giai thừa. Bên trên mình đã khai báo một hàm <code>rfact()</code>, chúng ta chỉ cần truyền vào 1 tham số n, vậy có nghĩa là chúng ta sẽ sử dụng hàm <code>rfact</code> thế này: <code>n * rfact(n - 1)</code>

Như các bạn thấy đấy, cả 2 cách dùng vòng lặp hoặc đệ quy đều cho ra kết quả như nhau. Nhưng nhớ rằng <code>rfact()</code> không phải là statement cuối cùng trong hàm đệ quy, nó chỉ là statement cuối cùng trong hàm if (n &gt; 0), và nó là tail recursion.

Vậy có một câu hỏi vui đặt ra là thế này: &quot;Nếu sử dụng được cả hai cách bạn sẽ sử dụng cách nào?&quot;. Thông thường, sử dụng vòng lặp là cách được khuyến khích hơn. Vậy tại sao cách này lại được khuyến khích hơn; Chúng ta cùng phân tích bên dưới.

Trở về bảng Variable bên trên, chỉ qua 4 lần gọi hàm, chúng ta cần tốn 4 ô nhớ để chứa 4 biến với 4 giá trị khác nhau. Đệ quy lưu trữ giá trị trong stack, và bộ nhớ stack là có giới hạn. Nếu 4 ô nhớ này chưa đủ thuyết phục bạn, hãy xem tiếp ví dụ mình sẽ nêu bên dưới.

Thứ hai, đệ quy có tốc độ chậm hơn, việc gọi và xử lý, lưu trữ giá trị... của hàm làm tiêu tốn rất nhiều thời gian.

Và bây giờ, bạn đang tự đặt ra câu hỏi là: &quot;Tại sao lại đưa ra ví dụ trên?&quot;. Tất nhiên là ví dụ trên là cách đơn giản nhất để giảng giải như thế nào là &quot;tail recursion&quot;.<br>
Đệ quy và Reversal</p>
<hr>
<p>Reversal, hay còn gọi là tính đảo ngược. Đây là một vấn đề khá thú vị trong đệ quy. Chúng ta hãy cùng thảo luận.

Mình đưa ra một yêu cầu thế này: &quot;Hãy viết hàm chuyển số thập phân về nhị phân&quot;. Đây là một vấn đề mà ai là lập trình viên đều biết, thực sự rất đơn giản, nhưng qua yêu cầu này chúnng ta có thể thấy được tính đảo ngược này có ích như thế nào.</p>
<pre><code>/* binary.c -- prints integer in binary form */ 
#include &lt;stdio.h&gt; 
void to_binary(unsigned long n); 
int main(void) 
{ 
    unsigned long number; 
    printf(&quot;Enter an integer (q to quit):\n&quot;); 
    while (scanf(&quot;%lu&quot;, &amp;number) == 1) 
    { 
        printf(&quot;Binary equivalent: &quot;); 
        to_binary(number); 
        putchar(&#x27;\n&#x27;); 
        printf(&quot;Enter an integer (q to quit):\n&quot;); 
    } 
    printf(&quot;Done.\n&quot;); 
    return 0; 
} 
void to_binary(unsigned long n) 
{ 
    int r; /* recursive function */ 
    r = n % 2; 
    if (n &gt;= 2) 
        to_binary(n / 2); 
    putchar(r == 0 ? &#x27;0&#x27; : &#x27;1&#x27;); 
    return; 
} 
</code></pre>
<p>Ở đây mình đã xây dựng một hàm to_binary(), ở hàm này sẽ xét r = n % 2, hàm sẽ hiển thị  một ký tự &#x27;0&#x27; nếu trị r là 0 và hiển thị &#x27;1&#x27; nếu giá trị r là 1. Biểu thức r == 0 ? &#x27;0&#x27; : &#x27;1&#x27; cung cấp phương thức này, giải nghĩa ra ta có thể hiểu rằng: xét r có bằng 0 không, nếu r = 0 thì in ra 0, nếu r !=0 thì in ra 1. Các phương thức tính toán binary thì mình không bàn tới, vì đây là cơ bản.

Bên dưới đây là kết quả sau khi chạy chương trình:</p>
<blockquote>
<p>Enter an integer (q to quit):
9
Binary equivalent: 1001
Enter an integer (q to quit):
255
Binary equivalent: 11111111
Enter an integer (q to quit):
1024
Binary equivalent: 10000000000
Enter an integer (q to quit):
q
done.</p>
</blockquote>
<p>Liệu bạn có thể sử dụng vòng lặp để tính binary? Tất nhiên là được, nhưng bạn cần phải lưu trữ từng giá trị n % 2 trong một nơi nào đó, một mảng chẳng hạn.

Tất nhiên trong hàm đệ quy có nhiều vấn đề rắc rối mình đã đề cập bên trên. Việc không quản lý được số lần gọi đệ quy sẽ làm hao tốn rất nhiều bộ nhớ và tài nguyên máy tính. Trong ví dụ này, nếu con số muốn chuyển qua binary lên tới nữa tỉ như 12! bên trên, thì gọi đệ quy thực sự là nhức đầu khi mà máy tính phải lưu trữ rất nhiều nhiều giá trị r... Và tất nhiên cách sử dụng mảng để lưu trữ cùng vòng lặp cũng nhức đầu không kém. Quan trọng bạn phải biết cách sử dụng cái nào tốt hơn.

Recursion Pros and Cons</p>
<hr>
<p>Có lẽ đệ quy không được đánh giá cao chỉ do một lý do duy nhất: Sử dụng quá nhiều tài nguyên máy tính. Tài nguyên của máy tính không phải là vô hạn, vậy nên ta phải biết tiết kiệm. Ngoài ra các thuật toán của đệ quy cũng khó giải thích và bảo trì theo thời gian.

Về vấn đề tài nguyên của máy tính mình đã nhấn mạnh ở hai ví dụ bên trên. Nếu hai ví dụ đó chưa đủ thuyết phục bạn về đệ quy sử dụng nhiều tài nguyên, thì hãy xem tiếp tục ví dụ bên dưới:

Chúng ta bắt đầu đi tính các số Fibonacci, vốn dĩ số này rất nổi tiếng vì tính thực tế của nó; Hiện trên thế giới có rất nhiều nhà thiết kế sử dụng dãy số này cho thiết kế của mình.

Một dãy Fibo bắt đầu bằng 2 số 1, các số tiếp theo sẽ là tổng của 2 số đứng trước, một đoạn ngắn đầu của fibo giống thế này: 1, 1, 2, 3, 5, 8, 13, ... Số Fibo không có giới hạn.

Ohm, mình nghĩ bạn cũng đã có lời giải đệ quy rồi. Thế mạnh của đệ quy: đệ quy hỗ trợ định nghĩa đơn giản. Nếu chúng ta đặt tên hàm là Fibonacci, Fibonacci(n) thì trả về (return) 1 nếu n = 1 hoặc n = 2, nếu không hàm sẽ trả về giá trị của tổng Fibbonacci(n-1) + Fibbonacci(n-2).</p>
<pre><code>unsigned long Fibonacci(unsigned n) 
{ 
    if (n &gt; 2) 
        return Fibonacci(n-1) + Fibonacci(n-2); 
    else
        return 1; 
} 
</code></pre>
<p>Như bạn thấy đây, Trong đệ quy này tự gọi chính nó tới 2 hàm, việc này là điểm yếu của đệ quy. Ví dụ như bạn cần tìm n = 40, đây là level 1 của đệ quy. tại Level 2 hàm này tự gọi mình 2 lần, nghĩa là cần thêm 2 vùng nhớ nữa để chứa giá trị lưu trữ; Mỗi hàm Fibbonacci(n - 1) và Fibbonacci(n - 1) lại tự gọi lại hàm nữa... Nếu là mình, mình đã thấy choáng váng ở đây vì không thể nào tính được số lần gọi hàm. Số lượng vùng nhớ này là cấp số nhân, sẽ tiếp tục tăng và tăng, tăng tới lúc vùng nhớ không còn đủ để cung cấp cho đệ quy hoạt động, và nó sẽ crash.

Đây là một ví dụ đơn giản, nhưng là ví dụ nhắc nhớ cho lập trình viên cần phải cẩn trọng trong cách sử dụng đệ quy, nếu không đúng cách thì hậu quả thực sự nghiêm trọng.

Tất nhiên đệ quy tự gọi mình 1 lần, đệ quy kép vẫn chưa đủ thuyết phục, bạn có thể tìm tới tam đệ quy hay tứ đệ quy.</p>
</div></div><div class="_3KFbD" data-reactid="12"><p class="_2kxHp" data-reactid="13"><!-- react-text: 14 -->Đăng vào <!-- /react-text --><time datetime="2015-04-09" data-reactid="15">09 tháng 4 2015</time></p><p data-reactid="16"><a href="http://daynhauhoc.com/t/5719" target="_blank" data-reactid="17"><!-- react-text: 18 -->Tham gia thảo luận bài viết tại <!-- /react-text --><strong data-reactid="19">Dạy nhau học</strong></a></p><a href="johndoe" data-reactid="20"><strong data-reactid="21">John Doe</strong><!-- react-text: 22 --> on Twitter<!-- /react-text --></a></div></div></div></div></div></div></div><script>window.__COLLECTION__ = [{"layout":"PageError","route":"404.html","description":"NOT FOUND\n\nYou just hit a route that doesn't exist... the sadness.\n","__filename":"404.md","__url":"/404.html","__resourceUrl":"/404.html","__dataUrl":"/404.html.db06c43a9ca4dd95a37a8ef55159d153.json"},{"title":"Homepage","layout":"Homepage","description":"No thing here\n","__filename":"index.md","__url":"/","__resourceUrl":"/index.html","__dataUrl":"/index.html.de865c697a43321b3d39b7dd2ca3115b.json"},{"id":11047,"layout":"Post","route":"trai-long-1-thang-hoc-tieng-anh","title":"[Trải lòng] 1 tháng học tiếng anh","tags":["english"],"date":"2015-08-14T10:36:23.027Z","description":"Vậy là gần được 1 tháng, mình theo đuổi tiếng anh và bắt đầu từ topic \"Chia sẻ phương pháp học tiếng anh của mình\", mình cảm thấy nó thật…","__filename":"posts/11047.md","__url":"/trai-long-1-thang-hoc-tieng-anh/","__resourceUrl":"/trai-long-1-thang-hoc-tieng-anh/index.html","__dataUrl":"/trai-long-1-thang-hoc-tieng-anh/index.html.73cb47271206909bdcc9dc0c4dc59c57.json"},{"id":11171,"layout":"Post","route":"chung-ta-nen-dung-viec-dich-thuat-ngu-tieng-anh-sang-tieng-viet-vi-mot-nen-giao-duc-tot-hon","title":"Chúng ta nên dừng việc dịch thuật ngữ tiếng Anh sang tiếng Việt vì một nền giáo dục tốt hơn","tags":null,"date":"2015-08-16T11:46:54.862Z","description":"Việc dịch thuật ngữ tiếng Anh sang tiếng Việt vừa tốn công, vừa không hiệu quả và tệ hơn hết là còn gây hiểu nhầm ý nghĩa của thuật ngữ. Về…","__filename":"posts/11171.md","__url":"/chung-ta-nen-dung-viec-dich-thuat-ngu-tieng-anh-sang-tieng-viet-vi-mot-nen-giao-duc-tot-hon/","__resourceUrl":"/chung-ta-nen-dung-viec-dich-thuat-ngu-tieng-anh-sang-tieng-viet-vi-mot-nen-giao-duc-tot-hon/index.html","__dataUrl":"/chung-ta-nen-dung-viec-dich-thuat-ngu-tieng-anh-sang-tieng-viet-vi-mot-nen-giao-duc-tot-hon/index.html.15e98919a5bbd580ba43a5844e56b988.json"},{"id":11040,"layout":"Post","route":"markdown-trong-daynhauhoc-com","title":"Markdown trong daynhauhoc.com","tags":["markdown"],"date":"2015-08-14T08:33:21.984Z","description":"Lời mở đầu\n\nDo quá trình sử dụng daynhauhoc nếu bạn đồng thời dùng markdown trong bài post sẽ giúp bài viết sáng ý và được chú ý hơn. Cũng…","__filename":"posts/11040.md","__url":"/markdown-trong-daynhauhoc-com/","__resourceUrl":"/markdown-trong-daynhauhoc-com/index.html","__dataUrl":"/markdown-trong-daynhauhoc-com/index.html.cdd96e34154aa97a3f069d475cf4054f.json"},{"id":1147,"layout":"Post","route":"wiki-sort-c-b-n-1-insert-sort-s-p-x-p-chen","title":"[Wiki] Sort cơ bản 1 - Insert Sort - Sắp xếp chèn","tags":["algorithm","c","wiki"],"date":"2014-11-02T09:23:53.502Z","description":"Ngồi rảnh rảnh nghiên cứu lại giải thuật đã bỏ từ lâu. Bắt đầu với Insert sort.\nhttp&#x3A;//vi.wikipedia.org/wiki/S%E1%BA%AFp_x%E1%BA%BFp_ch…","__filename":"posts/1147.md","__url":"/wiki-sort-c-b-n-1-insert-sort-s-p-x-p-chen/","__resourceUrl":"/wiki-sort-c-b-n-1-insert-sort-s-p-x-p-chen/index.html","__dataUrl":"/wiki-sort-c-b-n-1-insert-sort-s-p-x-p-chen/index.html.88246c73148a346c682d86f188341c88.json"},{"id":11235,"layout":"Post","route":"nhung-kinh-nghiem-voi-lap-trinh-android-phan-ii","title":"Những kinh nghiệm với lập trình Android - Phần II","tags":["android"],"date":"2015-08-17T09:02:33.249Z","description":"Sử dụng thư viện Volley hoặc OkHttp thay vì tự viết một HTTP client của riêng bạn\n\nQua quá trình sử dụng, mình nhận thấy rằng để viết một…","__filename":"posts/11235.md","__url":"/nhung-kinh-nghiem-voi-lap-trinh-android-phan-ii/","__resourceUrl":"/nhung-kinh-nghiem-voi-lap-trinh-android-phan-ii/index.html","__dataUrl":"/nhung-kinh-nghiem-voi-lap-trinh-android-phan-ii/index.html.d05a8ec7a32e85a4ba938ee9d16b05e8.json"},{"id":11285,"layout":"Post","route":"json-trong-android-phan-2-xuat-json-tu-database-bang-php","title":"JSon trong Android – Phần 2: Xuất JSon từ Database bằng Php","tags":["json","android"],"date":"2015-08-18T07:38:56.241Z","description":"Hôm nay tiếp tục phần 2 ra lò nhé các bạn\nJSon trong Android – Phần 2: Xuất JSon từ Database bằng Php \nhttp&#x3A;//www.nguyenvanquan7826.com…","__filename":"posts/11285.md","__url":"/json-trong-android-phan-2-xuat-json-tu-database-bang-php/","__resourceUrl":"/json-trong-android-phan-2-xuat-json-tu-database-bang-php/index.html","__dataUrl":"/json-trong-android-phan-2-xuat-json-tu-database-bang-php/index.html.0a25ae6ea6627a420e94be61ffef9f52.json"},{"id":11518,"layout":"Post","route":"maven-la-gi-su-dung-maven-trong-du-an-java","title":"Maven là gì? Sử dụng maven trong dự án java","tags":["java"],"date":"2015-08-22T13:33:03.805Z","description":"\n1. Maven là gì ?\n    Apache maven là một chương trình quản lý dự án cho phép các developers có thể quản lý về version, các dependencies (…","__filename":"posts/11518.md","__url":"/maven-la-gi-su-dung-maven-trong-du-an-java/","__resourceUrl":"/maven-la-gi-su-dung-maven-trong-du-an-java/index.html","__dataUrl":"/maven-la-gi-su-dung-maven-trong-du-an-java/index.html.0d0dde4098612ce0c2920f542e487c74.json"},{"id":14242,"layout":"Post","route":"d-t-ten-bi-n-nh-th-nao-cho-hi-u-qu-part1","title":"Đặt tên biến như thế nào cho hiệu quả (part1)","tags":["coding-style"],"date":"2015-10-09T16:12:03.117Z","description":"( Sinh nhật diễn đàn rồi, viết bài kiếm ít like đi chơi xổ số nào :smile: )\n \nBài viết này mình xin chia sẻ một vài gợi ý về việc đặt tên…","__filename":"posts/14242.md","__url":"/d-t-ten-bi-n-nh-th-nao-cho-hi-u-qu-part1/","__resourceUrl":"/d-t-ten-bi-n-nh-th-nao-cho-hi-u-qu-part1/index.html","__dataUrl":"/d-t-ten-bi-n-nh-th-nao-cho-hi-u-qu-part1/index.html.e0b21d080bbbd77cdf7e72c0cdf7c8b0.json"},{"id":11228,"layout":"Post","route":"nhung-kinh-nghiem-voi-lap-trinh-android-phan-i","title":"Những kinh nghiệm với lập trình Android - Phần I","tags":["android"],"date":"2015-08-17T07:32:43.343Z","description":"Tóm tắt\n\n[Có một vài topic như thế này][1] khiến mình rất bối rối không biết phải trả lời như thế nào cho hợp lí. Vậy nên lập thêm một topic…","__filename":"posts/11228.md","__url":"/nhung-kinh-nghiem-voi-lap-trinh-android-phan-i/","__resourceUrl":"/nhung-kinh-nghiem-voi-lap-trinh-android-phan-i/index.html","__dataUrl":"/nhung-kinh-nghiem-voi-lap-trinh-android-phan-i/index.html.0ce4861569f1b0b14805f9848e69f69c.json"},{"id":14273,"layout":"Post","route":"t-i-sao-m-t-s-ng-i-l-i-thich-xin-facebook-d-h-i-bai","title":"Tại sao một số người lại thích xin Facebook để ... hỏi bài?","tags":null,"date":"2015-10-10T07:53:44.616Z","description":"... Nhưng có thể sẽ không bao giờ hỏi hoặc khó lòng nhận được câu trả lời như mình hi vọng\n\nTại sao người hỏi có thể sẽ không bao giờ hỏi…","__filename":"posts/14273.md","__url":"/t-i-sao-m-t-s-ng-i-l-i-thich-xin-facebook-d-h-i-bai/","__resourceUrl":"/t-i-sao-m-t-s-ng-i-l-i-thich-xin-facebook-d-h-i-bai/index.html","__dataUrl":"/t-i-sao-m-t-s-ng-i-l-i-thich-xin-facebook-d-h-i-bai/index.html.2382e91489520254d4e56a0f772fb021.json"},{"id":14663,"layout":"Post","route":"t-o-va-deploy-app-tren-heroku-node-js","title":"Tạo và deploy app trên heroku (node.js)","tags":["nodejs"],"date":"2015-10-15T04:43:57.019Z","description":"Mình là newbie, từng gặp rất nhiều khó khăn khi tiếp xúc với heroku. Nay mình post bài này để các bạn chưa biết tham khảo. Các đại ca góp ý…","__filename":"posts/14663.md","__url":"/t-o-va-deploy-app-tren-heroku-node-js/","__resourceUrl":"/t-o-va-deploy-app-tren-heroku-node-js/index.html","__dataUrl":"/t-o-va-deploy-app-tren-heroku-node-js/index.html.c13324a293e79d7ce6bc4c523fcfeabe.json"},{"id":15700,"layout":"Post","route":"javascript-debounce-function-la-gi","title":"JavaScript - Debounce function là gì?","tags":["ux","javascript"],"date":"2015-11-02T18:25:24.295Z","description":"Lúc trước mình có làm một bài test yêu cầu làm một Instant Search như của Twitter. Trong quá trình làm, sẽ phát sinh một trường hợp như…","__filename":"posts/15700.md","__url":"/javascript-debounce-function-la-gi/","__resourceUrl":"/javascript-debounce-function-la-gi/index.html","__dataUrl":"/javascript-debounce-function-la-gi/index.html.2138ee6abdecd411f8ab21400a723480.json"},{"id":1537,"layout":"Post","route":"tai-lieu-lap-trinh-c-for-newbie-chuong-1-nen-tang-de-bat-dau","title":"[Tài liệu lập trình C for newbie] - Chương 1: Nền tảng để bắt đầu!","tags":["c","document"],"date":"2014-11-16T06:54:20.871Z","description":"Hi mọi người,\n\nHôm nay mình xin chia sẻ với các bạn 1 tài liệu hướng dẫn lập trình C mà mình sưu tầm được. Tài liệu này được viết bởi một…","__filename":"posts/1537.md","__url":"/tai-lieu-lap-trinh-c-for-newbie-chuong-1-nen-tang-de-bat-dau/","__resourceUrl":"/tai-lieu-lap-trinh-c-for-newbie-chuong-1-nen-tang-de-bat-dau/index.html","__dataUrl":"/tai-lieu-lap-trinh-c-for-newbie-chuong-1-nen-tang-de-bat-dau/index.html.4a6facfb6cbd3b0398d8faf436748552.json"},{"id":20049,"layout":"Post","route":"pascal-m-t-ngon-ngu-thoi-thop","title":"Pascal - Một ngôn ngữ thoi thóp","tags":["pascal"],"date":"2016-01-23T11:31:09.647Z","description":"\\*Lưu ý: Bài viết chỉ thể hiện quan điểm cá nhân và không có ý chỉ trích bất kỳ cá nhân hay tổ chức nào. Vui lòng gở bo…","__filename":"posts/20049.md","__url":"/pascal-m-t-ngon-ngu-thoi-thop/","__resourceUrl":"/pascal-m-t-ngon-ngu-thoi-thop/index.html","__dataUrl":"/pascal-m-t-ngon-ngu-thoi-thop/index.html.7d1a7387270253c5b6ce8fa493a5cb69.json"},{"id":20388,"layout":"Post","route":"d-o-java-u-no-co-th-t-day","title":"Đạo Java ư ? Nó có thật đấy","tags":["nerd","java"],"date":"2016-02-01T15:45:40.342Z","description":"Java - một điệp khúc muôn thuở, một vũ khí uy lực gắn liền với nhiều người và là niềm tự hào của James và Sun micsys qua…","__filename":"posts/20388.md","__url":"/d-o-java-u-no-co-th-t-day/","__resourceUrl":"/d-o-java-u-no-co-th-t-day/index.html","__dataUrl":"/d-o-java-u-no-co-th-t-day/index.html.69c68da390a124f56b307f3f1b3c5f8b.json"},{"id":20333,"layout":"Post","route":"10-ngon-ngu-l-p-trinh-thu-c-d-ng-kho-nhat","title":"10 Ngôn ngữ lập trình thuộc dạng... \"khó ở\" nhất","tags":null,"date":"2016-01-31T07:57:35.838Z","description":"Hệ thống xếp hạng này là do quan điểm cá nhân và thu thập ý kiến.\n\n10.Perl\n\nPerl là một ngôn ngữ lập trình do Larry Wall…","__filename":"posts/20333.md","__url":"/10-ngon-ngu-l-p-trinh-thu-c-d-ng-kho-nhat/","__resourceUrl":"/10-ngon-ngu-l-p-trinh-thu-c-d-ng-kho-nhat/index.html","__dataUrl":"/10-ngon-ngu-l-p-trinh-thu-c-d-ng-kho-nhat/index.html.ab3fddc25c228f46c091ecaecd6cb942.json"},{"id":2079,"layout":"Post","route":"wiki-mot-so-ham-toan-hoc-c","title":"[Wiki] Một số hàm toán học C++","tags":["wiki","c++"],"date":"2014-11-28T16:18:18.658Z","description":"Các hàm trong chương trinh\nUCLN2\n\nHàm này sẽ tính Ước chung lớn nhất cuả 2 số a,b\n\n* * *\n\nđây là toàn bộ code\n\n\\##Edited:\n\nMình vừa viết…","__filename":"posts/2079.md","__url":"/wiki-mot-so-ham-toan-hoc-c/","__resourceUrl":"/wiki-mot-so-ham-toan-hoc-c/index.html","__dataUrl":"/wiki-mot-so-ham-toan-hoc-c/index.html.e18d88bd881ea4aabb56da60d801c505.json"},{"id":21302,"layout":"Post","route":"doc-sach-online-giai-phap-tiet-kiem-cho-nguoi-muon-doc","title":"Đọc sách online, giải pháp tiết kiệm cho người muốn đọc","tags":null,"date":"2016-02-28T12:22:29.141Z","description":"Chú ý, lướt qua phần 1 nếu các bạn đã hiểu được việc đọc là quan trọng\n\nPhần 1: Việc đọc là quan trọng\n\nDayNhauHoc luôn khuyến khích các…","__filename":"posts/21302.md","__url":"/doc-sach-online-giai-phap-tiet-kiem-cho-nguoi-muon-doc/","__resourceUrl":"/doc-sach-online-giai-phap-tiet-kiem-cho-nguoi-muon-doc/index.html","__dataUrl":"/doc-sach-online-giai-phap-tiet-kiem-cho-nguoi-muon-doc/index.html.b8815fd76122ee824f9b36b4025c8d7d.json"},{"id":21505,"layout":"Post","route":"lau-lau-mot-quyen-sach-think-and-grow-rich-khong-chi-la-sach-lam-giau","title":"Lâu lâu một quyển sách - Think and grow rich, không chỉ là sách làm giàu","tags":["book","review"],"date":"2016-03-03T14:36:24.807Z","description":"Đạt thông thường không thích đọc sách nào có chữ \"rich\" trong đó chủ yếu là vì sợ đọc trúng sách \"lừa đảo\" vì Đạt biết làm giàu không khó…","__filename":"posts/21505.md","__url":"/lau-lau-mot-quyen-sach-think-and-grow-rich-khong-chi-la-sach-lam-giau/","__resourceUrl":"/lau-lau-mot-quyen-sach-think-and-grow-rich-khong-chi-la-sach-lam-giau/index.html","__dataUrl":"/lau-lau-mot-quyen-sach-think-and-grow-rich-khong-chi-la-sach-lam-giau/index.html.5317fc6128ab962b4d21ee0f9c9d517c.json"},{"id":2171,"layout":"Post","route":"wiki-ham-ki-m-tra-s-nguyen-t-trong-c-c","title":"[Wiki] Hàm Kiểm Tra số nguyên tố trong C/C++","tags":["wiki","c++"],"date":"2014-11-30T15:24:50.196Z","description":"Số nguyên tố:\n\nSố nguyên tố là số tự nhiên chỉ chia hết cho 1 và chính nó. Ngoài ra nó không chia hết cho bất cứ số nào khác. Số 0 và 1…","__filename":"posts/2171.md","__url":"/wiki-ham-ki-m-tra-s-nguyen-t-trong-c-c/","__resourceUrl":"/wiki-ham-ki-m-tra-s-nguyen-t-trong-c-c/index.html","__dataUrl":"/wiki-ham-ki-m-tra-s-nguyen-t-trong-c-c/index.html.9baf71bed699ba50965a027e311fd402.json"},{"id":2162,"layout":"Post","route":"wiki-sort-co-ban-3-quick-sort-sap-xep-nhanh","title":"[Wiki] Sort cơ bản 3 - Quick Sort - Sắp xếp nhanh","tags":["wiki","algorithm","c++"],"date":"2014-11-30T06:40:14.346Z","description":"http&#x3A;//vi.wikipedia.org/wiki/S%E1%BA%AFp_x%E1%BA%BFp_nhanh\n\nXem video về Quick Sort ở đây\n\nhttps&#x3A;//www.youtube.com/watch?v=COk…","__filename":"posts/2162.md","__url":"/wiki-sort-co-ban-3-quick-sort-sap-xep-nhanh/","__resourceUrl":"/wiki-sort-co-ban-3-quick-sort-sap-xep-nhanh/index.html","__dataUrl":"/wiki-sort-co-ban-3-quick-sort-sap-xep-nhanh/index.html.469abf391336fa03ca987117c0cda6d4.json"},{"id":22117,"layout":"Post","route":"fastest-way-to-learn-basic-of-programming-p1","title":"Fastest way to learn basic of Programming [P1]","tags":["basic"],"date":"2016-03-14T12:05:39.933Z","description":"Xin chào cả nhà. Căn bản lập trình là thứ bắt đầu đầy nước mắt của lập trình viên :joy:, và một khi bạn đã \"qua cơn nguy kịch\" thì bạn sẽ…","__filename":"posts/22117.md","__url":"/fastest-way-to-learn-basic-of-programming-p1/","__resourceUrl":"/fastest-way-to-learn-basic-of-programming-p1/index.html","__dataUrl":"/fastest-way-to-learn-basic-of-programming-p1/index.html.ad8f707927d82c64f82536838e92f91e.json"},{"id":2193,"layout":"Post","route":"wiki-toan-tu-trong-c","title":"[Wiki] Toán tử trong C++","tags":["wiki","c++"],"date":"2014-12-01T03:21:00.773Z","description":"Toán tử - Operators /'ɔpəreitə/\nOnce introduced to variables and constants, we can begin to operate with them by using operators. //đoạn này…","__filename":"posts/2193.md","__url":"/wiki-toan-tu-trong-c/","__resourceUrl":"/wiki-toan-tu-trong-c/index.html","__dataUrl":"/wiki-toan-tu-trong-c/index.html.0d41868a8ff93aac72ba1e7e0c889dce.json"},{"id":22056,"layout":"Post","route":"lau-lau-mot-quyen-sach-toi-di-hoc-cua-nha-giao-uu-tu-nguyen-ngoc-ky","title":"Lâu lâu một quyển sách - Tôi đi học của nhà giáo Ưu Tú Nguyễn Ngọc Ký","tags":["review","book"],"date":"2016-03-13T07:34:32.411Z","description":"Đạt nghe về quyển Tôi Đi Học đã lâu, nhưng giờ mới có dịp đọc.\n\n\n\nĐang tính đọc xong sẽ review, nhưng quyển này ngắn chắc là sẽ xong trong…","__filename":"posts/22056.md","__url":"/lau-lau-mot-quyen-sach-toi-di-hoc-cua-nha-giao-uu-tu-nguyen-ngoc-ky/","__resourceUrl":"/lau-lau-mot-quyen-sach-toi-di-hoc-cua-nha-giao-uu-tu-nguyen-ngoc-ky/index.html","__dataUrl":"/lau-lau-mot-quyen-sach-toi-di-hoc-cua-nha-giao-uu-tu-nguyen-ngoc-ky/index.html.a4acabb6da64bc747679407f671df55b.json"},{"id":22178,"layout":"Post","route":"fastest-way-to-learn-basic-of-programming-p2","title":"Fastest way to learn basic of Programming [P2]","tags":["basic"],"date":"2016-03-15T10:42:50.131Z","description":"Chào cả nhà, sau khi làm xong Part 1 của Fastest way to learn basic of Programming, em thấy có rất nhiều bạn newbie và cả không newbie đánh…","__filename":"posts/22178.md","__url":"/fastest-way-to-learn-basic-of-programming-p2/","__resourceUrl":"/fastest-way-to-learn-basic-of-programming-p2/index.html","__dataUrl":"/fastest-way-to-learn-basic-of-programming-p2/index.html.e4d64579f69a1dfb3dbc77bc66b7f7fe.json"},{"id":22191,"layout":"Post","route":"lau-lau-mot-cuon-sach-nha-gia-kim-cua-paulo-coelho-triet-li-tam-niem-phuong-cham-song","title":"[Lâu lâu một cuốn sách] Nhà giả kim của Paulo Coelho - triết lí, tâm niệm, phương châm sống","tags":["review","book"],"date":"2016-03-15T13:47:31.099Z","description":"Chào các bạn, thấy anh đạt review sách cũng hay hay nên mình cũng thử xem sao. \n\nGiới thiệu sờ sơ\n\nQuyển sách hôm nay mình giới thiệu là Nhà…","__filename":"posts/22191.md","__url":"/lau-lau-mot-cuon-sach-nha-gia-kim-cua-paulo-coelho-triet-li-tam-niem-phuong-cham-song/","__resourceUrl":"/lau-lau-mot-cuon-sach-nha-gia-kim-cua-paulo-coelho-triet-li-tam-niem-phuong-cham-song/index.html","__dataUrl":"/lau-lau-mot-cuon-sach-nha-gia-kim-cua-paulo-coelho-triet-li-tam-niem-phuong-cham-song/index.html.848319361d25fe7105467a3c44a8950a.json"},{"id":22231,"layout":"Post","route":"fastest-way-to-learn-basic-of-oop-p3","title":"Fastest way to learn basic of OOP [P3]","tags":["oop","basic"],"date":"2016-03-16T06:11:25.322Z","description":"Chào cả nhà, trưa không ngủ được nên ngồi viết bài luôn ^^.\nQua 2 phần của Fastest way to learn basic of Programming thì các…","__filename":"posts/22231.md","__url":"/fastest-way-to-learn-basic-of-oop-p3/","__resourceUrl":"/fastest-way-to-learn-basic-of-oop-p3/index.html","__dataUrl":"/fastest-way-to-learn-basic-of-oop-p3/index.html.9188e52bb9be3b673097ff1d546f0d27.json"},{"id":22938,"layout":"Post","route":"doi-pho-voi-cau-hoi-phong-van-truoc-day-ban-lam-gi","title":"Đối phó với câu hỏi phỏng vấn: Trước đây bạn làm gì?","tags":["kinh-nghiem"],"date":"2016-03-27T10:29:04.715Z","description":"Công việc và kinh nghiệm làm việc trong quá khứ không chỉ là cơ sở để nhà tuyển dụng biết bạn có phù hợp với vị trí ứng tuyển hay không, mà…","__filename":"posts/22938.md","__url":"/doi-pho-voi-cau-hoi-phong-van-truoc-day-ban-lam-gi/","__resourceUrl":"/doi-pho-voi-cau-hoi-phong-van-truoc-day-ban-lam-gi/index.html","__dataUrl":"/doi-pho-voi-cau-hoi-phong-van-truoc-day-ban-lam-gi/index.html.5a98f96f464c4509e5701c33e0aa3633.json"},{"id":22951,"layout":"Post","route":"lau-lau-mot-quyen-sach-doc-dac-nhan-tam-de-internet-khong-bi-huy-diet-boi-11-dong-code","title":"Lâu Lâu Một Quyển Sách: Đọc Đắc Nhân Tâm Để Internet không bị hủy diệt bởi 11 dòng code","tags":["book","review"],"date":"2016-03-27T13:49:58.161Z","description":"Đắc nhân tâm là một quyển sách mà Đạt nghe về nó cách đây 6 năm, lúc mới nghe tới sách này Đạt nghĩ đây là một quyển sách dành cho người già…","__filename":"posts/22951.md","__url":"/lau-lau-mot-quyen-sach-doc-dac-nhan-tam-de-internet-khong-bi-huy-diet-boi-11-dong-code/","__resourceUrl":"/lau-lau-mot-quyen-sach-doc-dac-nhan-tam-de-internet-khong-bi-huy-diet-boi-11-dong-code/index.html","__dataUrl":"/lau-lau-mot-quyen-sach-doc-dac-nhan-tam-de-internet-khong-bi-huy-diet-boi-11-dong-code/index.html.3f4fad6cccfe36cd371315fef7591252.json"},{"id":22819,"layout":"Post","route":"dat-nuoc-cua-nhung-ke-luoi-bieng","title":"Đất Nước của những kẻ Lười Biếng","tags":null,"date":"2016-03-26T02:09:03.125Z","description":"Đây là một bài viết tôi sưu tầm được, nhưng tôi phải nói trước với bạn là ngôn từ của nó không hề ngọt tai, nếu bạn chưa sẵn sàng nhìn nhận…","__filename":"posts/22819.md","__url":"/dat-nuoc-cua-nhung-ke-luoi-bieng/","__resourceUrl":"/dat-nuoc-cua-nhung-ke-luoi-bieng/index.html","__dataUrl":"/dat-nuoc-cua-nhung-ke-luoi-bieng/index.html.aa8aa23941c4096a28461b38a9ab87d4.json"},{"id":23407,"layout":"Post","route":"ky-nang-song-neu-cac-ban-that-su-muon-thay-doi-suy-nghi-va-cach-song-tieu-cuc-cua-minh-thi-nen-doc-chi-can-bo-ra-9-phut-doc-va-1-phut-ngam-thoi","title":"Kỹ năng sống.Nếu các bạn thật sự muốn thay đổi suy nghĩ và cách sống tiêu cực của mình thì nên đọc(chỉ cần bỏ ra 9 phút đọc và 1 phút ngẫm thôi)","tags":["kỹnăngsống"],"date":"2016-04-01T10:36:13.066Z","description":"Vào mỗi chiếu thứ 6 hàng tuần khoảng 5:30 PM mình sẽ post 1 chủ đề về kỹ năng sống và những suy nghĩ của giới trẻ hiện nay.Mình chỉ là 1 con…","__filename":"posts/23407.md","__url":"/ky-nang-song-neu-cac-ban-that-su-muon-thay-doi-suy-nghi-va-cach-song-tieu-cuc-cua-minh-thi-nen-doc-chi-can-bo-ra-9-phut-doc-va-1-phut-ngam-thoi/","__resourceUrl":"/ky-nang-song-neu-cac-ban-that-su-muon-thay-doi-suy-nghi-va-cach-song-tieu-cuc-cua-minh-thi-nen-doc-chi-can-bo-ra-9-phut-doc-va-1-phut-ngam-thoi/index.html","__dataUrl":"/ky-nang-song-neu-cac-ban-that-su-muon-thay-doi-suy-nghi-va-cach-song-tieu-cuc-cua-minh-thi-nen-doc-chi-can-bo-ra-9-phut-doc-va-1-phut-ngam-thoi/index.html.b55923fc1e9a285d8eba3bca66298613.json"},{"id":2944,"layout":"Post","route":"wiki-c-11-nhung-cai-hay-dung","title":"[Wiki] C++11 những cái hay dùng","tags":["wiki","c","c++"],"date":"2014-12-23T11:03:55.579Z","description":"Bài tham khảo từ link: \nhttp&#x3A;//www.codeproject.com/Articles/570638/Ten-Cplusplus-Features-Every-Cplusplus-Developer\n\nSử dụng auto…","__filename":"posts/2944.md","__url":"/wiki-c-11-nhung-cai-hay-dung/","__resourceUrl":"/wiki-c-11-nhung-cai-hay-dung/index.html","__dataUrl":"/wiki-c-11-nhung-cai-hay-dung/index.html.782380479748ba80a16ad48f2429f00e.json"},{"id":2424,"layout":"Post","route":"thu-thuat-hay-tich-hop-visual-studio-vao-notepad-compile-run-with-visual-studio","title":"[Thủ thuật hay] - Tích hợp Visual studio vào notepad++ (compile & run with Visual studio)","tags":null,"date":"2014-12-06T03:06:48.938Z","description":"Có bao giờ bạn tự hỏi: sao trong notepad++ thấy có mấy cái menu \"run\" gì gì đó mà lại không chạy được C/C++ code? Vì bạn chưa tích hợp một…","__filename":"posts/2424.md","__url":"/thu-thuat-hay-tich-hop-visual-studio-vao-notepad-compile-run-with-visual-studio/","__resourceUrl":"/thu-thuat-hay-tich-hop-visual-studio-vao-notepad-compile-run-with-visual-studio/index.html","__dataUrl":"/thu-thuat-hay-tich-hop-visual-studio-vao-notepad-compile-run-with-visual-studio/index.html.ca0ae803fc03a4d46ad69a8c9303c0b5.json"},{"id":30,"layout":"Post","route":"http-imgur-com-cong-cu-chia-se-anh-tuyet-voi","title":"Http://imgur.com Công cụ chia sẻ ảnh tuyệt vời","tags":["tutorial"],"date":"2014-10-13T10:40:28.747Z","description":"Bạn cần share 1 tầm hình lên internet, bạn sẽ gặp các vấn đề sau...\n\nphải tìm một host up ảnh free\n\nupload hình quá lâu\n\nđăng ký quá phức…","__filename":"posts/30.md","__url":"/http-imgur-com-cong-cu-chia-se-anh-tuyet-voi/","__resourceUrl":"/http-imgur-com-cong-cu-chia-se-anh-tuyet-voi/index.html","__dataUrl":"/http-imgur-com-cong-cu-chia-se-anh-tuyet-voi/index.html.259d324a9e3be60b010a04505f9e2bce.json"},{"id":3032,"layout":"Post","route":"wiki-cach-ghi-file-trong-c","title":"[Wiki] Cách ghi file trong C++","tags":["wiki","c++"],"date":"2014-12-26T09:55:37.003Z","description":"Cách ghi file cực kỳ đơn giản trong C++.\n\nĐể khi nội dung vào file nằm chung thư mục với code, ta làm như sau:\n\nĐể ghi một file có đường dẫn…","__filename":"posts/3032.md","__url":"/wiki-cach-ghi-file-trong-c/","__resourceUrl":"/wiki-cach-ghi-file-trong-c/index.html","__dataUrl":"/wiki-cach-ghi-file-trong-c/index.html.3621b5ff98c8ec16b906caa5e0f83593.json"},{"id":3391,"layout":"Post","route":"tong-hop-doc-file-bang-c-va-c","title":"Tổng hợp: đọc file bằng C++ và C","tags":["tutorial","c++","c"],"date":"2015-01-17T18:12:36.112Z","description":"Mình tìm thấy nhiều cách đọc file bằng C++ vào std::string khác nhau, post tạm 1 cách đã, có thời gian post dần thêm.\n\nCách đầu tiên là đọc…","__filename":"posts/3391.md","__url":"/tong-hop-doc-file-bang-c-va-c/","__resourceUrl":"/tong-hop-doc-file-bang-c-va-c/index.html","__dataUrl":"/tong-hop-doc-file-bang-c-va-c/index.html.464ff8c3329ba259e7255e4a2fe5ba82.json"},{"id":3698,"layout":"Post","route":"cach-dat-muc-tieu-smart-theo-5-nguyen-tac","title":"Cách đặt mục tiêu SMART theo 5 nguyên tắc","tags":null,"date":"2015-02-03T07:55:03.449Z","description":"\n\nTại sao mình viết bài này ? Vì mình thấy có nhiều bạn có mục tiêu, nhưng chưa biết cách đặt mục tiêu sao cho hiểu quả.\nBài viết nay có…","__filename":"posts/3698.md","__url":"/cach-dat-muc-tieu-smart-theo-5-nguyen-tac/","__resourceUrl":"/cach-dat-muc-tieu-smart-theo-5-nguyen-tac/index.html","__dataUrl":"/cach-dat-muc-tieu-smart-theo-5-nguyen-tac/index.html.f37e7f1bab263aaaad7be73a25970a2f.json"},{"id":3564,"layout":"Post","route":"github-va-cach-su-dung-co-ban-github-tren-windows","title":"Github Và Cách Sử Dụng Cơ Bản Github Trên Windows","tags":["github"],"date":"2015-01-27T10:33:04.615Z","description":"Bài viết được đăng tại đây: http&#x3A;//portal.daynhauhoc.com/p/huong-dan-dung-github-tren-windows-co-ban/\n\nĐã có khá nhiều bài hướng dẫn sử…","__filename":"posts/3564.md","__url":"/github-va-cach-su-dung-co-ban-github-tren-windows/","__resourceUrl":"/github-va-cach-su-dung-co-ban-github-tren-windows/index.html","__dataUrl":"/github-va-cach-su-dung-co-ban-github-tren-windows/index.html.6d4171209441ca4462d8dfd9e3f378de.json"},{"id":522,"layout":"Post","route":"dropbox-va-cac-dich-vu-luu-tru-file-khac","title":"Dropbox và các dịch vụ lưu trữ file khác","tags":null,"date":"2014-10-16T16:52:01.105Z","description":"Cũ nhưng có thể nhiều người chưa biết. Ai chưa biết và chưa đăng ký Dropbox thì đăng ký theo link dưới để sử dụng Dropbox. Đăng ký là bạn…","__filename":"posts/522.md","__url":"/dropbox-va-cac-dich-vu-luu-tru-file-khac/","__resourceUrl":"/dropbox-va-cac-dich-vu-luu-tru-file-khac/index.html","__dataUrl":"/dropbox-va-cac-dich-vu-luu-tru-file-khac/index.html.7f44a6f6ceb1c2754c0d1a31082d5da7.json"},{"id":4584,"layout":"Post","route":"b-n-dung-trinh-so-n-th-o-nao-d-h-c-va-lam-vi-c-v-i-python","title":"Bạn dùng trình soạn thảo nào để học và làm việc với Python?","tags":["python"],"date":"2015-03-07T06:52:34.395Z","description":"Bài viết được post tại: http&#x3A;//portal.daynhauhoc.com/p/ban-dung-trinh-soan-thao-nao-de-hoc-va-lam-viec-voi-python/\n\nBạn dùng trình soạn…","__filename":"posts/4584.md","__url":"/b-n-dung-trinh-so-n-th-o-nao-d-h-c-va-lam-vi-c-v-i-python/","__resourceUrl":"/b-n-dung-trinh-so-n-th-o-nao-d-h-c-va-lam-vi-c-v-i-python/index.html","__dataUrl":"/b-n-dung-trinh-so-n-th-o-nao-d-h-c-va-lam-vi-c-v-i-python/index.html.7c8b8714a82b369914578c4aafd24b08.json"},{"id":5924,"layout":"Post","route":"huong-dan-su-dung-github-tren-windows-voi-tortoisegit-ui","title":"Hướng dẫn sử dụng github trên windows với TortoiseGit UI","tags":["github"],"date":"2015-04-14T10:50:22.313Z","description":"Các bước cài đặt\n\nStep 1. Download & install TortoiseGit https&#x3A;//code.google.com/p/tortoisegit/wiki/Download . NEXT > Next and next…","__filename":"posts/5924.md","__url":"/huong-dan-su-dung-github-tren-windows-voi-tortoisegit-ui/","__resourceUrl":"/huong-dan-su-dung-github-tren-windows-voi-tortoisegit-ui/index.html","__dataUrl":"/huong-dan-su-dung-github-tren-windows-voi-tortoisegit-ui/index.html.df6a28bbf3eac98d44734014abf62fe3.json"},{"id":6297,"layout":"Post","route":"thiet-lap-phim-tat-shutter-tren-ubuntu-lam-mac-dinh","title":"Thiết lập phím tắt Shutter trên Ubuntu làm mặc định","tags":["ubuntu","linux","howto"],"date":"2015-04-22T08:24:03.069Z","description":"Ở  Ubuntu, khi ta bấm PrtSc, hay Ctrl+PrtSc mặc định Ubuntu sẽ gọi phần mền ScreenShot để chụp ảnh màn hình, trong bài này mình sẽ hướng dẫn…","__filename":"posts/6297.md","__url":"/thiet-lap-phim-tat-shutter-tren-ubuntu-lam-mac-dinh/","__resourceUrl":"/thiet-lap-phim-tat-shutter-tren-ubuntu-lam-mac-dinh/index.html","__dataUrl":"/thiet-lap-phim-tat-shutter-tren-ubuntu-lam-mac-dinh/index.html.142e39f70ed4aac6c0b3d366efe0be6f.json"},{"id":6511,"layout":"Post","route":"thuat-toan-nho-tim-boi-chung-nho-nhat-cua-3-so-bat-ky","title":"[Thuật toán nhỏ] Tìm bội chung nhỏ nhất của 3 số bất kỳ","tags":["algorithm","cpp","python","php"],"date":"2015-04-25T15:40:11.523Z","description":"Yêu cầu\n\nInput: nhập 3 số nguyên: a, b, c\n\nOutput: BCNN(a, b, c)\n\nKhái niệm\n\nBội chung nhỏ nhất của các số nhất kỳ là số nhỏ nhất có thể…","__filename":"posts/6511.md","__url":"/thuat-toan-nho-tim-boi-chung-nho-nhat-cua-3-so-bat-ky/","__resourceUrl":"/thuat-toan-nho-tim-boi-chung-nho-nhat-cua-3-so-bat-ky/index.html","__dataUrl":"/thuat-toan-nho-tim-boi-chung-nho-nhat-cua-3-so-bat-ky/index.html.fd7bdee4883ce7978a03292d8d79313b.json"},{"id":6078,"layout":"Post","route":"tuts-genymotion-emulator-for-android-studio","title":"[Tuts] - Genymotion Emulator for Android Studio","tags":["android","tutorial"],"date":"2015-04-17T08:18:53.764Z","description":"Tích hợp emulator của Genymotion vào Android Studio.\nBạn mới chuyển sang Android Studio vì nghe nói Eclipse hết thời? :joy: Nhưng cấu hình…","__filename":"posts/6078.md","__url":"/tuts-genymotion-emulator-for-android-studio/","__resourceUrl":"/tuts-genymotion-emulator-for-android-studio/index.html","__dataUrl":"/tuts-genymotion-emulator-for-android-studio/index.html.189dbc63ec56d4bdf593b9799439c40c.json"},{"id":6526,"layout":"Post","route":"huong-dan-dung-github-tren-windows-co-ban-step-by-step","title":"Hướng dẫn dùng Github trên Windows cơ bản (step by step)","tags":["github"],"date":"2015-04-26T07:36:13.728Z","description":"\\#Hướng dẫn dùng Github cơ bản theo phong cách \"mì ăn liền\" \n\nĐã có khá nhiều bài hướng dẫn sử dụng Github rồi nhưng mình vẫn muốn viết bài…","__filename":"posts/6526.md","__url":"/huong-dan-dung-github-tren-windows-co-ban-step-by-step/","__resourceUrl":"/huong-dan-dung-github-tren-windows-co-ban-step-by-step/index.html","__dataUrl":"/huong-dan-dung-github-tren-windows-co-ban-step-by-step/index.html.3e4236a89007da1e3cfd5e9924b31223.json"},{"id":6625,"layout":"Post","route":"sublime-text-3-tren-ca-tuyet-voi","title":"Sublime Text 3 ! Trên cả tuyệt vời","tags":["ide"],"date":"2015-04-28T04:46:44.173Z","description":"Bài viết được post tại: http&#x3A;//portal.daynhauhoc.com/p/sublime-text-3-tren-ca-tuyet-voi/\n\nSublime Text là một phần mền soạn thảo code…","__filename":"posts/6625.md","__url":"/sublime-text-3-tren-ca-tuyet-voi/","__resourceUrl":"/sublime-text-3-tren-ca-tuyet-voi/index.html","__dataUrl":"/sublime-text-3-tren-ca-tuyet-voi/index.html.c7b42d6969e5e70f546850c7a43fc13b.json"},{"id":6728,"layout":"Post","route":"phan-tich-thuat-toan-tiem-can-asymptotic-notation","title":"[Phân tích thuật toán] Tiệm cận (Asymptotic notation)","tags":["algorithm"],"date":"2015-04-30T15:36:15.457Z","description":"Ở bài này, mình sẽ nói về độ phức tạp của một thuật toán. Do mình cũng mới nghiên cứu để viết bài này nên chưa thể hiểu rõ được, nhưng mình…","__filename":"posts/6728.md","__url":"/phan-tich-thuat-toan-tiem-can-asymptotic-notation/","__resourceUrl":"/phan-tich-thuat-toan-tiem-can-asymptotic-notation/index.html","__dataUrl":"/phan-tich-thuat-toan-tiem-can-asymptotic-notation/index.html.2eb7c846e63ab95bbcd33e60ac1b2b11.json"},{"id":6685,"layout":"Post","route":"phan-mem-tao-anh-gif-record-screen-cuc-nhanh","title":"Phần mềm tạo ảnh GIF Record Screen cực nhanh","tags":["gif"],"date":"2015-04-29T11:27:14.468Z","description":"Ảnh GIF hiện có mặt khắp mọi nơi từ 9gag đến github ( tạo iss nói không rõ vấn đề nên bị bắt làm gif :smile:  )\nĐặc biệt rất hữu ích trong…","__filename":"posts/6685.md","__url":"/phan-mem-tao-anh-gif-record-screen-cuc-nhanh/","__resourceUrl":"/phan-mem-tao-anh-gif-record-screen-cuc-nhanh/index.html","__dataUrl":"/phan-mem-tao-anh-gif-record-screen-cuc-nhanh/index.html.f38e5e62b949a50b56243a80e485a425.json"},{"id":6710,"layout":"Post","route":"chia-de-tri-tinh-luy-thua-a-n","title":"[Chia để trị] Tính lũy thừa a^n","tags":["algorithm"],"date":"2015-04-30T06:20:35.807Z","description":"Giờ rảnh được chút, làm thêm một bài nữa về một thuật toán cơ bản: tính lũy thừa an bằng phương pháp chia để trị.\nChắc mọi người đa số hay…","__filename":"posts/6710.md","__url":"/chia-de-tri-tinh-luy-thua-a-n/","__resourceUrl":"/chia-de-tri-tinh-luy-thua-a-n/index.html","__dataUrl":"/chia-de-tri-tinh-luy-thua-a-n/index.html.3daa3d2c38f08455f260cbe680acc591.json"},{"id":6730,"layout":"Post","route":"he-dieu-hanh-nao-se-la-vua-trong-tuong-lai","title":"Hệ điều hành nào sẽ là vua trong tương lai?","tags":null,"date":"2015-04-30T16:22:46.523Z","description":"\n\niOS đã từng làm mưa làm gió với sự cao sang của mình, làm thay đổi nguyên một thế giới Điện thoại Thông minh ở những năm 2007-2012 với…","__filename":"posts/6730.md","__url":"/he-dieu-hanh-nao-se-la-vua-trong-tuong-lai/","__resourceUrl":"/he-dieu-hanh-nao-se-la-vua-trong-tuong-lai/index.html","__dataUrl":"/he-dieu-hanh-nao-se-la-vua-trong-tuong-lai/index.html.55e6793f79710d2965523d56f2bdc4e1.json"},{"id":6758,"layout":"Post","route":"top-3-text-editor-for-web-development","title":"Top 3 Text Editor For Web Development","tags":["web"],"date":"2015-05-01T07:19:17.170Z","description":"Nếu bạn đang phân vân không biết chọn text editor nào phù hợp, thì đây là 3 lựa chọn cho bạn :smiley: . \n1.Sublime Text 3 http&#x3A;//www…","__filename":"posts/6758.md","__url":"/top-3-text-editor-for-web-development/","__resourceUrl":"/top-3-text-editor-for-web-development/index.html","__dataUrl":"/top-3-text-editor-for-web-development/index.html.95badd1f1ea9e8dbef7a9372014230ad.json"},{"id":6762,"layout":"Post","route":"tan-man-ve-mat-ma-hien-dai-part-1","title":"Tản mạn về Mật mã hiện đại (part 1)","tags":["security","rsa"],"date":"2015-05-01T07:56:22.461Z","description":"Bài viết được post tại đây: http&#x3A;//portal.daynhauhoc.com/p/tan-man-ve-mat-ma-hien-dai-part-1/\n\n\\#Tản mạn về Mật mã hiện đại  (part…","__filename":"posts/6762.md","__url":"/tan-man-ve-mat-ma-hien-dai-part-1/","__resourceUrl":"/tan-man-ve-mat-ma-hien-dai-part-1/index.html","__dataUrl":"/tan-man-ve-mat-ma-hien-dai-part-1/index.html.2e2189f11b8f40fbafa7246052df56de.json"},{"id":6818,"layout":"Post","route":"tan-man-ve-mat-ma-hien-dai-part-2","title":"Tản mạn về Mật mã hiện đại (part 2)","tags":["security","photon"],"date":"2015-05-02T12:25:53.828Z","description":"\\#Tản mạn về Mật mã hiện đại  (part 2)\n\nỞ bài viết trước mình đã giới thiệu các bạn về sơ bộ về mã RSA, còn ở bài này mình sẽ nói về tương…","__filename":"posts/6818.md","__url":"/tan-man-ve-mat-ma-hien-dai-part-2/","__resourceUrl":"/tan-man-ve-mat-ma-hien-dai-part-2/index.html","__dataUrl":"/tan-man-ve-mat-ma-hien-dai-part-2/index.html.6d22ac52ce32bdb397ce9dde477edde0.json"},{"id":6907,"layout":"Post","route":"wpf-va-mvvm-phan-4-ung-dung-trong-wpf","title":"WPF và MVVM – Phần 4: Ứng dụng trong WPF","tags":["c-sharp"],"date":"2015-05-05T09:55:12.620Z","description":"Một khái niệm dễ nhầm lẫn khá phổ biến mà tôi thấy mọi người khi bắt đầu với WPF là họ cảm thấy rằng đó là khó tiếp cận, quá phức tạp và quá…","__filename":"posts/6907.md","__url":"/wpf-va-mvvm-phan-4-ung-dung-trong-wpf/","__resourceUrl":"/wpf-va-mvvm-phan-4-ung-dung-trong-wpf/index.html","__dataUrl":"/wpf-va-mvvm-phan-4-ung-dung-trong-wpf/index.html.0f51425011b1c264023beb223b90f43b.json"},{"id":6921,"layout":"Post","route":"lam-sao-de-su-dung-bien-hieu-qua-hon-part1","title":"Làm sao để sử dụng biến hiệu quả hơn (part1)","tags":["coding-style"],"date":"2015-05-05T17:12:29.073Z","description":"Khi chương trình còn đơn giản thì việc sử dụng biến thường không thành vấn đề, nhưng khi bạn làm những chương trình lớn hơn thì việc sử dụng…","__filename":"posts/6921.md","__url":"/lam-sao-de-su-dung-bien-hieu-qua-hon-part1/","__resourceUrl":"/lam-sao-de-su-dung-bien-hieu-qua-hon-part1/index.html","__dataUrl":"/lam-sao-de-su-dung-bien-hieu-qua-hon-part1/index.html.aa34520f10b3e4110f4630e2c10ab015.json"},{"id":7030,"layout":"Post","route":"lam-blog-bang-jekyll-su-dung-host-cua-github-level-sieu-co-ban","title":"Làm Blog bằng Jekyll sử dụng host của Github (level siêu cơ bản)","tags":["blog","github","jekyll"],"date":"2015-05-08T13:11:33.302Z","description":"\\#Làm Blog bằng Jekyll sử dụng host của Github (level siêu cơ bản)\n\nHôm trước thấy có anh giới thiệu về cái này nên nghịch thử cho biết, vừa…","__filename":"posts/7030.md","__url":"/lam-blog-bang-jekyll-su-dung-host-cua-github-level-sieu-co-ban/","__resourceUrl":"/lam-blog-bang-jekyll-su-dung-host-cua-github-level-sieu-co-ban/index.html","__dataUrl":"/lam-blog-bang-jekyll-su-dung-host-cua-github-level-sieu-co-ban/index.html.3110fd387fde7ddbbf90a7644e78338e.json"},{"id":6936,"layout":"Post","route":"lam-sao-de-su-dung-bien-hieu-qua-hon-part2","title":"Làm sao để sử dụng biến hiệu quả hơn (part2)","tags":["coding-style"],"date":"2015-05-06T03:16:39.897Z","description":"Bài [viết trước][1] mình đã nói về cách khai báo biến và khởi tạo biến và bài viết này sẽ nói về cách chọn phạm vi biến sao cho code hiệu…","__filename":"posts/6936.md","__url":"/lam-sao-de-su-dung-bien-hieu-qua-hon-part2/","__resourceUrl":"/lam-sao-de-su-dung-bien-hieu-qua-hon-part2/index.html","__dataUrl":"/lam-sao-de-su-dung-bien-hieu-qua-hon-part2/index.html.728bcc480f7cd9144b95c20cf6f4f9e0.json"},{"id":6862,"layout":"Post","route":"can-than-khi-truyen-x-vao-mot-function-like-macro","title":"Cẩn thận khi truyền ++x vào một function-like macro","tags":null,"date":"2015-05-04T03:27:20.104Z","description":"Bài viết được post tại:  http&#x3A;//portal.daynhauhoc.com/p/can-than-khi-truyen-x-vao-mot-function-like-macro/\n\n1.Có thể các bạn đã biết…","__filename":"posts/6862.md","__url":"/can-than-khi-truyen-x-vao-mot-function-like-macro/","__resourceUrl":"/can-than-khi-truyen-x-vao-mot-function-like-macro/index.html","__dataUrl":"/can-than-khi-truyen-x-vao-mot-function-like-macro/index.html.461b4731cd78e0b868372f0b0c1d7048.json"},{"id":7063,"layout":"Post","route":"lam-sao-de-su-dung-bien-hieu-qua-hon-part-4","title":"Làm sao để sử dụng biến hiệu quả hơn (part 4)","tags":["coding-style"],"date":"2015-05-09T09:00:57.925Z","description":"\\#Làm sao để sử dụng biến hiệu quả hơn  (part 4)\n\nSử dụng một biến với nhiều mục đích đôi khi làm chúng ta có  cảm giác như tiết kiệm được…","__filename":"posts/7063.md","__url":"/lam-sao-de-su-dung-bien-hieu-qua-hon-part-4/","__resourceUrl":"/lam-sao-de-su-dung-bien-hieu-qua-hon-part-4/index.html","__dataUrl":"/lam-sao-de-su-dung-bien-hieu-qua-hon-part-4/index.html.3a927fa6e4dcb44bee8cd1c155b3704a.json"},{"id":7032,"layout":"Post","route":"comment-code-tai-sao-chung-ta-nen-comment-code-p1","title":"Comment Code - Tại sao chúng ta nên Comment Code? (p1)","tags":["comment","coding-style"],"date":"2015-05-08T14:43:06.789Z","description":"Comment code là một trong những chủ đề được tranh luận rộng rãi trong thế giới lập trình. Đó là điều mình được học ngay từ khi học môn đầu…","__filename":"posts/7032.md","__url":"/comment-code-tai-sao-chung-ta-nen-comment-code-p1/","__resourceUrl":"/comment-code-tai-sao-chung-ta-nen-comment-code-p1/index.html","__dataUrl":"/comment-code-tai-sao-chung-ta-nen-comment-code-p1/index.html.5766a8c960531a7855602ab8ebae5550.json"},{"id":7038,"layout":"Post","route":"tai-lieu-lap-trinh-c-for-newbie-chuong-2-nhung-ky-thuat-nang-cao","title":"[Tài liệu lập trình C for newbie] - Chương 2: Những kỹ thuật nâng cao!","tags":["document","c"],"date":"2015-05-08T17:30:09.509Z","description":"Hello every body. Long time no see!\n\nTrước tiên mình xin gửi lời cảm ơn đến Mr.Đạt vì đã tạo ra một sân chơi chung cho mọi người có cơ hội…","__filename":"posts/7038.md","__url":"/tai-lieu-lap-trinh-c-for-newbie-chuong-2-nhung-ky-thuat-nang-cao/","__resourceUrl":"/tai-lieu-lap-trinh-c-for-newbie-chuong-2-nhung-ky-thuat-nang-cao/index.html","__dataUrl":"/tai-lieu-lap-trinh-c-for-newbie-chuong-2-nhung-ky-thuat-nang-cao/index.html.448c1ea495f2182ac292ef7b13060483.json"},{"id":7092,"layout":"Post","route":"struct-la-gi-ban-chat-va-cach-su-dung","title":"Struct là gì? bản chất và cách sử dụng","tags":["union","data-structures","struct","c++"],"date":"2015-05-10T14:24:23.654Z","description":"Sử dụng struct trong chương trình\n\nOHM, lần trước chúng ta đã bàn về [Đệ Quy][1] rồi, bây giờ chúng ta lại quay về vấn đề cơ bản của ngôn…","__filename":"posts/7092.md","__url":"/struct-la-gi-ban-chat-va-cach-su-dung/","__resourceUrl":"/struct-la-gi-ban-chat-va-cach-su-dung/index.html","__dataUrl":"/struct-la-gi-ban-chat-va-cach-su-dung/index.html.172445a580cb55c9f0f086df600e6be3.json"},{"id":7275,"layout":"Post","route":"cai-dat-plugin-soat-loi-code-style-python-flake8-lint-cho-sublime-text-2","title":"Cài đặt Plugin soát lỗi code style Python Flake8 Lint cho Sublime Text 2","tags":["pep8","sublime-text-2","python"],"date":"2015-05-15T07:24:48.293Z","description":"Mình đang định học code Python theo style [PEP8][1] với cả mới chuyển nhà sang SublimeText nên quyết định mày mò tìm/cài đặt Plugin hỗ trợ…","__filename":"posts/7275.md","__url":"/cai-dat-plugin-soat-loi-code-style-python-flake8-lint-cho-sublime-text-2/","__resourceUrl":"/cai-dat-plugin-soat-loi-code-style-python-flake8-lint-cho-sublime-text-2/index.html","__dataUrl":"/cai-dat-plugin-soat-loi-code-style-python-flake8-lint-cho-sublime-text-2/index.html.971b9b1324f07d6ee17bd133be77d834.json"},{"id":7287,"layout":"Post","route":"giao-trinh-ky-thuat-lap-trinh-c-can-ban-va-nang-cao-phien-ban-moi-dep-ro-net-co-day-du-bookmarks","title":"Giáo Trình Kỹ Thuật Lập Trình C Căn Bản Và Nâng Cao phiên bản mới, đẹp, rõ nét, có đầy đủ bookmarks","tags":["document","c"],"date":"2015-05-15T14:33:43.891Z","description":"Mặc dù trên mạng đã có ebook này nhưng là phiên bản cũ 2006, bản Ebook này scan sách mới nhất (cũng không khác phiên bản cũ nhiều là mấy…","__filename":"posts/7287.md","__url":"/giao-trinh-ky-thuat-lap-trinh-c-can-ban-va-nang-cao-phien-ban-moi-dep-ro-net-co-day-du-bookmarks/","__resourceUrl":"/giao-trinh-ky-thuat-lap-trinh-c-can-ban-va-nang-cao-phien-ban-moi-dep-ro-net-co-day-du-bookmarks/index.html","__dataUrl":"/giao-trinh-ky-thuat-lap-trinh-c-can-ban-va-nang-cao-phien-ban-moi-dep-ro-net-co-day-du-bookmarks/index.html.88f978886adf6ddfc4c99c5e84441683.json"},{"id":7251,"layout":"Post","route":"cach-tai-them-ram-cho-laptop-ban-da-thu-chua-d","title":"Cách \"tải thêm\" RAM cho laptop, bạn đã thử chưa :D","tags":["hp"],"date":"2015-05-14T16:26:03.937Z","description":"Đợt trước thằng bạn mình nó dùng một con lap HP 1000 nhưng mà nó kêu ram yếu quá nên nó bảo mình xem hộ: Đây là cuộc đối thoại :\"ớ đù ram…","__filename":"posts/7251.md","__url":"/cach-tai-them-ram-cho-laptop-ban-da-thu-chua-d/","__resourceUrl":"/cach-tai-them-ram-cho-laptop-ban-da-thu-chua-d/index.html","__dataUrl":"/cach-tai-them-ram-cho-laptop-ban-da-thu-chua-d/index.html.c6685b40b142700304028428c7ba809e.json"},{"id":7871,"layout":"Post","route":"101-loi-co-ban-trong-lap-trinh-c","title":"101 Lỗi cơ bản trong Lập Trình C","tags":["c"],"date":"2015-06-01T14:15:36.242Z","description":"Tình cờ lụm được trên mạng nên chia sẻ ngay cho mọi người :)\n","__filename":"posts/7871.md","__url":"/101-loi-co-ban-trong-lap-trinh-c/","__resourceUrl":"/101-loi-co-ban-trong-lap-trinh-c/index.html","__dataUrl":"/101-loi-co-ban-trong-lap-trinh-c/index.html.bdb385446015130970c01b0a7defa679.json"},{"id":7734,"layout":"Post","route":"suy-nghi-cua-1-lap-trinh-vien-phan-2","title":"Suy nghĩ của 1 lập trình viên ! ( Phần 2 )","tags":null,"date":"2015-05-27T18:44:39.593Z","description":"tiếp theo phần 1 [http://daynhauhoc.com/t/suy-nghi-cua-1-lap-trinh-vien-phan-1/7733][1]\n\nTrong bài viết trước, tôi đã cố gắng mô tả một số…","__filename":"posts/7734.md","__url":"/suy-nghi-cua-1-lap-trinh-vien-phan-2/","__resourceUrl":"/suy-nghi-cua-1-lap-trinh-vien-phan-2/index.html","__dataUrl":"/suy-nghi-cua-1-lap-trinh-vien-phan-2/index.html.4a1a819fb26489ff9e66665892aefc87.json"},{"id":8069,"layout":"Post","route":"tool-ho-tro-xu-li-loi-man-hinh-xanh-chet-choc","title":"Tool hỗ trợ xử lí lỗi màn hình xanh chết chóc","tags":["tool","bsod"],"date":"2015-06-07T08:15:57.025Z","description":"Tool này sẽ đọc các file dmp trong C:\\\\Windows\\\\minidump để đưa ra các thông tin về lỗi màn hình xanh\nhttp&#x3A;//www.nirsoft.net/utils/blue…","__filename":"posts/8069.md","__url":"/tool-ho-tro-xu-li-loi-man-hinh-xanh-chet-choc/","__resourceUrl":"/tool-ho-tro-xu-li-loi-man-hinh-xanh-chet-choc/index.html","__dataUrl":"/tool-ho-tro-xu-li-loi-man-hinh-xanh-chet-choc/index.html.c61d03001308c80ef7f5e85fd9dc771c.json"},{"id":8330,"layout":"Post","route":"cach-hoc-lap-trinh-thanh-cong","title":"Cách học lập trình thành công","tags":["learn","how-to","programming"],"date":"2015-06-15T13:56:33.572Z","description":"Đạt đang học Python, cho vui, và làm [Video hướng dẫn Python][1], lấy tiếng :sunglasses:. \n\nMình thấy cách học lập trình hay nhất, hiệu quả…","__filename":"posts/8330.md","__url":"/cach-hoc-lap-trinh-thanh-cong/","__resourceUrl":"/cach-hoc-lap-trinh-thanh-cong/index.html","__dataUrl":"/cach-hoc-lap-trinh-thanh-cong/index.html.afc3545e52978cc1e9fdce8415e6ed23.json"},{"id":8457,"layout":"Post","route":"lam-the-nao-de-hien-thi-va-nhap-tieng-viet-trong-cmd-windows","title":"Làm thế nào để hiển thị và nhập tiếng Việt trong cmd Windows","tags":["unicode","windows"],"date":"2015-06-18T14:21:44.971Z","description":"Bước 1: Mở cmd gõ chcp 65001 \nhttps&#x3A;//msdn.microsoft.com/en-us/library/windows/desktop/dd317756%28v=vs.85%29.aspx\n\nBước 2: Chuột phải…","__filename":"posts/8457.md","__url":"/lam-the-nao-de-hien-thi-va-nhap-tieng-viet-trong-cmd-windows/","__resourceUrl":"/lam-the-nao-de-hien-thi-va-nhap-tieng-viet-trong-cmd-windows/index.html","__dataUrl":"/lam-the-nao-de-hien-thi-va-nhap-tieng-viet-trong-cmd-windows/index.html.391eeeabd0a0c77ebd738fd4df06d325.json"},{"id":8257,"layout":"Post","route":"nghe-thuat-cua-code-de-doc-phan-1","title":"Nghệ thuật của code \"dễ đọc\" (Phần 1)","tags":["coding-style"],"date":"2015-06-13T16:43:14.561Z","description":"Chào các bạn, hôm nọ mình có đọc được bài http&#x3A;//daynhauhoc.com/t/lam-sao-de-su-dung-bien-hieu-qua-hon-part1/6921 của anh thanhmssl10…","__filename":"posts/8257.md","__url":"/nghe-thuat-cua-code-de-doc-phan-1/","__resourceUrl":"/nghe-thuat-cua-code-de-doc-phan-1/index.html","__dataUrl":"/nghe-thuat-cua-code-de-doc-phan-1/index.html.5e25f1cc9fa6b5f4c6a99690b6eaf059.json"},{"id":8626,"layout":"Post","route":"co-gi-moi-trong-javascript","title":"Có gì mới trong javascript","tags":["wiki","programming","javascript"],"date":"2015-06-22T14:22:11.551Z","description":"Đang học lại javascript thấy cái này hay [javascript es6][1]\n\nMình thấy có một số cái mới khá hay nên chia sẻ cùng mọi người :smile…","__filename":"posts/8626.md","__url":"/co-gi-moi-trong-javascript/","__resourceUrl":"/co-gi-moi-trong-javascript/index.html","__dataUrl":"/co-gi-moi-trong-javascript/index.html.251937a2ff183f17391bf22a3570a4cd.json"},{"id":9290,"layout":"Post","route":"nguoi-vn-minh-gioi-qua-phai-rang-phan-dau","title":"Người VN mình giỏi quá, phải ráng phấn đấu","tags":null,"date":"2015-07-10T02:04:27.754Z","description":"Sáng nay đang StackOverflow thì đọc thấy câu trả lời này hay, tuy không cụ thể. Thử xem profile của ông này thế nào mà điểm cao thế\n\n \n\nOh…","__filename":"posts/9290.md","__url":"/nguoi-vn-minh-gioi-qua-phai-rang-phan-dau/","__resourceUrl":"/nguoi-vn-minh-gioi-qua-phai-rang-phan-dau/index.html","__dataUrl":"/nguoi-vn-minh-gioi-qua-phai-rang-phan-dau/index.html.3a5a9cf4fafde359503c840aa700c6b3.json"},{"id":8542,"layout":"Post","route":"su-dung-hashtag-dung-cach-tren-mang-xa-hoi","title":"Sử dụng hashtag # đúng cách trên mạng xã hội","tags":["howto","hashtag"],"date":"2015-06-20T15:31:42.057Z","description":"Theo định nghĩa [Wikipedia][1] thì hashtag là một cách để đánh dấu một chủ đề bằng các sử dụng dấu # và theo sau là một chữ, câu không có…","__filename":"posts/8542.md","__url":"/su-dung-hashtag-dung-cach-tren-mang-xa-hoi/","__resourceUrl":"/su-dung-hashtag-dung-cach-tren-mang-xa-hoi/index.html","__dataUrl":"/su-dung-hashtag-dung-cach-tren-mang-xa-hoi/index.html.b4ca847b18b368ae6e9f65a1672935d4.json"},{"id":9361,"layout":"Post","route":"review-kinh-thuc-tai-ao-smilecardboard","title":"[Review] Kính thực tại ảo SmileCardboard","tags":["vr","review"],"date":"2015-07-11T15:21:04.420Z","description":"Từ bé đã mê cái kính thực tại ảo, ôm vào mặt  bước vào trong bộ phim để tha hồ tự sướng^^. Tuy nhiên mơ ước chỉ là mơ ước, vì những cái kính…","__filename":"posts/9361.md","__url":"/review-kinh-thuc-tai-ao-smilecardboard/","__resourceUrl":"/review-kinh-thuc-tai-ao-smilecardboard/index.html","__dataUrl":"/review-kinh-thuc-tai-ao-smilecardboard/index.html.131b767c8ba2379f374726c55a2b5231.json"},{"id":8539,"layout":"Post","route":"tai-sao-moi-nguoi-lai-thich-dung-tag-khong-ly-do-nhu-vay","title":"Tại sao mọi người lại thích dùng [tag] không lý do như vậy?","tags":["tag"],"date":"2015-06-20T15:09:44.592Z","description":"Đạt thấy ở nhiều diễn đàn ở VN hiện nay, có cả dnh, hay có các topic sử dụng tag một cách lạ lùng, ví dụ như\n\n[Tâm sự] bạn\n\nHoặc\n\n[U23 Việt…","__filename":"posts/8539.md","__url":"/tai-sao-moi-nguoi-lai-thich-dung-tag-khong-ly-do-nhu-vay/","__resourceUrl":"/tai-sao-moi-nguoi-lai-thich-dung-tag-khong-ly-do-nhu-vay/index.html","__dataUrl":"/tai-sao-moi-nguoi-lai-thich-dung-tag-khong-ly-do-nhu-vay/index.html.a4fb93d328364dd3d6e4637562dd2801.json"},{"id":9704,"layout":"Post","route":"lam-sao-de-cau-hoi-cua-minh-thu-hut-duoc-nhieu-views-va-mau-co-cau-tra-loi-tren-daynhauhoc","title":"Làm sao để câu hỏi của mình thu hút được nhiều views và mau có câu trả lời trên DayNhauHoc?","tags":["share","how-to-ask","wiki"],"date":"2015-07-19T14:07:53.878Z","description":"Đạt thấy có nhiều topic mất rất nhiều thời gian để thu hút sự chú ý của các thành viên khác và nhận được câu trả lời. Bài viết này chia sẻ…","__filename":"posts/9704.md","__url":"/lam-sao-de-cau-hoi-cua-minh-thu-hut-duoc-nhieu-views-va-mau-co-cau-tra-loi-tren-daynhauhoc/","__resourceUrl":"/lam-sao-de-cau-hoi-cua-minh-thu-hut-duoc-nhieu-views-va-mau-co-cau-tra-loi-tren-daynhauhoc/index.html","__dataUrl":"/lam-sao-de-cau-hoi-cua-minh-thu-hut-duoc-nhieu-views-va-mau-co-cau-tra-loi-tren-daynhauhoc/index.html.1b42751c96c9956f33f399da4338523e.json"},{"id":5719,"layout":"Post","route":"de-quy-dich-boi-breakdown","title":"Đệ quy - dịch bởi @breakdown","tags":null,"date":"2015-04-09T07:06:07.833Z","description":"Đây là một bài viết hay được dịch bởi @breakdown. Bài viết được lấy từ sách: \"C Primer Plus 6th Edition\"\n\n* * *\n\nĐệ Quy (Recursion)\n\nHôm nay…","__filename":"posts/5719.md","__url":"/de-quy-dich-boi-breakdown/","__resourceUrl":"/de-quy-dich-boi-breakdown/index.html","__dataUrl":"/de-quy-dich-boi-breakdown/index.html.15aed1e5698c2fa892d2ebf575c2c14a.json"}];window.__INITIAL_STATE__ = {"pages":{"/de-quy-dich-boi-breakdown/":{"head":{"id":5719,"layout":"Post","route":"de-quy-dich-boi-breakdown","title":"Đệ quy - dịch bởi @breakdown","tags":null,"date":"2015-04-09T07:06:07.833Z","description":"Đây là một bài viết hay được dịch bởi @breakdown. Bài viết được lấy từ sách: \"C Primer Plus 6th Edition\"\n\n* * *\n\nĐệ Quy (Recursion)\n\nHôm nay…"},"body":"<p>Đây là một bài viết hay được dịch bởi @breakdown. Bài viết được lấy từ sách: &quot;C Primer Plus 6th Edition&quot;</p>\n<hr>\n<h2 id=\"-quy-recursion\"><a href=\"#-quy-recursion\" class=\"statinamic-HeadingAnchor\">#</a>Đệ Quy (Recursion)</h2>\n<p>Hôm nay chúng ta sẽ quay lại với ĐỆ QUY. Thực chất đệ quy không phức tạp như mọi người nghĩ, đệ quy cũng chỉ là một hàm nhưng hàm này đặc biệt hơn những hàm khác. Hàm đệ quy tự gọi chính nó.\n\nDo cách thức đặc biệt này của đệ quy nên xảy ra rất nhiều vấn đề xung quanh đệ quy. Vấn đề đầu tiên mà mọi người nghĩ tới có lẽ sẽ là làm sao để hàm đệ quy này không gọi lại nó nữa. Chúng ta gọi việc này là điều kiện chấm dứt đệ quy.\n\nNhư chúng ta đã bàn bạc bên tr��n, đệ quy có tính chất cũng khá giống vòng lặp, và có thể sử dụng được ở mọi nơi mà vòng lặp có thể sử dụng. Đôi khi cách sử dụng vòng lặp rõ ràng và ngắn gọn, nhưng cách dùng đệ quy còn rõ ràng, ngắn gọn hơn rất nhiều.\n\nRecursion Revealed -- Tính chất &quot;Đảo&quot; của đệ quy</p>\n<hr>\n<p>Bây giờ chúng ta hãy đi sâu và xem cách thức mà một hàm đệ quy thực thi và kết quả của hàm đệ quy.\n\nTrong đoạn code bên dưới, chúng ta thấy được hàm main() sẽ gọi một hàm mang tên up_and_down. Trong bài này mình sẽ gọi đây là &quot;lần đầu tiên gọi hàm&quot;. Tiếp theo đó hàm up_and_down() sẽ gọi lại chính nó với tham số truyền vào là n+1, mình sẽ gọi đây là &quot;lần thứ hai gọi hàm&quot;, cứ thế tiếp tục mọi ngừoi theo cách đó nhé.<br>\nỞ trong ví dụ bên dưới, hàm up_and_down() sẽ tự gọi nó 4 lần, mình gọi mỗi lần là 1 level, cứ thế mà tăng lên. Ở trong ví dụ mình có sử dụng operation &amp;, để hiểu rõ thêm chức năng của operation này, bạn có thể theo dõi ở các bài viết sau. Ở bài viết này mình chỉ nói sơ qua Operation &amp; lấy địa chỉ của biến lưu trữ trong bộ nhớ máy tính. Để sử dụng operation &amp;, trong hàm printf mình phải xuất dạng %p, nếu các bạn không thể sử dụng %p thì có thể dùng %lu hoặc %u để thay thế.\n\nChương trình recur.c</p>\n<pre><code>/* recur.c -- */ \n#include &lt;stdio.h&gt; \nvoid up_and_down(int); \nint main(void) \n{ \n    up_and_down(1); \n    return 0; \n} \nvoid up_and_down(int n) \n{ \n    printf(&quot;Level %d: n location %p\\n&quot;, n, &amp;n); // 1 \n    if (n &lt; 4) \n        up_and_down(n+1); \n    printf(&quot;LEVEL %d: n location %p\\n&quot;, n, &amp;n); // 2 \n} \n</code></pre>\n<p>Trong ví dụ trên Output sẽ như thế này:</p>\n<blockquote>\n<p>Level 1: n location 0x0012ff48\nLevel 2: n location 0x0012ff3c\nLevel 3: n location 0x0012ff30\nLevel 4: n location 0x0012ff24\nLEVEL 4: n location 0x0012ff24\nLEVEL 3: n location 0x0012ff30\nLEVEL 2: n location 0x0012ff3c\nLEVEL 1: n location 0x0012ff48</p>\n</blockquote>\n<p>Bây giờ chúng ta hãy bàn về cách mà đệ quy hoạt động.\n\nBan đầu, chúng ta xem trong hàm main() có lời gọi hàm up_and_down() với tham số truyền vào là 1 ( up_and_down(1) ). Vậy nghĩa là n trong hàm up_and_down() sẽ bằng 1.<br>\nNhư đã nói bên trên, mình sẽ gọi đây là Level 1, để xác nhận gọi hàm thành công, mình sẽ in ra dòng Level 1: n location 0x0012ff48 nhờ câu lệnh: <code>printf(&quot;Level %d: n location %p\\n&quot;, n, &amp;n);</code>. Tiếp tới máy sẽ tiếp tục chạy câu lệnh tiếp theo là câu lệnh <code>if (n &lt; 4)</code>; Tại câu lệnh này, máy sẽ xét điều kiện n có nhỏ hơn 4 không, nếu đúng thì sẽ tiếp tục gọi hàm <code>up_and_down(n+1);</code>. Tại đây như các bạn đã thấy, hàm <code>up_and_down(n);</code> gọi <code>up_and_down(n+1);</code>. hay có thể gọi <code>up_and_down(2);</code> do <code>n = 1, n + 1 =2</code>. Lần này mình sẽ gọi đây là lần gọi hàm thứ hai (hay Level 2).\n\nỞ Level 2, do cùng cách thức hoạt động nên hàm này sẽ thực thi giống như trên mình đã nói, và sẽ gọi tiếp hàm thứ 3, hàm thứ 4...(gọi là Level 3, Level 4). Trong đoạn code này  mình chỉ giới hạn đệ quy gọi hàm 4 lần, vậy tại Level 4 sẽ kết thúc gọi hàm (điều kiện if sai nên không còn lời gọi hàm nữa\n)\n\nVậy là tới đây chúng ta đã giải quyết 1/2 chặn đường của Output rồi. Khi code chạy tới đây thì Output sẽ giống thế này:</p>\n<blockquote>\n<p>Level 1: n location 0x0012ff48\nLevel 2: n location 0x0012ff3c\nLevel 3: n location 0x0012ff30</p>\n</blockquote>\n<p>Level 4: n location 0x0012ff24\n------ket qua chay toi day-------\nLEVEL 4: n location 0x0012ff24\nLEVEL 3: n location 0x0012ff30\nLEVEL 2: n location 0x0012ff3c\nLEVEL 1: n location 0x0012ff48<br>\nVậy tại sao trong OUTPUT của chươn trình lại còn có thêm kết quả bên dưới. Đây là vấn đề của đệ quy, khi chạy tới bên trên thì đệ quy up_and_down() vẫn chưa hết nhiệm vụ của nó. Hãy xem lại đệ quy còn 1 đoạn chương trình bên dưới nữa:</p>\n<pre><code>if (n &lt; 4) \nup_and_down(n+1); \nprintf(&quot;LEVEL %d: n location %p\\n&quot;, n, &amp;n); // 2 \n</code></pre>\n<p>Chúng ta quay lại giá trị n tại Level 4. Lúc này n đang giữ giá trị là 4, vậy nghĩa là điều kiện if trong hàm up_and_down() không còn đúng nữa, vì thế chúng ta không còn lời gọi hàm nào nữa ở đây. Chúng ta đều biết chương trình là một tập các lệnh dành cho máy tính, máy tính thực thi các lệnh từ trên xuống dưới và không bỏ xót lệnh nào. Vì thế khi chạy tới Level 4 thì máy tính cũng  mới chỉ chạy xong lệnh <code>up_and_down(n+1)</code>, và lúc này vẫn còn <code>printf(&quot;LEVEL %d: n location %p\\n&quot;, n, &amp;n);</code>.\n\nKhi Level 4 không còn lời gọi hàm, thì nó còn 1 lệnh in, và máy tính sẽ thực hiện lệnh in này. Đó là nguyên nhân tại sao Level 4 lại được in 2 lần, vì trước tiên máy sẽ in <code>//1</code> và sau đó máy sẽ in <code>//2</code>. Thế là kết thúc Level 4.\n\nNhưng hãy tưởng tượng, khi bạn sử dụng một hàm bình thường, cái bạn cần là &quot;trả trị&quot;, đệ quy cũng thế. Level 1 gọi Level 2, chờ level 2 trả trị về, level 2 gọi level 3 chờ level 3 trả trị về, level 3 gọi level 4 chờ level 4 trả trị về... Cứ tiếp thế. Vậy nghĩa là hàm a gọi hàm b thì phải chờ hàm b thực thi xong và &quot;trả trị&quot; về và hàm a mới có thể tiếp tục thực hiện các câu lệnh tiếp theo trong hàm.\n\nTrở về quá trình hoạt động của hàm up_and_down(), chúng ta nhớ ra rằng các level của đệ quy trước đó chỉ mới thực hiện tới <code>up_and_down(n+1)</code> và nó còn 1 dòng lệnh cuối cùng nữa <code>printf(&quot;LEVEL %d: n location %p\\n&quot;, n, &amp;n);</code>. Vì thế nên khi đệ quy Level 4 thực thi xong, &quot;quyền kiểm soát&quot; sẽ được giao cho Level 3, level 3 lại thực hiện lệnh in cuối cùng và trả quyền này về level 2, level 2 trả về level 1 và level 1 trả về main() rồi kết thúc chương trình.\n\nLưu ý rằng mỗi level của đệ quy đều sử dụng biến private n. Thông qua địa chỉ của biến n thì ta có thể gọi n (phần này liên quan đến con trỏ pointer nên mình không đề cập ở đây). Ở mỗi hệ thống thì địa chỉ này có thể khác nhau.<br>\nOhm, Nếu cái lý giải bên trên khó hiểu với bạn, thì hãy thử tưởng tượng; Bạn cài đặt các hàm như ham1(), ham2(), ham3(), ham4() với nội dung sau đây:</p>\n<pre><code>int ham1(){ ham2(); printf(&quot;hello, im in level 1!!!!\\n&quot;); return 0;} \nint ham2(){ ham3(); printf(&quot;hello, im in level 2!!!!\\n&quot;); return 0;} \nint ham3(){ ham4(); printf(&quot;hello, im in level 3!!!!\\n&quot;); return 0;} \nint ham4(){ printf(&quot;hello, im in level 4!!!!\\n&quot;);return 0;} \n \nint main(){ ham1(); return 0;} \n</code></pre>\n<p>Kết quả nhận được:</p>\n<blockquote>\n<p>hello, im in level 4!!!!\nhello, im in level 3!!!!\nhello, im in level 2!!!!\nhello, im in level 1!!!!</p>\n</blockquote>\n<p>Như chúng ta thấy cách thức của các hàm ham1-4 rất giống cách thức hoạt động của đệ quy. Đệ quy thực sự chỉ là cách viết gọn của 4 ham có cùng cách thức hoạt động thôi.<br>\nNguyên tắc cơ bản của đệ quy</p>\n<hr>\n<p>Chúng ta đã biết cách thức hoạt động của đê quy, nếu bạn là người mới biết sử dụng đệ quy, bạn sẽ thấy đệ quy khá là khó để sử dụng và cũng khá rắc rối để hiểu. Bây giờ mình sẽ đưa ra một vấn đề chủ chốt của đệ quy.\n\nĐầu tiên, như đã nói bên trên, Đệ quy là hàm tự gọi nó, và nó sẽ cứ thế cho tới khi một điều kiện nào đó thỏa. Như ở ví dụ trên, khi n &gt;= 4 thì sẽ không có lời gọi hàm đệ quy nào nữa. Nhưng tại sao n lại bằng 4? Tất nhiên là do trong mỗi lần đệ quy, chúng ta tăng n lên 1 và cứ thế n sẽ là bằng 4. Như cách mình đã nói bên trên, mỗi hàm &quot;sẽ chờ&quot; hàm được gọi thực thi xong thì hàm đó mới thực thi tiếp. Vậy nghĩa là phải có &quot;một chỗ nào đó&quot; chứa biến số n. Đó là nguyên nhân tại sao biến số n lại có 4 địa chỉ khác nhau trong OUTPUT.\n\nBây gườ chúng ta hãy xem 4 biến số đó như thế nào.</p>\n<pre><code>        variables:                |    n     n     n     n \nafter level 1 call                |    1                 \nafter level 2 call                |    1    2         \nafter level 3 call                |    1    2    3     \nafter level 4 call                |    1    2    3    4     \n after return from level 4        |    1    2    3     \n after return from level 3        |    1    2         \n after return from level 2        |    1             \n after return from level 1        |\n</code></pre>\n<p>Cũng khá dễ tưởng tượng đúng không nào? Vậy tại sao 1 biến số n mà có tới 4 giá trị, máy tính lưu trữ ra sao. Mình sẽ bàn tiếp trong bài tới. Bài này chỉ để đệ quy thôi nhé.\n\nThứ hai, trong mỗi lần gọi hàm thì hàm được gọi sẽ trả trị (chúng ta hay gọi là return). Cứ thế thì level 4 sẽ trả trị về level 3, 3 trả về 2, 2 trả về 1, 1 trả về main(). Chúng ta không thể trả vượt cấp ngay về main() được.\n\nThứ ba, hàm đệ quy thực hiện theo điều kiện, điều kiện nào đến trước sẽ được thực hiện trước, điều kiện nào đến sau sẽ thực hiện sau, mình đã giải thích bên trên.<br>\nThứ tư, điều kiện được gọi sau khi gọi hàm đệ quy sẽ được thực hiện khi hàm đệ quy đó nhận được trị trả về của hàm đệ quy nó gọi. Ví dụ, điều kiện in ở #2 được thực hiện sau khi quá trình gọi hàm đệ quy kết thúc và được thực thi thông qua các lệnh: Level 4, Level 3, Level2, Level1. Chức năng này của đệ quy thực sự hữu dụng trong các chương trình phải xử lý các tiến trình liên quan đến revelsals.\n\nThứ năm, mặc dầu mỗi Level của đệ quy có biến của riêng nó, nhưng code thì lại được dùng chung. Code là một chuỗi các hướng dẫn cho máy tính, và lời gọi hàm đơn giản di chuyển đến điểm bắt đầu của chuỗi các hướng dẫn đó. Ngoài việc tạo ra biến riếng cho mỗi lần gọi hàm, đệ quy giống như vòng lặp. Thực tế, đôi khi đệ quy có thể được dùng thay cho vòng lặp và ngược lại.\n\nCuối cùng, hàm đệ quy phải có một điều kiện để ngăn chặn tiến trình gọi hàm. Thông thường các lập trình viên sử dụng if else. Để làm việc này, mỗi lần gọi đệ quy ta phải đưa vào một tham số khác với tham số trước đó (như ở trên là n và n + 1). Trong ví dụ trên các tham số được đưa vào mỗi lần gọi hàm là 1, 2, 3, 4; Bạn có thể xem lại bảng variable bên trên để hiểu rõ thêm.<br>\nĐệ quy Đuôi---Tail Recursion</p>\n<hr>\n<p>Cách đơn giản để sử dụng một hàm đệ quy là sử dụng nó ngay return statement. Đây được gọi là đệ quy đuôi, có thể gọi là tail recursion hay end recursion. Đệ quy đuôi là một cách đơn giản và nó hoạt động khá giống vòng lặp.\n\nỞ ví dụ dưới đây, mình sẽ làm một bài toán tính giá trị giai thừa của một số; Ví dụ 3! = 1 <em> 2 </em> 3</p>\n<pre><code>// factor.c \n#include &lt;stdio.h&gt; \nlong fact(int n); \nlong rfact(int n); \nint main(void) \n{ \n    int num; \n    printf(&quot;This program calculates factorials.\\n&quot;); \n    printf(&quot;Enter a value in the range 0-12 (q to quit):\\n&quot;); \n    while (scanf(&quot;%d&quot;, &amp;num) == 1) \n    { \n        if (num &lt; 0) \n            printf(&quot;No negative numbers, please.\\n&quot;); \n        else if (num &gt; 12) \n            printf(&quot;Keep input under 13.\\n&quot;); \n        else \n        { \n            printf(&quot;loop: %d factorial = %ld\\n&quot;, \n                    num, fact(num)); \n            printf(&quot;recursion: %d factorial = %ld\\n&quot;, \n                    num, rfact(num)); \n        } \n        printf(&quot;Enter a value in the range 0-12 (q to quit):\\n&quot;); \n    } \n    printf(&quot;Bye.\\n&quot;); \n    return 0; \n} \nlong fact(int n) \n{ \n    long ans; \n    // loop-based function \n    for (ans = 1; n &gt; 1; n--) \n        ans *= n; \n    return ans; \n} \nlong rfact(int n) // recursive version \n{ \n    long ans; \n    if (n &gt; 0) \n        ans= n * rfact(n-1); \n    else \n        ans = 1; \n    return ans; \n} \n</code></pre>\n<p>Chương trình này của mình chỉ giới hạn nhập số interger có giá trị giao động từ 0 tới 12. Vì giá trị của 12! lên tới nữa tỉ, giá trị này thực sự lớn hơn kiểu long của máy tính, và nếu như bạn muốn sử dụng số lớn hơn 12! thì bạn chắc phải dùng kiểu double hoặc long long.\n\nDưới đây là kết quả sau khi kết thúc chương trình trên:</p>\n<blockquote>\n<p>This program calculates factorials.\nEnter a value in the range 0-12 (q to quit):\n5\nloop: 5 factorial = 120\nrecursion: 5 factorial = 120\nEnter a value in the range 0-12 (q to quit):\n10\nloop: 10 factorial = 3628800\nrecursion: 10 factorial = 3628800\nEnter a value in the range 0-12 (q to quit):\nq\nBye.</p>\n</blockquote>\n<p>Ở hàm mình sử dụng vòng lặp, máu tính sẽ khởi tạo một biến tên ans = 1, sau đó nhân với các số nguyên từ 2 tới n (hoặc từ n về 2 - nói chính xác là thế). Về mặt kỹ thuật thì phải từ n về 1, nhưng số nào nhân với 1 cũng sẽ bằng chính nó, việc này trở lên vô nghĩa trong lập trình.\n\nBây giờ hãy xem cách mà đệ quy thực hiện. Hướng làm khi tính giai thừa của một số n! là n! = n * (n -1)!.\n\nHãy xem ví dụ sau:</p>\n<pre><code>3!  = 3 * (3-1)! \n    = 3 * 2!\n</code></pre>\n<p>Ta xem</p>\n<pre><code>2!  = 2 * (2 - 1)! \n    = 2 * 1! \n</code></pre>\n<p>Ta có <code>1! = 1</code>\n\nVậy có đúng là <code>3! = 3 * 2 * 1.</code>\n\nQuay trở lại vấn đề, ta thấy được công thức này là cách để chúng ta tiếp cận và sử dụng đệ quy trong bài toán tìm số giai thừa. Bên trên mình đã khai báo một hàm <code>rfact()</code>, chúng ta chỉ cần truyền vào 1 tham số n, vậy có nghĩa là chúng ta sẽ sử dụng hàm <code>rfact</code> thế này: <code>n * rfact(n - 1)</code>\n\nNhư các bạn thấy đấy, cả 2 cách dùng vòng lặp hoặc đệ quy đều cho ra kết quả như nhau. Nhưng nhớ rằng <code>rfact()</code> không phải là statement cuối cùng trong hàm đệ quy, nó chỉ là statement cuối cùng trong hàm if (n &gt; 0), và nó là tail recursion.\n\nVậy có một câu hỏi vui đặt ra là thế này: &quot;Nếu sử dụng được cả hai cách bạn sẽ sử dụng cách nào?&quot;. Thông thường, sử dụng vòng lặp là cách được khuyến khích hơn. Vậy tại sao cách này lại được khuyến khích hơn; Chúng ta cùng phân tích bên dưới.\n\nTrở về bảng Variable bên trên, chỉ qua 4 lần gọi hàm, chúng ta cần tốn 4 ô nhớ để chứa 4 biến với 4 giá trị khác nhau. Đệ quy lưu trữ giá trị trong stack, và bộ nhớ stack là có giới hạn. Nếu 4 ô nhớ này chưa đủ thuyết phục bạn, hãy xem tiếp ví dụ mình sẽ nêu bên dưới.\n\nThứ hai, đệ quy có tốc độ chậm hơn, việc gọi và xử lý, lưu trữ giá trị... của hàm làm tiêu tốn rất nhiều thời gian.\n\nVà bây giờ, bạn đang tự đặt ra câu hỏi là: &quot;Tại sao lại đưa ra ví dụ trên?&quot;. Tất nhiên là ví dụ trên là cách đơn giản nhất để giảng giải như thế nào là &quot;tail recursion&quot;.<br>\nĐệ quy và Reversal</p>\n<hr>\n<p>Reversal, hay còn gọi là tính đảo ngược. Đây là một vấn đề khá thú vị trong đệ quy. Chúng ta hãy cùng thảo luận.\n\nMình đưa ra một yêu cầu thế này: &quot;Hãy viết hàm chuyển số thập phân về nhị phân&quot;. Đây là một vấn đề mà ai là lập trình viên đều biết, thực sự rất đơn giản, nhưng qua yêu cầu này chúnng ta có thể thấy được tính đảo ngược này có ích như thế nào.</p>\n<pre><code>/* binary.c -- prints integer in binary form */ \n#include &lt;stdio.h&gt; \nvoid to_binary(unsigned long n); \nint main(void) \n{ \n    unsigned long number; \n    printf(&quot;Enter an integer (q to quit):\\n&quot;); \n    while (scanf(&quot;%lu&quot;, &amp;number) == 1) \n    { \n        printf(&quot;Binary equivalent: &quot;); \n        to_binary(number); \n        putchar(&#x27;\\n&#x27;); \n        printf(&quot;Enter an integer (q to quit):\\n&quot;); \n    } \n    printf(&quot;Done.\\n&quot;); \n    return 0; \n} \nvoid to_binary(unsigned long n) \n{ \n    int r; /* recursive function */ \n    r = n % 2; \n    if (n &gt;= 2) \n        to_binary(n / 2); \n    putchar(r == 0 ? &#x27;0&#x27; : &#x27;1&#x27;); \n    return; \n} \n</code></pre>\n<p>Ở đây mình đã xây dựng một hàm to_binary(), ở hàm này sẽ xét r = n % 2, hàm sẽ hiển thị  một ký tự &#x27;0&#x27; nếu trị r là 0 và hiển thị &#x27;1&#x27; nếu giá trị r là 1. Biểu thức r == 0 ? &#x27;0&#x27; : &#x27;1&#x27; cung cấp phương thức này, giải nghĩa ra ta có thể hiểu rằng: xét r có bằng 0 không, nếu r = 0 thì in ra 0, nếu r !=0 thì in ra 1. Các phương thức tính toán binary thì mình không bàn tới, vì đây là cơ bản.\n\nBên dưới đây là kết quả sau khi chạy chương trình:</p>\n<blockquote>\n<p>Enter an integer (q to quit):\n9\nBinary equivalent: 1001\nEnter an integer (q to quit):\n255\nBinary equivalent: 11111111\nEnter an integer (q to quit):\n1024\nBinary equivalent: 10000000000\nEnter an integer (q to quit):\nq\ndone.</p>\n</blockquote>\n<p>Liệu bạn có thể sử dụng vòng lặp để tính binary? Tất nhiên là được, nhưng bạn cần phải lưu trữ từng giá trị n % 2 trong một nơi nào đó, một mảng chẳng hạn.\n\nTất nhiên trong hàm đệ quy có nhiều vấn đề rắc rối mình đã đề cập bên trên. Việc không quản lý được số lần gọi đệ quy sẽ làm hao tốn rất nhiều bộ nhớ và tài nguyên máy tính. Trong ví dụ này, nếu con số muốn chuyển qua binary lên tới nữa tỉ như 12! bên trên, thì gọi đệ quy thực sự là nhức đầu khi mà máy tính phải lưu trữ rất nhiều nhiều giá trị r... Và tất nhiên cách sử dụng mảng để lưu trữ cùng vòng lặp cũng nhức đầu không kém. Quan trọng bạn phải biết cách sử dụng cái nào tốt hơn.\n\nRecursion Pros and Cons</p>\n<hr>\n<p>Có lẽ đệ quy không được đánh giá cao chỉ do một lý do duy nhất: Sử dụng quá nhiều tài nguyên máy tính. Tài nguyên của máy tính không phải là vô hạn, vậy nên ta phải biết tiết kiệm. Ngoài ra các thuật toán của đệ quy cũng khó giải thích và bảo trì theo thời gian.\n\nVề vấn đề tài nguyên của máy tính mình đã nhấn mạnh ở hai ví dụ bên trên. Nếu hai ví dụ đó chưa đủ thuyết phục bạn về đệ quy sử dụng nhiều tài nguyên, thì hãy xem tiếp tục ví dụ bên dưới:\n\nChúng ta bắt đầu đi tính các số Fibonacci, vốn dĩ số này rất nổi tiếng vì tính thực tế của nó; Hiện trên thế giới có rất nhiều nhà thiết kế sử dụng dãy số này cho thiết kế của mình.\n\nMột dãy Fibo bắt đầu bằng 2 số 1, các số tiếp theo sẽ là tổng của 2 số đứng trước, một đoạn ngắn đầu của fibo giống thế này: 1, 1, 2, 3, 5, 8, 13, ... Số Fibo không có giới hạn.\n\nOhm, mình nghĩ bạn cũng đã có lời giải đệ quy rồi. Thế mạnh của đệ quy: đệ quy hỗ trợ định nghĩa đơn giản. Nếu chúng ta đặt tên hàm là Fibonacci, Fibonacci(n) thì trả về (return) 1 nếu n = 1 hoặc n = 2, nếu không hàm sẽ trả về giá trị của tổng Fibbonacci(n-1) + Fibbonacci(n-2).</p>\n<pre><code>unsigned long Fibonacci(unsigned n) \n{ \n    if (n &gt; 2) \n        return Fibonacci(n-1) + Fibonacci(n-2); \n    else\n        return 1; \n} \n</code></pre>\n<p>Như bạn thấy đây, Trong đệ quy này tự gọi chính nó tới 2 hàm, việc này là điểm yếu của đệ quy. Ví dụ như bạn cần tìm n = 40, đây là level 1 của đệ quy. tại Level 2 hàm này tự gọi mình 2 lần, nghĩa là cần thêm 2 vùng nhớ nữa để chứa giá trị lưu trữ; Mỗi hàm Fibbonacci(n - 1) và Fibbonacci(n - 1) lại tự gọi lại hàm nữa... Nếu là mình, mình đã thấy choáng váng ở đây vì không thể nào tính được số lần gọi hàm. Số lượng vùng nhớ này là cấp số nhân, sẽ tiếp tục tăng và tăng, tăng tới lúc vùng nhớ không còn đủ để cung cấp cho đệ quy hoạt động, và nó sẽ crash.\n\nĐây là một ví dụ đơn giản, nhưng là ví dụ nhắc nhớ cho lập trình viên cần phải cẩn trọng trong cách sử dụng đệ quy, nếu không đúng cách thì hậu quả thực sự nghiêm trọng.\n\nTất nhiên đệ quy tự gọi mình 1 lần, đệ quy kép vẫn chưa đủ thuyết phục, bạn có thể tìm tới tam đệ quy hay tứ đệ quy.</p>\n","rawBody":"\nĐây là một bài viết hay được dịch bởi @breakdown. Bài viết được lấy từ sách: \"C Primer Plus 6th Edition\"\n\n---\n\nĐệ Quy (Recursion) \n---\n \nHôm nay chúng ta sẽ quay lại với ĐỆ QUY. Thực chất đệ quy không phức tạp như mọi người nghĩ, đệ quy cũng chỉ là một hàm nhưng hàm này đặc biệt hơn những hàm khác. Hàm đệ quy tự gọi chính nó. \n \nDo cách thức đặc biệt này của đệ quy nên xảy ra rất nhiều vấn đề xung quanh đệ quy. Vấn đề đầu tiên mà mọi người nghĩ tới có lẽ sẽ là làm sao để hàm đệ quy này không gọi lại nó nữa. Chúng ta gọi việc này là điều kiện chấm dứt đệ quy. \n \nNhư chúng ta đã bàn bạc bên tr��n, đệ quy có tính chất cũng khá giống vòng lặp, và có thể sử dụng được ở mọi nơi mà vòng lặp có thể sử dụng. Đôi khi cách sử dụng vòng lặp rõ ràng và ngắn gọn, nhưng cách dùng đệ quy còn rõ ràng, ngắn gọn hơn rất nhiều. \n \nRecursion Revealed -- Tính chất \"Đảo\" của đệ quy \n---\n \nBây giờ chúng ta hãy đi sâu và xem cách thức mà một hàm đệ quy thực thi và kết quả của hàm đệ quy. \n \nTrong đoạn code bên dưới, chúng ta thấy được hàm main() sẽ gọi một hàm mang tên up_and_down. Trong bài này mình sẽ gọi đây là \"lần đầu tiên gọi hàm\". Tiếp theo đó hàm up_and_down() sẽ gọi lại chính nó với tham số truyền vào là n+1, mình sẽ gọi đây là \"lần thứ hai gọi hàm\", cứ thế tiếp tục mọi ngừoi theo cách đó nhé.  \n \nỞ trong ví dụ bên dưới, hàm up_and_down() sẽ tự gọi nó 4 lần, mình gọi mỗi lần là 1 level, cứ thế mà tăng lên. Ở trong ví dụ mình có sử dụng operation &, để hiểu rõ thêm chức năng của operation này, bạn có thể theo dõi ở các bài viết sau. Ở bài viết này mình chỉ nói sơ qua Operation & lấy địa chỉ của biến lưu trữ trong bộ nhớ máy tính. Để sử dụng operation &, trong hàm printf mình phải xuất dạng %p, nếu các bạn không thể sử dụng %p thì có thể dùng %lu hoặc %u để thay thế. \n \nChương trình recur.c \n```\n/* recur.c -- */ \n#include <stdio.h> \nvoid up_and_down(int); \nint main(void) \n{ \n    up_and_down(1); \n    return 0; \n} \nvoid up_and_down(int n) \n{ \n    printf(\"Level %d: n location %p\\n\", n, &n); // 1 \n    if (n < 4) \n        up_and_down(n+1); \n    printf(\"LEVEL %d: n location %p\\n\", n, &n); // 2 \n} \n```\n \nTrong ví dụ trên Output sẽ như thế này: \n> Level 1: n location 0x0012ff48\nLevel 2: n location 0x0012ff3c \nLevel 3: n location 0x0012ff30 \nLevel 4: n location 0x0012ff24 \nLEVEL 4: n location 0x0012ff24 \nLEVEL 3: n location 0x0012ff30 \nLEVEL 2: n location 0x0012ff3c \nLEVEL 1: n location 0x0012ff48  \n \nBây giờ chúng ta hãy bàn về cách mà đệ quy hoạt động. \n \nBan đầu, chúng ta xem trong hàm main() có lời gọi hàm up_and_down() với tham số truyền vào là 1 ( up_and_down(1) ). Vậy nghĩa là n trong hàm up_and_down() sẽ bằng 1.  \nNhư đã nói bên trên, mình sẽ gọi đây là Level 1, để xác nhận gọi hàm thành công, mình sẽ in ra dòng Level 1: n location 0x0012ff48 nhờ câu lệnh: `printf(\"Level %d: n location %p\\n\", n, &n);`. Tiếp tới máy sẽ tiếp tục chạy câu lệnh tiếp theo là câu lệnh `if (n < 4)`; Tại câu lệnh này, máy sẽ xét điều kiện n có nhỏ hơn 4 không, nếu đúng thì sẽ tiếp tục gọi hàm `up_and_down(n+1);`. Tại đây như các bạn đã thấy, hàm `up_and_down(n);` gọi `up_and_down(n+1);`. hay có thể gọi `up_and_down(2);` do `n = 1, n + 1 =2`. Lần này mình sẽ gọi đây là lần gọi hàm thứ hai (hay Level 2). \n \nỞ Level 2, do cùng cách thức hoạt động nên hàm này sẽ thực thi giống như trên mình đã nói, và sẽ gọi tiếp hàm thứ 3, hàm thứ 4...(gọi là Level 3, Level 4). Trong đoạn code này  mình chỉ giới hạn đệ quy gọi hàm 4 lần, vậy tại Level 4 sẽ kết thúc gọi hàm (điều kiện if sai nên không còn lời gọi hàm nữa \n) \n \nVậy là tới đây chúng ta đã giải quyết 1/2 chặn đường của Output rồi. Khi code chạy tới đây thì Output sẽ giống thế này: \n \n> Level 1: n location 0x0012ff48 \nLevel 2: n location 0x0012ff3c \nLevel 3: n location 0x0012ff30 \nLevel 4: n location 0x0012ff24 \n------ket qua chay toi day------- \nLEVEL 4: n location 0x0012ff24 \nLEVEL 3: n location 0x0012ff30 \nLEVEL 2: n location 0x0012ff3c \nLEVEL 1: n location 0x0012ff48  \n \nVậy tại sao trong OUTPUT của chươn trình lại còn có thêm kết quả bên dưới. Đây là vấn đề của đệ quy, khi chạy tới bên trên thì đệ quy up_and_down() vẫn chưa hết nhiệm vụ của nó. Hãy xem lại đệ quy còn 1 đoạn chương trình bên dưới nữa: \n \n```\nif (n < 4) \nup_and_down(n+1); \nprintf(\"LEVEL %d: n location %p\\n\", n, &n); // 2 \n```\n \nChúng ta quay lại giá trị n tại Level 4. Lúc này n đang giữ giá trị là 4, vậy nghĩa là điều kiện if trong hàm up_and_down() không còn đúng nữa, vì thế chúng ta không còn lời gọi hàm nào nữa ở đây. Chúng ta đều biết chương trình là một tập các lệnh dành cho máy tính, máy tính thực thi các lệnh từ trên xuống dưới và không bỏ xót lệnh nào. Vì thế khi chạy tới Level 4 thì máy tính cũng  mới chỉ chạy xong lệnh `up_and_down(n+1)`, và lúc này vẫn còn `printf(\"LEVEL %d: n location %p\\n\", n, &n);`. \n \nKhi Level 4 không còn lời gọi hàm, thì nó còn 1 lệnh in, và máy tính sẽ thực hiện lệnh in này. Đó là nguyên nhân tại sao Level 4 lại được in 2 lần, vì trước tiên máy sẽ in `//1` và sau đó máy sẽ in `//2`. Thế là kết thúc Level 4. \n \nNhưng hãy tưởng tượng, khi bạn sử dụng một hàm bình thường, cái bạn cần là \"trả trị\", đệ quy cũng thế. Level 1 gọi Level 2, chờ level 2 trả trị về, level 2 gọi level 3 chờ level 3 trả trị về, level 3 gọi level 4 chờ level 4 trả trị về... Cứ tiếp thế. Vậy nghĩa là hàm a gọi hàm b thì phải chờ hàm b thực thi xong và \"trả trị\" về và hàm a mới có thể tiếp tục thực hiện các câu lệnh tiếp theo trong hàm. \n \nTrở về quá trình hoạt động của hàm up_and_down(), chúng ta nhớ ra rằng các level của đệ quy trước đó chỉ mới thực hiện tới `up_and_down(n+1)` và nó còn 1 dòng lệnh cuối cùng nữa `printf(\"LEVEL %d: n location %p\\n\", n, &n);`. Vì thế nên khi đệ quy Level 4 thực thi xong, \"quyền kiểm soát\" sẽ được giao cho Level 3, level 3 lại thực hiện lệnh in cuối cùng và trả quyền này về level 2, level 2 trả về level 1 và level 1 trả về main() rồi kết thúc chương trình. \n \nLưu ý rằng mỗi level của đệ quy đều sử dụng biến private n. Thông qua địa chỉ của biến n thì ta có thể gọi n (phần này liên quan đến con trỏ pointer nên mình không đề cập ở đây). Ở mỗi hệ thống thì địa chỉ này có thể khác nhau.  \n \nOhm, Nếu cái lý giải bên trên khó hiểu với bạn, thì hãy thử tưởng tượng; Bạn cài đặt các hàm như ham1(), ham2(), ham3(), ham4() với nội dung sau đây: \n \n```\nint ham1(){ ham2(); printf(\"hello, im in level 1!!!!\\n\"); return 0;} \nint ham2(){ ham3(); printf(\"hello, im in level 2!!!!\\n\"); return 0;} \nint ham3(){ ham4(); printf(\"hello, im in level 3!!!!\\n\"); return 0;} \nint ham4(){ printf(\"hello, im in level 4!!!!\\n\");return 0;} \n \nint main(){ ham1(); return 0;} \n```\n \nKết quả nhận được: \n \n> hello, im in level 4!!!! \nhello, im in level 3!!!! \nhello, im in level 2!!!! \nhello, im in level 1!!!! \n \nNhư chúng ta thấy cách thức của các hàm ham1-4 rất giống cách thức hoạt động của đệ quy. Đệ quy thực sự chỉ là cách viết gọn của 4 ham có cùng cách thức hoạt động thôi.  \n \nNguyên tắc cơ bản của đệ quy \n---\n \nChúng ta đã biết cách thức hoạt động của đê quy, nếu bạn là người mới biết sử dụng đệ quy, bạn sẽ thấy đệ quy khá là khó để sử dụng và cũng khá rắc rối để hiểu. Bây giờ mình sẽ đưa ra một vấn đề chủ chốt của đệ quy. \n \nĐầu tiên, như đã nói bên trên, Đệ quy là hàm tự gọi nó, và nó sẽ cứ thế cho tới khi một điều kiện nào đó thỏa. Như ở ví dụ trên, khi n >= 4 thì sẽ không có lời gọi hàm đệ quy nào nữa. Nhưng tại sao n lại bằng 4? Tất nhiên là do trong mỗi lần đệ quy, chúng ta tăng n lên 1 và cứ thế n sẽ là bằng 4. Như cách mình đã nói bên trên, mỗi hàm \"sẽ chờ\" hàm được gọi thực thi xong thì hàm đó mới thực thi tiếp. Vậy nghĩa là phải có \"một chỗ nào đó\" chứa biến số n. Đó là nguyên nhân tại sao biến số n lại có 4 địa chỉ khác nhau trong OUTPUT. \n \nBây gườ chúng ta hãy xem 4 biến số đó như thế nào. \n \n``` \n        variables:                |    n     n     n     n \nafter level 1 call                |    1                 \nafter level 2 call                |    1    2         \nafter level 3 call                |    1    2    3     \nafter level 4 call                |    1    2    3    4     \n after return from level 4        |    1    2    3     \n after return from level 3        |    1    2         \n after return from level 2        |    1             \n after return from level 1        |\n```\nCũng khá dễ tưởng tượng đúng không nào? Vậy tại sao 1 biến số n mà có tới 4 giá trị, máy tính lưu trữ ra sao. Mình sẽ bàn tiếp trong bài tới. Bài này chỉ để đệ quy thôi nhé. \n \nThứ hai, trong mỗi lần gọi hàm thì hàm được gọi sẽ trả trị (chúng ta hay gọi là return). Cứ thế thì level 4 sẽ trả trị về level 3, 3 trả về 2, 2 trả về 1, 1 trả về main(). Chúng ta không thể trả vượt cấp ngay về main() được. \n \nThứ ba, hàm đệ quy thực hiện theo điều kiện, điều kiện nào đến trước sẽ được thực hiện trước, điều kiện nào đến sau sẽ thực hiện sau, mình đã giải thích bên trên.  \n \nThứ tư, điều kiện được gọi sau khi gọi hàm đệ quy sẽ được thực hiện khi hàm đệ quy đó nhận được trị trả về của hàm đệ quy nó gọi. Ví dụ, điều kiện in ở #2 được thực hiện sau khi quá trình gọi hàm đệ quy kết thúc và được thực thi thông qua các lệnh: Level 4, Level 3, Level2, Level1. Chức năng này của đệ quy thực sự hữu dụng trong các chương trình phải xử lý các tiến trình liên quan đến revelsals. \n \nThứ năm, mặc dầu mỗi Level của đệ quy có biến của riêng nó, nhưng code thì lại được dùng chung. Code là một chuỗi các hướng dẫn cho máy tính, và lời gọi hàm đơn giản di chuyển đến điểm bắt đầu của chuỗi các hướng dẫn đó. Ngoài việc tạo ra biến riếng cho mỗi lần gọi hàm, đệ quy giống như vòng lặp. Thực tế, đôi khi đệ quy có thể được dùng thay cho vòng lặp và ngược lại. \n \nCuối cùng, hàm đệ quy phải có một điều kiện để ngăn chặn tiến trình gọi hàm. Thông thường các lập trình viên sử dụng if else. Để làm việc này, mỗi lần gọi đệ quy ta phải đưa vào một tham số khác với tham số trước đó (như ở trên là n và n + 1). Trong ví dụ trên các tham số được đưa vào mỗi lần gọi hàm là 1, 2, 3, 4; Bạn có thể xem lại bảng variable bên trên để hiểu rõ thêm.  \n \nĐệ quy Đuôi---Tail Recursion\n---\n \nCách đơn giản để sử dụng một hàm đệ quy là sử dụng nó ngay return statement. Đây được gọi là đệ quy đuôi, có thể gọi là tail recursion hay end recursion. Đệ quy đuôi là một cách đơn giản và nó hoạt động khá giống vòng lặp. \n \nỞ ví dụ dưới đây, mình sẽ làm một bài toán tính giá trị giai thừa của một số; Ví dụ 3! = 1 * 2 * 3 \n \n```\n// factor.c \n#include <stdio.h> \nlong fact(int n); \nlong rfact(int n); \nint main(void) \n{ \n    int num; \n    printf(\"This program calculates factorials.\\n\"); \n    printf(\"Enter a value in the range 0-12 (q to quit):\\n\"); \n    while (scanf(\"%d\", &num) == 1) \n    { \n        if (num < 0) \n            printf(\"No negative numbers, please.\\n\"); \n        else if (num > 12) \n            printf(\"Keep input under 13.\\n\"); \n        else \n        { \n            printf(\"loop: %d factorial = %ld\\n\", \n                    num, fact(num)); \n            printf(\"recursion: %d factorial = %ld\\n\", \n                    num, rfact(num)); \n        } \n        printf(\"Enter a value in the range 0-12 (q to quit):\\n\"); \n    } \n    printf(\"Bye.\\n\"); \n    return 0; \n} \nlong fact(int n) \n{ \n    long ans; \n    // loop-based function \n    for (ans = 1; n > 1; n--) \n        ans *= n; \n    return ans; \n} \nlong rfact(int n) // recursive version \n{ \n    long ans; \n    if (n > 0) \n        ans= n * rfact(n-1); \n    else \n        ans = 1; \n    return ans; \n} \n```\n \nChương trình này của mình chỉ giới hạn nhập số interger có giá trị giao động từ 0 tới 12. Vì giá trị của 12! lên tới nữa tỉ, giá trị này thực sự lớn hơn kiểu long của máy tính, và nếu như bạn muốn sử dụng số lớn hơn 12! thì bạn chắc phải dùng kiểu double hoặc long long. \n \nDưới đây là kết quả sau khi kết thúc chương trình trên: \n> This program calculates factorials. \nEnter a value in the range 0-12 (q to quit): \n5 \nloop: 5 factorial = 120 \nrecursion: 5 factorial = 120 \nEnter a value in the range 0-12 (q to quit): \n10 \nloop: 10 factorial = 3628800 \nrecursion: 10 factorial = 3628800 \nEnter a value in the range 0-12 (q to quit): \nq \nBye.  \n \nỞ hàm mình sử dụng vòng lặp, máu tính sẽ khởi tạo một biến tên ans = 1, sau đó nhân với các số nguyên từ 2 tới n (hoặc từ n về 2 - nói chính xác là thế). Về mặt kỹ thuật thì phải từ n về 1, nhưng số nào nhân với 1 cũng sẽ bằng chính nó, việc này trở lên vô nghĩa trong lập trình. \n \nBây giờ hãy xem cách mà đệ quy thực hiện. Hướng làm khi tính giai thừa của một số n! là n! = n * (n -1)!. \n \nHãy xem ví dụ sau: \n```\n3!  = 3 * (3-1)! \n    = 3 * 2!\n```\nTa xem \n```\n2!  = 2 * (2 - 1)! \n    = 2 * 1! \n```\nTa có `1! = 1`\n \nVậy có đúng là `3! = 3 * 2 * 1.`\n \nQuay trở lại vấn đề, ta thấy được công thức này là cách để chúng ta tiếp cận và sử dụng đệ quy trong bài toán tìm số giai thừa. Bên trên mình đã khai báo một hàm `rfact()`, chúng ta chỉ cần truyền vào 1 tham số n, vậy có nghĩa là chúng ta sẽ sử dụng hàm `rfact` thế này: `n * rfact(n - 1)` \n \nNhư các bạn thấy đấy, cả 2 cách dùng vòng lặp hoặc đệ quy đều cho ra kết quả như nhau. Nhưng nhớ rằng `rfact()` không phải là statement cuối cùng trong hàm đệ quy, nó chỉ là statement cuối cùng trong hàm if (n > 0), và nó là tail recursion. \n \nVậy có một câu hỏi vui đặt ra là thế này: \"Nếu sử dụng được cả hai cách bạn sẽ sử dụng cách nào?\". Thông thường, sử dụng vòng lặp là cách được khuyến khích hơn. Vậy tại sao cách này lại được khuyến khích hơn; Chúng ta cùng phân tích bên dưới. \n \nTrở về bảng Variable bên trên, chỉ qua 4 lần gọi hàm, chúng ta cần tốn 4 ô nhớ để chứa 4 biến với 4 giá trị khác nhau. Đệ quy lưu trữ giá trị trong stack, và bộ nhớ stack là có giới hạn. Nếu 4 ô nhớ này chưa đủ thuyết phục bạn, hãy xem tiếp ví dụ mình sẽ nêu bên dưới. \n \nThứ hai, đệ quy có tốc độ chậm hơn, việc gọi và xử lý, lưu trữ giá trị... của hàm làm tiêu tốn rất nhiều thời gian. \n \nVà bây giờ, bạn đang tự đặt ra câu hỏi là: \"Tại sao lại đưa ra ví dụ trên?\". Tất nhiên là ví dụ trên là cách đơn giản nhất để giảng giải như thế nào là \"tail recursion\".  \n \n \nĐệ quy và Reversal \n---\n \nReversal, hay còn gọi là tính đảo ngược. Đây là một vấn đề khá thú vị trong đệ quy. Chúng ta hãy cùng thảo luận. \n \nMình đưa ra một yêu cầu thế này: \"Hãy viết hàm chuyển số thập phân về nhị phân\". Đây là một vấn đề mà ai là lập trình viên đều biết, thực sự rất đơn giản, nhưng qua yêu cầu này chúnng ta có thể thấy được tính đảo ngược này có ích như thế nào. \n \n```\n/* binary.c -- prints integer in binary form */ \n#include <stdio.h> \nvoid to_binary(unsigned long n); \nint main(void) \n{ \n    unsigned long number; \n    printf(\"Enter an integer (q to quit):\\n\"); \n    while (scanf(\"%lu\", &number) == 1) \n    { \n        printf(\"Binary equivalent: \"); \n        to_binary(number); \n        putchar('\\n'); \n        printf(\"Enter an integer (q to quit):\\n\"); \n    } \n    printf(\"Done.\\n\"); \n    return 0; \n} \nvoid to_binary(unsigned long n) \n{ \n    int r; /* recursive function */ \n    r = n % 2; \n    if (n >= 2) \n        to_binary(n / 2); \n    putchar(r == 0 ? '0' : '1'); \n    return; \n} \n```\n \nỞ đây mình đã xây dựng một hàm to_binary(), ở hàm này sẽ xét r = n % 2, hàm sẽ hiển thị  một ký tự '0' nếu trị r là 0 và hiển thị '1' nếu giá trị r là 1. Biểu thức r == 0 ? '0' : '1' cung cấp phương thức này, giải nghĩa ra ta có thể hiểu rằng: xét r có bằng 0 không, nếu r = 0 thì in ra 0, nếu r !=0 thì in ra 1. Các phương thức tính toán binary thì mình không bàn tới, vì đây là cơ bản. \n \nBên dưới đây là kết quả sau khi chạy chương trình: \n> Enter an integer (q to quit): \n9 \nBinary equivalent: 1001 \nEnter an integer (q to quit): \n255 \nBinary equivalent: 11111111 \nEnter an integer (q to quit): \n1024 \nBinary equivalent: 10000000000 \nEnter an integer (q to quit): \nq \ndone.  \n \nLiệu bạn có thể sử dụng vòng lặp để tính binary? Tất nhiên là được, nhưng bạn cần phải lưu trữ từng giá trị n % 2 trong một nơi nào đó, một mảng chẳng hạn. \n \nTất nhiên trong hàm đệ quy có nhiều vấn đề rắc rối mình đã đề cập bên trên. Việc không quản lý được số lần gọi đệ quy sẽ làm hao tốn rất nhiều bộ nhớ và tài nguyên máy tính. Trong ví dụ này, nếu con số muốn chuyển qua binary lên tới nữa tỉ như 12! bên trên, thì gọi đệ quy thực sự là nhức đầu khi mà máy tính phải lưu trữ rất nhiều nhiều giá trị r... Và tất nhiên cách sử dụng mảng để lưu trữ cùng vòng lặp cũng nhức đầu không kém. Quan trọng bạn phải biết cách sử dụng cái nào tốt hơn. \n \nRecursion Pros and Cons  \n---\n \nCó lẽ đệ quy không được đánh giá cao chỉ do một lý do duy nhất: Sử dụng quá nhiều tài nguyên máy tính. Tài nguyên của máy tính không phải là vô hạn, vậy nên ta phải biết tiết kiệm. Ngoài ra các thuật toán của đệ quy cũng khó giải thích và bảo trì theo thời gian. \n \nVề vấn đề tài nguyên của máy tính mình đã nhấn mạnh ở hai ví dụ bên trên. Nếu hai ví dụ đó chưa đủ thuyết phục bạn về đệ quy sử dụng nhiều tài nguyên, thì hãy xem tiếp tục ví dụ bên dưới: \n \nChúng ta bắt đầu đi tính các số Fibonacci, vốn dĩ số này rất nổi tiếng vì tính thực tế của nó; Hiện trên thế giới có rất nhiều nhà thiết kế sử dụng dãy số này cho thiết kế của mình. \n \nMột dãy Fibo bắt đầu bằng 2 số 1, các số tiếp theo sẽ là tổng của 2 số đứng trước, một đoạn ngắn đầu của fibo giống thế này: 1, 1, 2, 3, 5, 8, 13, ... Số Fibo không có giới hạn. \n \nOhm, mình nghĩ bạn cũng đã có lời giải đệ quy rồi. Thế mạnh của đệ quy: đệ quy hỗ trợ định nghĩa đơn giản. Nếu chúng ta đặt tên hàm là Fibonacci, Fibonacci(n) thì trả về (return) 1 nếu n = 1 hoặc n = 2, nếu không hàm sẽ trả về giá trị của tổng Fibbonacci(n-1) + Fibbonacci(n-2). \n \n```\nunsigned long Fibonacci(unsigned n) \n{ \n    if (n > 2) \n        return Fibonacci(n-1) + Fibonacci(n-2); \n    else\n        return 1; \n} \n```\n \nNhư bạn thấy đây, Trong đệ quy này tự gọi chính nó tới 2 hàm, việc này là điểm yếu của đệ quy. Ví dụ như bạn cần tìm n = 40, đây là level 1 của đệ quy. tại Level 2 hàm này tự gọi mình 2 lần, nghĩa là cần thêm 2 vùng nhớ nữa để chứa giá trị lưu trữ; Mỗi hàm Fibbonacci(n - 1) và Fibbonacci(n - 1) lại tự gọi lại hàm nữa... Nếu là mình, mình đã thấy choáng váng ở đây vì không thể nào tính được số lần gọi hàm. Số lượng vùng nhớ này là cấp số nhân, sẽ tiếp tục tăng và tăng, tăng tới lúc vùng nhớ không còn đủ để cung cấp cho đệ quy hoạt động, và nó sẽ crash. \n \nĐây là một ví dụ đơn giản, nhưng là ví dụ nhắc nhớ cho lập trình viên cần phải cẩn trọng trong cách sử dụng đệ quy, nếu không đúng cách thì hậu quả thực sự nghiêm trọng. \n \nTất nhiên đệ quy tự gọi mình 1 lần, đệ quy kép vẫn chưa đủ thuyết phục, bạn có thể tìm tới tam đệ quy hay tứ đệ quy.\n","raw":"---json\n{\"id\":5719,\"layout\":\"Post\",\"route\":\"de-quy-dich-boi-breakdown\",\"title\":\"Đệ quy - dịch bởi @breakdown\",\"tags\":null,\"date\":\"2015-04-09T07:06:07.833Z\"}\n---\n\nĐây là một bài viết hay được dịch bởi @breakdown. Bài viết được lấy từ sách: \"C Primer Plus 6th Edition\"\n\n---\n\nĐệ Quy (Recursion) \n---\n \nHôm nay chúng ta sẽ quay lại với ĐỆ QUY. Thực chất đệ quy không phức tạp như mọi người nghĩ, đệ quy cũng chỉ là một hàm nhưng hàm này đặc biệt hơn những hàm khác. Hàm đệ quy tự gọi chính nó. \n \nDo cách thức đặc biệt này của đệ quy nên xảy ra rất nhiều vấn đề xung quanh đệ quy. Vấn đề đầu tiên mà mọi người nghĩ tới có lẽ sẽ là làm sao để hàm đệ quy này không gọi lại nó nữa. Chúng ta gọi việc này là điều kiện chấm dứt đệ quy. \n \nNhư chúng ta đã bàn bạc bên tr��n, đệ quy có tính chất cũng khá giống vòng lặp, và có thể sử dụng được ở mọi nơi mà vòng lặp có thể sử dụng. Đôi khi cách sử dụng vòng lặp rõ ràng và ngắn gọn, nhưng cách dùng đệ quy còn rõ ràng, ngắn gọn hơn rất nhiều. \n \nRecursion Revealed -- Tính chất \"Đảo\" của đệ quy \n---\n \nBây giờ chúng ta hãy đi sâu và xem cách thức mà một hàm đệ quy thực thi và kết quả của hàm đệ quy. \n \nTrong đoạn code bên dưới, chúng ta thấy được hàm main() sẽ gọi một hàm mang tên up_and_down. Trong bài này mình sẽ gọi đây là \"lần đầu tiên gọi hàm\". Tiếp theo đó hàm up_and_down() sẽ gọi lại chính nó với tham số truyền vào là n+1, mình sẽ gọi đây là \"lần thứ hai gọi hàm\", cứ thế tiếp tục mọi ngừoi theo cách đó nhé.  \n \nỞ trong ví dụ bên dưới, hàm up_and_down() sẽ tự gọi nó 4 lần, mình gọi mỗi lần là 1 level, cứ thế mà tăng lên. Ở trong ví dụ mình có sử dụng operation &, để hiểu rõ thêm chức năng của operation này, bạn có thể theo dõi ở các bài viết sau. Ở bài viết này mình chỉ nói sơ qua Operation & lấy địa chỉ của biến lưu trữ trong bộ nhớ máy tính. Để sử dụng operation &, trong hàm printf mình phải xuất dạng %p, nếu các bạn không thể sử dụng %p thì có thể dùng %lu hoặc %u để thay thế. \n \nChương trình recur.c \n```\n/* recur.c -- */ \n#include <stdio.h> \nvoid up_and_down(int); \nint main(void) \n{ \n    up_and_down(1); \n    return 0; \n} \nvoid up_and_down(int n) \n{ \n    printf(\"Level %d: n location %p\\n\", n, &n); // 1 \n    if (n < 4) \n        up_and_down(n+1); \n    printf(\"LEVEL %d: n location %p\\n\", n, &n); // 2 \n} \n```\n \nTrong ví dụ trên Output sẽ như thế này: \n> Level 1: n location 0x0012ff48\nLevel 2: n location 0x0012ff3c \nLevel 3: n location 0x0012ff30 \nLevel 4: n location 0x0012ff24 \nLEVEL 4: n location 0x0012ff24 \nLEVEL 3: n location 0x0012ff30 \nLEVEL 2: n location 0x0012ff3c \nLEVEL 1: n location 0x0012ff48  \n \nBây giờ chúng ta hãy bàn về cách mà đệ quy hoạt động. \n \nBan đầu, chúng ta xem trong hàm main() có lời gọi hàm up_and_down() với tham số truyền vào là 1 ( up_and_down(1) ). Vậy nghĩa là n trong hàm up_and_down() sẽ bằng 1.  \nNhư đã nói bên trên, mình sẽ gọi đây là Level 1, để xác nhận gọi hàm thành công, mình sẽ in ra dòng Level 1: n location 0x0012ff48 nhờ câu lệnh: `printf(\"Level %d: n location %p\\n\", n, &n);`. Tiếp tới máy sẽ tiếp tục chạy câu lệnh tiếp theo là câu lệnh `if (n < 4)`; Tại câu lệnh này, máy sẽ xét điều kiện n có nhỏ hơn 4 không, nếu đúng thì sẽ tiếp tục gọi hàm `up_and_down(n+1);`. Tại đây như các bạn đã thấy, hàm `up_and_down(n);` gọi `up_and_down(n+1);`. hay có thể gọi `up_and_down(2);` do `n = 1, n + 1 =2`. Lần này mình sẽ gọi đây là lần gọi hàm thứ hai (hay Level 2). \n \nỞ Level 2, do cùng cách thức hoạt động nên hàm này sẽ thực thi giống như trên mình đã nói, và sẽ gọi tiếp hàm thứ 3, hàm thứ 4...(gọi là Level 3, Level 4). Trong đoạn code này  mình chỉ giới hạn đệ quy gọi hàm 4 lần, vậy tại Level 4 sẽ kết thúc gọi hàm (điều kiện if sai nên không còn lời gọi hàm nữa \n) \n \nVậy là tới đây chúng ta đã giải quyết 1/2 chặn đường của Output rồi. Khi code chạy tới đây thì Output sẽ giống thế này: \n \n> Level 1: n location 0x0012ff48 \nLevel 2: n location 0x0012ff3c \nLevel 3: n location 0x0012ff30 \nLevel 4: n location 0x0012ff24 \n------ket qua chay toi day------- \nLEVEL 4: n location 0x0012ff24 \nLEVEL 3: n location 0x0012ff30 \nLEVEL 2: n location 0x0012ff3c \nLEVEL 1: n location 0x0012ff48  \n \nVậy tại sao trong OUTPUT của chươn trình lại còn có thêm kết quả bên dưới. Đây là vấn đề của đệ quy, khi chạy tới bên trên thì đệ quy up_and_down() vẫn chưa hết nhiệm vụ của nó. Hãy xem lại đệ quy còn 1 đoạn chương trình bên dưới nữa: \n \n```\nif (n < 4) \nup_and_down(n+1); \nprintf(\"LEVEL %d: n location %p\\n\", n, &n); // 2 \n```\n \nChúng ta quay lại giá trị n tại Level 4. Lúc này n đang giữ giá trị là 4, vậy nghĩa là điều kiện if trong hàm up_and_down() không còn đúng nữa, vì thế chúng ta không còn lời gọi hàm nào nữa ở đây. Chúng ta đều biết chương trình là một tập các lệnh dành cho máy tính, máy tính thực thi các lệnh từ trên xuống dưới và không bỏ xót lệnh nào. Vì thế khi chạy tới Level 4 thì máy tính cũng  mới chỉ chạy xong lệnh `up_and_down(n+1)`, và lúc này vẫn còn `printf(\"LEVEL %d: n location %p\\n\", n, &n);`. \n \nKhi Level 4 không còn lời gọi hàm, thì nó còn 1 lệnh in, và máy tính sẽ thực hiện lệnh in này. Đó là nguyên nhân tại sao Level 4 lại được in 2 lần, vì trước tiên máy sẽ in `//1` và sau đó máy sẽ in `//2`. Thế là kết thúc Level 4. \n \nNhưng hãy tưởng tượng, khi bạn sử dụng một hàm bình thường, cái bạn cần là \"trả trị\", đệ quy cũng thế. Level 1 gọi Level 2, chờ level 2 trả trị về, level 2 gọi level 3 chờ level 3 trả trị về, level 3 gọi level 4 chờ level 4 trả trị về... Cứ tiếp thế. Vậy nghĩa là hàm a gọi hàm b thì phải chờ hàm b thực thi xong và \"trả trị\" về và hàm a mới có thể tiếp tục thực hiện các câu lệnh tiếp theo trong hàm. \n \nTrở về quá trình hoạt động của hàm up_and_down(), chúng ta nhớ ra rằng các level của đệ quy trước đó chỉ mới thực hiện tới `up_and_down(n+1)` và nó còn 1 dòng lệnh cuối cùng nữa `printf(\"LEVEL %d: n location %p\\n\", n, &n);`. Vì thế nên khi đệ quy Level 4 thực thi xong, \"quyền kiểm soát\" sẽ được giao cho Level 3, level 3 lại thực hiện lệnh in cuối cùng và trả quyền này về level 2, level 2 trả về level 1 và level 1 trả về main() rồi kết thúc chương trình. \n \nLưu ý rằng mỗi level của đệ quy đều sử dụng biến private n. Thông qua địa chỉ của biến n thì ta có thể gọi n (phần này liên quan đến con trỏ pointer nên mình không đề cập ở đây). Ở mỗi hệ thống thì địa chỉ này có thể khác nhau.  \n \nOhm, Nếu cái lý giải bên trên khó hiểu với bạn, thì hãy thử tưởng tượng; Bạn cài đặt các hàm như ham1(), ham2(), ham3(), ham4() với nội dung sau đây: \n \n```\nint ham1(){ ham2(); printf(\"hello, im in level 1!!!!\\n\"); return 0;} \nint ham2(){ ham3(); printf(\"hello, im in level 2!!!!\\n\"); return 0;} \nint ham3(){ ham4(); printf(\"hello, im in level 3!!!!\\n\"); return 0;} \nint ham4(){ printf(\"hello, im in level 4!!!!\\n\");return 0;} \n \nint main(){ ham1(); return 0;} \n```\n \nKết quả nhận được: \n \n> hello, im in level 4!!!! \nhello, im in level 3!!!! \nhello, im in level 2!!!! \nhello, im in level 1!!!! \n \nNhư chúng ta thấy cách thức của các hàm ham1-4 rất giống cách thức hoạt động của đệ quy. Đệ quy thực sự chỉ là cách viết gọn của 4 ham có cùng cách thức hoạt động thôi.  \n \nNguyên tắc cơ bản của đệ quy \n---\n \nChúng ta đã biết cách thức hoạt động của đê quy, nếu bạn là người mới biết sử dụng đệ quy, bạn sẽ thấy đệ quy khá là khó để sử dụng và cũng khá rắc rối để hiểu. Bây giờ mình sẽ đưa ra một vấn đề chủ chốt của đệ quy. \n \nĐầu tiên, như đã nói bên trên, Đệ quy là hàm tự gọi nó, và nó sẽ cứ thế cho tới khi một điều kiện nào đó thỏa. Như ở ví dụ trên, khi n >= 4 thì sẽ không có lời gọi hàm đệ quy nào nữa. Nhưng tại sao n lại bằng 4? Tất nhiên là do trong mỗi lần đệ quy, chúng ta tăng n lên 1 và cứ thế n sẽ là bằng 4. Như cách mình đã nói bên trên, mỗi hàm \"sẽ chờ\" hàm được gọi thực thi xong thì hàm đó mới thực thi tiếp. Vậy nghĩa là phải có \"một chỗ nào đó\" chứa biến số n. Đó là nguyên nhân tại sao biến số n lại có 4 địa chỉ khác nhau trong OUTPUT. \n \nBây gườ chúng ta hãy xem 4 biến số đó như thế nào. \n \n``` \n        variables:                |    n     n     n     n \nafter level 1 call                |    1                 \nafter level 2 call                |    1    2         \nafter level 3 call                |    1    2    3     \nafter level 4 call                |    1    2    3    4     \n after return from level 4        |    1    2    3     \n after return from level 3        |    1    2         \n after return from level 2        |    1             \n after return from level 1        |\n```\nCũng khá dễ tưởng tượng đúng không nào? Vậy tại sao 1 biến số n mà có tới 4 giá trị, máy tính lưu trữ ra sao. Mình sẽ bàn tiếp trong bài tới. Bài này chỉ để đệ quy thôi nhé. \n \nThứ hai, trong mỗi lần gọi hàm thì hàm được gọi sẽ trả trị (chúng ta hay gọi là return). Cứ thế thì level 4 sẽ trả trị về level 3, 3 trả về 2, 2 trả về 1, 1 trả về main(). Chúng ta không thể trả vượt cấp ngay về main() được. \n \nThứ ba, hàm đệ quy thực hiện theo điều kiện, điều kiện nào đến trước sẽ được thực hiện trước, điều kiện nào đến sau sẽ thực hiện sau, mình đã giải thích bên trên.  \n \nThứ tư, điều kiện được gọi sau khi gọi hàm đệ quy sẽ được thực hiện khi hàm đệ quy đó nhận được trị trả về của hàm đệ quy nó gọi. Ví dụ, điều kiện in ở #2 được thực hiện sau khi quá trình gọi hàm đệ quy kết thúc và được thực thi thông qua các lệnh: Level 4, Level 3, Level2, Level1. Chức năng này của đệ quy thực sự hữu dụng trong các chương trình phải xử lý các tiến trình liên quan đến revelsals. \n \nThứ năm, mặc dầu mỗi Level của đệ quy có biến của riêng nó, nhưng code thì lại được dùng chung. Code là một chuỗi các hướng dẫn cho máy tính, và lời gọi hàm đơn giản di chuyển đến điểm bắt đầu của chuỗi các hướng dẫn đó. Ngoài việc tạo ra biến riếng cho mỗi lần gọi hàm, đệ quy giống như vòng lặp. Thực tế, đôi khi đệ quy có thể được dùng thay cho vòng lặp và ngược lại. \n \nCuối cùng, hàm đệ quy phải có một điều kiện để ngăn chặn tiến trình gọi hàm. Thông thường các lập trình viên sử dụng if else. Để làm việc này, mỗi lần gọi đệ quy ta phải đưa vào một tham số khác với tham số trước đó (như ở trên là n và n + 1). Trong ví dụ trên các tham số được đưa vào mỗi lần gọi hàm là 1, 2, 3, 4; Bạn có thể xem lại bảng variable bên trên để hiểu rõ thêm.  \n \nĐệ quy Đuôi---Tail Recursion\n---\n \nCách đơn giản để sử dụng một hàm đệ quy là sử dụng nó ngay return statement. Đây được gọi là đệ quy đuôi, có thể gọi là tail recursion hay end recursion. Đệ quy đuôi là một cách đơn giản và nó hoạt động khá giống vòng lặp. \n \nỞ ví dụ dưới đây, mình sẽ làm một bài toán tính giá trị giai thừa của một số; Ví dụ 3! = 1 * 2 * 3 \n \n```\n// factor.c \n#include <stdio.h> \nlong fact(int n); \nlong rfact(int n); \nint main(void) \n{ \n    int num; \n    printf(\"This program calculates factorials.\\n\"); \n    printf(\"Enter a value in the range 0-12 (q to quit):\\n\"); \n    while (scanf(\"%d\", &num) == 1) \n    { \n        if (num < 0) \n            printf(\"No negative numbers, please.\\n\"); \n        else if (num > 12) \n            printf(\"Keep input under 13.\\n\"); \n        else \n        { \n            printf(\"loop: %d factorial = %ld\\n\", \n                    num, fact(num)); \n            printf(\"recursion: %d factorial = %ld\\n\", \n                    num, rfact(num)); \n        } \n        printf(\"Enter a value in the range 0-12 (q to quit):\\n\"); \n    } \n    printf(\"Bye.\\n\"); \n    return 0; \n} \nlong fact(int n) \n{ \n    long ans; \n    // loop-based function \n    for (ans = 1; n > 1; n--) \n        ans *= n; \n    return ans; \n} \nlong rfact(int n) // recursive version \n{ \n    long ans; \n    if (n > 0) \n        ans= n * rfact(n-1); \n    else \n        ans = 1; \n    return ans; \n} \n```\n \nChương trình này của mình chỉ giới hạn nhập số interger có giá trị giao động từ 0 tới 12. Vì giá trị của 12! lên tới nữa tỉ, giá trị này thực sự lớn hơn kiểu long của máy tính, và nếu như bạn muốn sử dụng số lớn hơn 12! thì bạn chắc phải dùng kiểu double hoặc long long. \n \nDưới đây là kết quả sau khi kết thúc chương trình trên: \n> This program calculates factorials. \nEnter a value in the range 0-12 (q to quit): \n5 \nloop: 5 factorial = 120 \nrecursion: 5 factorial = 120 \nEnter a value in the range 0-12 (q to quit): \n10 \nloop: 10 factorial = 3628800 \nrecursion: 10 factorial = 3628800 \nEnter a value in the range 0-12 (q to quit): \nq \nBye.  \n \nỞ hàm mình sử dụng vòng lặp, máu tính sẽ khởi tạo một biến tên ans = 1, sau đó nhân với các số nguyên từ 2 tới n (hoặc từ n về 2 - nói chính xác là thế). Về mặt kỹ thuật thì phải từ n về 1, nhưng số nào nhân với 1 cũng sẽ bằng chính nó, việc này trở lên vô nghĩa trong lập trình. \n \nBây giờ hãy xem cách mà đệ quy thực hiện. Hướng làm khi tính giai thừa của một số n! là n! = n * (n -1)!. \n \nHãy xem ví dụ sau: \n```\n3!  = 3 * (3-1)! \n    = 3 * 2!\n```\nTa xem \n```\n2!  = 2 * (2 - 1)! \n    = 2 * 1! \n```\nTa có `1! = 1`\n \nVậy có đúng là `3! = 3 * 2 * 1.`\n \nQuay trở lại vấn đề, ta thấy được công thức này là cách để chúng ta tiếp cận và sử dụng đệ quy trong bài toán tìm số giai thừa. Bên trên mình đã khai báo một hàm `rfact()`, chúng ta chỉ cần truyền vào 1 tham số n, vậy có nghĩa là chúng ta sẽ sử dụng hàm `rfact` thế này: `n * rfact(n - 1)` \n \nNhư các bạn thấy đấy, cả 2 cách dùng vòng lặp hoặc đệ quy đều cho ra kết quả như nhau. Nhưng nhớ rằng `rfact()` không phải là statement cuối cùng trong hàm đệ quy, nó chỉ là statement cuối cùng trong hàm if (n > 0), và nó là tail recursion. \n \nVậy có một câu hỏi vui đặt ra là thế này: \"Nếu sử dụng được cả hai cách bạn sẽ sử dụng cách nào?\". Thông thường, sử dụng vòng lặp là cách được khuyến khích hơn. Vậy tại sao cách này lại được khuyến khích hơn; Chúng ta cùng phân tích bên dưới. \n \nTrở về bảng Variable bên trên, chỉ qua 4 lần gọi hàm, chúng ta cần tốn 4 ô nhớ để chứa 4 biến với 4 giá trị khác nhau. Đệ quy lưu trữ giá trị trong stack, và bộ nhớ stack là có giới hạn. Nếu 4 ô nhớ này chưa đủ thuyết phục bạn, hãy xem tiếp ví dụ mình sẽ nêu bên dưới. \n \nThứ hai, đệ quy có tốc độ chậm hơn, việc gọi và xử lý, lưu trữ giá trị... của hàm làm tiêu tốn rất nhiều thời gian. \n \nVà bây giờ, bạn đang tự đặt ra câu hỏi là: \"Tại sao lại đưa ra ví dụ trên?\". Tất nhiên là ví dụ trên là cách đơn giản nhất để giảng giải như thế nào là \"tail recursion\".  \n \n \nĐệ quy và Reversal \n---\n \nReversal, hay còn gọi là tính đảo ngược. Đây là một vấn đề khá thú vị trong đệ quy. Chúng ta hãy cùng thảo luận. \n \nMình đưa ra một yêu cầu thế này: \"Hãy viết hàm chuyển số thập phân về nhị phân\". Đây là một vấn đề mà ai là lập trình viên đều biết, thực sự rất đơn giản, nhưng qua yêu cầu này chúnng ta có thể thấy được tính đảo ngược này có ích như thế nào. \n \n```\n/* binary.c -- prints integer in binary form */ \n#include <stdio.h> \nvoid to_binary(unsigned long n); \nint main(void) \n{ \n    unsigned long number; \n    printf(\"Enter an integer (q to quit):\\n\"); \n    while (scanf(\"%lu\", &number) == 1) \n    { \n        printf(\"Binary equivalent: \"); \n        to_binary(number); \n        putchar('\\n'); \n        printf(\"Enter an integer (q to quit):\\n\"); \n    } \n    printf(\"Done.\\n\"); \n    return 0; \n} \nvoid to_binary(unsigned long n) \n{ \n    int r; /* recursive function */ \n    r = n % 2; \n    if (n >= 2) \n        to_binary(n / 2); \n    putchar(r == 0 ? '0' : '1'); \n    return; \n} \n```\n \nỞ đây mình đã xây dựng một hàm to_binary(), ở hàm này sẽ xét r = n % 2, hàm sẽ hiển thị  một ký tự '0' nếu trị r là 0 và hiển thị '1' nếu giá trị r là 1. Biểu thức r == 0 ? '0' : '1' cung cấp phương thức này, giải nghĩa ra ta có thể hiểu rằng: xét r có bằng 0 không, nếu r = 0 thì in ra 0, nếu r !=0 thì in ra 1. Các phương thức tính toán binary thì mình không bàn tới, vì đây là cơ bản. \n \nBên dưới đây là kết quả sau khi chạy chương trình: \n> Enter an integer (q to quit): \n9 \nBinary equivalent: 1001 \nEnter an integer (q to quit): \n255 \nBinary equivalent: 11111111 \nEnter an integer (q to quit): \n1024 \nBinary equivalent: 10000000000 \nEnter an integer (q to quit): \nq \ndone.  \n \nLiệu bạn có thể sử dụng vòng lặp để tính binary? Tất nhiên là được, nhưng bạn cần phải lưu trữ từng giá trị n % 2 trong một nơi nào đó, một mảng chẳng hạn. \n \nTất nhiên trong hàm đệ quy có nhiều vấn đề rắc rối mình đã đề cập bên trên. Việc không quản lý được số lần gọi đệ quy sẽ làm hao tốn rất nhiều bộ nhớ và tài nguyên máy tính. Trong ví dụ này, nếu con số muốn chuyển qua binary lên tới nữa tỉ như 12! bên trên, thì gọi đệ quy thực sự là nhức đầu khi mà máy tính phải lưu trữ rất nhiều nhiều giá trị r... Và tất nhiên cách sử dụng mảng để lưu trữ cùng vòng lặp cũng nhức đầu không kém. Quan trọng bạn phải biết cách sử dụng cái nào tốt hơn. \n \nRecursion Pros and Cons  \n---\n \nCó lẽ đệ quy không được đánh giá cao chỉ do một lý do duy nhất: Sử dụng quá nhiều tài nguyên máy tính. Tài nguyên của máy tính không phải là vô hạn, vậy nên ta phải biết tiết kiệm. Ngoài ra các thuật toán của đệ quy cũng khó giải thích và bảo trì theo thời gian. \n \nVề vấn đề tài nguyên của máy tính mình đã nhấn mạnh ở hai ví dụ bên trên. Nếu hai ví dụ đó chưa đủ thuyết phục bạn về đệ quy sử dụng nhiều tài nguyên, thì hãy xem tiếp tục ví dụ bên dưới: \n \nChúng ta bắt đầu đi tính các số Fibonacci, vốn dĩ số này rất nổi tiếng vì tính thực tế của nó; Hiện trên thế giới có rất nhiều nhà thiết kế sử dụng dãy số này cho thiết kế của mình. \n \nMột dãy Fibo bắt đầu bằng 2 số 1, các số tiếp theo sẽ là tổng của 2 số đứng trước, một đoạn ngắn đầu của fibo giống thế này: 1, 1, 2, 3, 5, 8, 13, ... Số Fibo không có giới hạn. \n \nOhm, mình nghĩ bạn cũng đã có lời giải đệ quy rồi. Thế mạnh của đệ quy: đệ quy hỗ trợ định nghĩa đơn giản. Nếu chúng ta đặt tên hàm là Fibonacci, Fibonacci(n) thì trả về (return) 1 nếu n = 1 hoặc n = 2, nếu không hàm sẽ trả về giá trị của tổng Fibbonacci(n-1) + Fibbonacci(n-2). \n \n```\nunsigned long Fibonacci(unsigned n) \n{ \n    if (n > 2) \n        return Fibonacci(n-1) + Fibonacci(n-2); \n    else\n        return 1; \n} \n```\n \nNhư bạn thấy đây, Trong đệ quy này tự gọi chính nó tới 2 hàm, việc này là điểm yếu của đệ quy. Ví dụ như bạn cần tìm n = 40, đây là level 1 của đệ quy. tại Level 2 hàm này tự gọi mình 2 lần, nghĩa là cần thêm 2 vùng nhớ nữa để chứa giá trị lưu trữ; Mỗi hàm Fibbonacci(n - 1) và Fibbonacci(n - 1) lại tự gọi lại hàm nữa... Nếu là mình, mình đã thấy choáng váng ở đây vì không thể nào tính được số lần gọi hàm. Số lượng vùng nhớ này là cấp số nhân, sẽ tiếp tục tăng và tăng, tăng tới lúc vùng nhớ không còn đủ để cung cấp cho đệ quy hoạt động, và nó sẽ crash. \n \nĐây là một ví dụ đơn giản, nhưng là ví dụ nhắc nhớ cho lập trình viên cần phải cẩn trọng trong cách sử dụng đệ quy, nếu không đúng cách thì hậu quả thực sự nghiêm trọng. \n \nTất nhiên đệ quy tự gọi mình 1 lần, đệ quy kép vẫn chưa đủ thuyết phục, bạn có thể tìm tới tam đệ quy hay tứ đệ quy.\n","__filename":"posts/5719.md","__url":"/de-quy-dich-boi-breakdown/","__resourceUrl":"/de-quy-dich-boi-breakdown/index.html","__dataUrl":"/de-quy-dich-boi-breakdown/index.html.15aed1e5698c2fa892d2ebf575c2c14a.json","type":"Post"}}}</script><script src="/dnh-blog/manifest.ae561172dce0bdff882e.js"></script><script src="/dnh-blog/statinamic-bundle.ddb866315dc127da0a97.js"></script><script src="/dnh-blog/statinamic-client.6055a92d909952c94679.js"></script></body></html>