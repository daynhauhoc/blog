{"head":{"id":8832,"layout":"Post","route":"gioi-thieu-decorator-trong-python","title":"Giới thiệu decorator trong Python","tags":["decorator","python"],"date":"2015-06-27T10:37:34.715Z","description":"\\##1. Decorator là gì?\n\nDecorator là một mẫu thiết kế (Design pattern) thường được dùng để thay đổi hành vi, chức năng của hàm(function)…"},"body":"<p>##1. Decorator là gì?</p>\n<p>Decorator là một mẫu thiết kế (Design pattern) thường được dùng để thay đổi hành vi, chức năng của hàm(function) hoặc lớp (class) mà không cần phải thay đổi code của hàm hoặc lớp.\nTham khảo\nPython hỗ trợ cú pháp (syntax) cho Decorator từ version 2.4\nVề cơ bản Decorator giống như một lớp vỏ bọc (wrapper), nó thay đổi hành vi(behavior) của code trước và sau khi gọi hàm chính (hàm được decorate).</p>\n<p>##2. Decorator được dùng làm gì?</p>\n<p>Tại sao chúng ta cần Decorator?</p>\n<p>Cho phép tái sử dụng code.\nMở rộng các hàm, hoặc lớp mà không cần phải thay đổi code có sẵn —&gt; không cần test lại.\nVí dụ trong chương trình của bạn bạn cần kiểm tra quyền (permission) của người dùng trước khi thực hiện hàm. Bạn có thể phải thêm code vào tất cả các hàm đã có để kiểm tra. Thay vào đó với decorator, bạn chỉ cần định nghĩa một decorator và khai báo nó trước hàm.</p>\n<p>##3. Làm sao để định nghĩa một decorator?</p>\n<p>Decorator cũng là một hàm chỉ khác là hàm decorator nhận vào một hàm và kết quả trả về của nó là hàm sau khi được decorate.\nNhư vậy để định nghĩa một decorator chỉ đơn giản là định nghĩa một hàm nhận vào một hàm khác và trả về một hàm mới có prototype tương đương với hàm nhận vào.</p>\n<p><strong>Ví dụ 1:</strong></p>\n<pre><code class=\"hljs language-python\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">ten_decorator</span><span class=\"hljs-params\">(f)</span>:</span>\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">wrapper</span><span class=\"hljs-params\">(ten)</span>:</span>\n          chuoi_moi = <span class=\"hljs-string\">\"Ten tui la %s\"</span> % ten\n          <span class=\"hljs-keyword\">return</span> f(chuoi_moi)\n      <span class=\"hljs-keyword\">return</span> wrapper\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">xuat_ten</span><span class=\"hljs-params\">( ten )</span>:</span>\n<span class=\"hljs-keyword\">print</span> ten</code></pre>\n<p><strong>CHÚ Ý QUAN TRỌNG</strong>: hàm wrapper và hàm f phải có tham số phù hợp với nhau. Ví dụ như hàm f nhận vào chỉ 2 tham số thì hàm decorator không thể nhận vào 3 tham số hoặc 1 tham số.</p>\n<p>##4. Sử dụng decorator như thế nào?</p>\n<p>Sử dụng Decorator hết sức đơn giản. Sử dụng decorator trong ví dụ trên cho hàm xuat_ten như sau:</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-meta\">@ten_decorator</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">xuat_ten</span><span class=\"hljs-params\">(ten)</span>:</span>\n  <span class=\"hljs-keyword\">print</span> ten</code></pre>\n<p>Dùng dấu @ để thông báo đó là một decorator. Một hàm có thể dùng nhiều decorator cùng lúc:</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-meta\">@ten_decorator1</span>\n<span class=\"hljs-meta\">@ten_decorator2</span>\n<span class=\"hljs-meta\">@ten_decorator3</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">xuat_ten</span><span class=\"hljs-params\">(ten)</span>:</span>\n  <span class=\"hljs-keyword\">print</span> ten</code></pre>\n<p>##5. Decorator hoạt động như thế nào?</p>\n<p>Như trong ví dụ ở trên:</p>\n<p>ten_decorator nhận vào hàm f, sau đó bọc hàm f trong hàm wrapper của nó và trả về hàm wrapper. Hàm wrapper có nhiệm vụ gắn thêm thông tin vào tên rồi mới gọi thực hiện hàm f với chuỗi mới.\nViệc sử dụng:</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-meta\"> @ten_decorator</span>\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">xuat_ten</span><span class=\"hljs-params\">(ten)</span>:</span>\n     <span class=\"hljs-keyword\">print</span> ten\n xuat_ten(<span class=\"hljs-string\">'coulson'</span>)\nTương đương với:\n\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">xuat_ten</span><span class=\"hljs-params\">(ten)</span>:</span>\n     <span class=\"hljs-keyword\">print</span> ten\n ham_xuat_ten_moi = ten_decorator(xuat_ten)\n ham_xuat_ten_moi(<span class=\"hljs-string\">'coulson'</span>)</code></pre>\n<p>Rõ ràng với việc sử dụng cú pháp decorator thì code sẽ ngắn gọn và đơn giản hơn. Developer không phải gọi decorator mỗi lần sử dụng mà trình thông dịch sẽ làm việc đó.\nĐối với hàm sử dụng nhiều decorator</p>\n<p><strong>Ví dụ 2</strong></p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-meta\">@ten_decorator1</span>\n<span class=\"hljs-meta\">@ten_decorator2</span>\n<span class=\"hljs-meta\">@ten_decorator3</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">xuat_ten</span><span class=\"hljs-params\">(ten)</span>:</span>\n    <span class=\"hljs-keyword\">print</span> ten</code></pre>\n<p>Decorator nào càng ở trên, xa function thì sẽ bọc lớp ngoài Giống như khi bạn bọc trái xoài vào trong bị, rồi lại lấy cái bị khác để bọc bên ngoài nữa.\nThứ tự thực thi code:\nCode của decorator được thực thi ngay lúc file nguồn Python được load lên. Ngoại trừ code trong hàm wrapper của decorator trong cùng sẽ được thực thi lúc gọi hàm.\nDecorator được gọi thực thi theo thứ tự từ trong (gần hàm nhất) ra ngoài.</p>\n<p>##6 Truyền tham số cho decorator</p>\n<p>Ở trên, để cho đơn giản, và dễ hiểu thì decorator là một hàm có tham số là một hàm khác. Nhưng điều đó không bắt buộc, decorator cũng có thể là một hàm nhận vào tham số bất kỳ và trả về một hàm và hàm trả về này nhận vào tham số là một hàm khác.</p>\n<p><strong>Ví dụ 3</strong>: thêm chức danh vào chuỗi xuất ra mình có thể định nghĩa decorator như sau:</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">chuc_danh_decorator</span><span class=\"hljs-params\">(ten_chuc_danh)</span>:</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">ten_decorator</span><span class=\"hljs-params\">(f)</span>:</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">wrapper</span><span class=\"hljs-params\">(ten)</span>:</span>\n            chuoi_moi = <span class=\"hljs-string\">\"Xin gioi thieu %s %s\"</span> % (ten_chuc_danh, ten)\n            <span class=\"hljs-keyword\">return</span> f(chuoi_moi)\n        <span class=\"hljs-keyword\">return</span> wrapper\n    <span class=\"hljs-keyword\">return</span> ten_decorator\n<span class=\"hljs-meta\">@chuc_danh_decorator(\"Giao su\")</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">gioi_thieu</span><span class=\"hljs-params\">(ten)</span>:</span>\n<span class=\"hljs-keyword\">print</span> ten\n\n<span class=\"hljs-meta\">@chuc_danh_decorator(\"Tien si\")</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">gioi_thieu_2</span><span class=\"hljs-params\">(ten)</span>:</span>\n<span class=\"hljs-keyword\">print</span> ten\n\ngioi_thieu(<span class=\"hljs-string\">\"Teo\"</span>)\ngioi_thieu_2(<span class=\"hljs-string\">\"Ti\"</span>)\n\n&gt;&gt; Xin gioi thieu Giao su Teo\n&gt;&gt; Xin gioi thieu Tien si Ti</code></pre>\n<p>Sự khác biệt:</p>\n<p>Hàm decorator bây giờ không phải nhận vào tham số là một hàm mà có thể là tham số bất kỳ.\nHàm trả về từ decorator nhận vào một hàm và chính nó mới trả về hàm wrapper\nCách sử dụng decorator cũng khác một chút. Decorator được gọi chạy ( dùng dấu () ) và truyền vào tham số.\nNó chạy như thế nào:</p>\n<p>Trong ví dụ 3 decorator được sử dụng @chuc_danh_decorator(&quot;Giao su&quot;). Chú ý dấu (…), decorator được gọi thực thi và nó trả về hàm ten_decorator và chính nó sẽ bọc hàm được decorate.\nHàm chuc_danh_decorator chỉ có tác dụng là dùng để truyền tham số vào decorator.</p>\n<p>##7. Debug hàm decorator.</p>\n<p>Khi sử dụng decorator thì hàm thực sự được gọi là hàm wrapper của trả về từ decorator. Nên các thuộc tính <strong>name</strong>, <strong>doc</strong>, <strong>module</strong> không còn là của hàm được decorate nữa mà là của wrapper</p>\n<p>Sử dụng lại code trong ví dụ 1:</p>\n<pre><code class=\"hljs language-python\"> <span class=\"hljs-keyword\">print</span> xuat_ten.__name__\n&gt;&gt; wrapper</code></pre>\n<p>Khắc phục: sử dụng thư viện functools\nVí dụ 4:</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> functools <span class=\"hljs-keyword\">import</span> wraps\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">ten_decorator</span><span class=\"hljs-params\">(f)</span>:</span>\n<span class=\"hljs-meta\">@wraps(f)</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">wrapper</span><span class=\"hljs-params\">(ten)</span>:</span>\nchuoi_moi = <span class=\"hljs-string\">\"Ten tui la %s\"</span> % ten\n<span class=\"hljs-keyword\">return</span> f(chuoi_moi)\n<span class=\"hljs-keyword\">return</span> wrapper\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">xuat_ten</span><span class=\"hljs-params\">( ten )</span>:</span>\n<span class=\"hljs-keyword\">print</span> ten\n\n<span class=\"hljs-keyword\">print</span> xuat_ten.__name__\n\n&gt;&gt; xuat_ten</code></pre>\n<p>Decorator wraps sẽ lấy các thuộc tính <strong>name</strong>, <strong>doc</strong>, <strong>module</strong> của hàm được decorate và gán cho hàm wrapper nên khi lấy những thuộc tính này sẽ trả về thông tin đúng.</p>\n<p>##8. Khi nào nên sử dụng decorator?</p>\n<p>Tham khảo trang <a href=\"https://wiki.python.org/moin/PythonDecoratorLibrary\">Wiki</a> của Python</p>\n<p>Tui mới tập viết blog, bác nào rảnh cho ý kiến nhé <a href=\"http://kebano.net/\">http://kebano.net/</a></p>\n","rawBody":"\n##1. Decorator là gì?\n\nDecorator là một mẫu thiết kế (Design pattern) thường được dùng để thay đổi hành vi, chức năng của hàm(function) hoặc lớp (class) mà không cần phải thay đổi code của hàm hoặc lớp.\nTham khảo\nPython hỗ trợ cú pháp (syntax) cho Decorator từ version 2.4\nVề cơ bản Decorator giống như một lớp vỏ bọc (wrapper), nó thay đổi hành vi(behavior) của code trước và sau khi gọi hàm chính (hàm được decorate).\n\n##2. Decorator được dùng làm gì?\n\nTại sao chúng ta cần Decorator?\n\nCho phép tái sử dụng code.\nMở rộng các hàm, hoặc lớp mà không cần phải thay đổi code có sẵn —> không cần test lại.\nVí dụ trong chương trình của bạn bạn cần kiểm tra quyền (permission) của người dùng trước khi thực hiện hàm. Bạn có thể phải thêm code vào tất cả các hàm đã có để kiểm tra. Thay vào đó với decorator, bạn chỉ cần định nghĩa một decorator và khai báo nó trước hàm.\n\n##3. Làm sao để định nghĩa một decorator?\n\nDecorator cũng là một hàm chỉ khác là hàm decorator nhận vào một hàm và kết quả trả về của nó là hàm sau khi được decorate.\nNhư vậy để định nghĩa một decorator chỉ đơn giản là định nghĩa một hàm nhận vào một hàm khác và trả về một hàm mới có prototype tương đương với hàm nhận vào.\n\n**Ví dụ 1:**\n```python\n  def ten_decorator(f):\n      def wrapper(ten):\n          chuoi_moi = \"Ten tui la %s\" % ten\n          return f(chuoi_moi)\n      return wrapper\n\ndef xuat_ten( ten ):\nprint ten\n```\n**CHÚ Ý QUAN TRỌNG**: hàm wrapper và hàm f phải có tham số phù hợp với nhau. Ví dụ như hàm f nhận vào chỉ 2 tham số thì hàm decorator không thể nhận vào 3 tham số hoặc 1 tham số.\n \n\n##4. Sử dụng decorator như thế nào?\n\nSử dụng Decorator hết sức đơn giản. Sử dụng decorator trong ví dụ trên cho hàm xuat_ten như sau:\n```python\n@ten_decorator\ndef xuat_ten(ten):\n  print ten\n```\nDùng dấu @ để thông báo đó là một decorator. Một hàm có thể dùng nhiều decorator cùng lúc:\n```python\n@ten_decorator1\n@ten_decorator2\n@ten_decorator3\ndef xuat_ten(ten):\n  print ten\n```\n##5. Decorator hoạt động như thế nào?\n\nNhư trong ví dụ ở trên:\n\nten_decorator nhận vào hàm f, sau đó bọc hàm f trong hàm wrapper của nó và trả về hàm wrapper. Hàm wrapper có nhiệm vụ gắn thêm thông tin vào tên rồi mới gọi thực hiện hàm f với chuỗi mới.\nViệc sử dụng:\n```python\n @ten_decorator\n def xuat_ten(ten):\n     print ten\n xuat_ten('coulson')\nTương đương với:\n\n def xuat_ten(ten):\n     print ten\n ham_xuat_ten_moi = ten_decorator(xuat_ten)\n ham_xuat_ten_moi('coulson')\n```\nRõ ràng với việc sử dụng cú pháp decorator thì code sẽ ngắn gọn và đơn giản hơn. Developer không phải gọi decorator mỗi lần sử dụng mà trình thông dịch sẽ làm việc đó.\nĐối với hàm sử dụng nhiều decorator\n\n**Ví dụ 2**\n```python\n@ten_decorator1\n@ten_decorator2\n@ten_decorator3\ndef xuat_ten(ten):\n    print ten\n```\nDecorator nào càng ở trên, xa function thì sẽ bọc lớp ngoài Giống như khi bạn bọc trái xoài vào trong bị, rồi lại lấy cái bị khác để bọc bên ngoài nữa.\nThứ tự thực thi code:\nCode của decorator được thực thi ngay lúc file nguồn Python được load lên. Ngoại trừ code trong hàm wrapper của decorator trong cùng sẽ được thực thi lúc gọi hàm.\nDecorator được gọi thực thi theo thứ tự từ trong (gần hàm nhất) ra ngoài.\n\n##6 Truyền tham số cho decorator\n\nỞ trên, để cho đơn giản, và dễ hiểu thì decorator là một hàm có tham số là một hàm khác. Nhưng điều đó không bắt buộc, decorator cũng có thể là một hàm nhận vào tham số bất kỳ và trả về một hàm và hàm trả về này nhận vào tham số là một hàm khác.\n\n**Ví dụ 3**: thêm chức danh vào chuỗi xuất ra mình có thể định nghĩa decorator như sau:\n```python\ndef chuc_danh_decorator(ten_chuc_danh):\n    def ten_decorator(f):\n        def wrapper(ten):\n            chuoi_moi = \"Xin gioi thieu %s %s\" % (ten_chuc_danh, ten)\n            return f(chuoi_moi)\n        return wrapper\n    return ten_decorator\n@chuc_danh_decorator(\"Giao su\")\ndef gioi_thieu(ten):\nprint ten\n\n@chuc_danh_decorator(\"Tien si\")\ndef gioi_thieu_2(ten):\nprint ten\n\ngioi_thieu(\"Teo\")\ngioi_thieu_2(\"Ti\")\n\n>> Xin gioi thieu Giao su Teo\n>> Xin gioi thieu Tien si Ti\n```\nSự khác biệt:\n\nHàm decorator bây giờ không phải nhận vào tham số là một hàm mà có thể là tham số bất kỳ.\nHàm trả về từ decorator nhận vào một hàm và chính nó mới trả về hàm wrapper\nCách sử dụng decorator cũng khác một chút. Decorator được gọi chạy ( dùng dấu () ) và truyền vào tham số.\nNó chạy như thế nào:\n\nTrong ví dụ 3 decorator được sử dụng @chuc_danh_decorator(\"Giao su\"). Chú ý dấu (…), decorator được gọi thực thi và nó trả về hàm ten_decorator và chính nó sẽ bọc hàm được decorate.\nHàm chuc_danh_decorator chỉ có tác dụng là dùng để truyền tham số vào decorator.\n\n##7. Debug hàm decorator.\n\nKhi sử dụng decorator thì hàm thực sự được gọi là hàm wrapper của trả về từ decorator. Nên các thuộc tính __name__, __doc__, __module__ không còn là của hàm được decorate nữa mà là của wrapper\n\nSử dụng lại code trong ví dụ 1:\n```python\n print xuat_ten.__name__\n>> wrapper\n```\n\nKhắc phục: sử dụng thư viện functools\nVí dụ 4:\n```python\nfrom functools import wraps\ndef ten_decorator(f):\n@wraps(f)\ndef wrapper(ten):\nchuoi_moi = \"Ten tui la %s\" % ten\nreturn f(chuoi_moi)\nreturn wrapper\n\ndef xuat_ten( ten ):\nprint ten\n\nprint xuat_ten.__name__\n\n>> xuat_ten\n```\nDecorator wraps sẽ lấy các thuộc tính __name__, __doc__, __module__ của hàm được decorate và gán cho hàm wrapper nên khi lấy những thuộc tính này sẽ trả về thông tin đúng.\n\n##8. Khi nào nên sử dụng decorator?\n\nTham khảo trang [Wiki](https://wiki.python.org/moin/PythonDecoratorLibrary) của Python\n\n\nTui mới tập viết blog, bác nào rảnh cho ý kiến nhé [http://kebano.net/](http://kebano.net/)\n","raw":"---json\n{\"id\":8832,\"layout\":\"Post\",\"route\":\"gioi-thieu-decorator-trong-python\",\"title\":\"Giới thiệu decorator trong Python\",\"tags\":[\"decorator\",\"python\"],\"date\":\"2015-06-27T10:37:34.715Z\"}\n---\n\n##1. Decorator là gì?\n\nDecorator là một mẫu thiết kế (Design pattern) thường được dùng để thay đổi hành vi, chức năng của hàm(function) hoặc lớp (class) mà không cần phải thay đổi code của hàm hoặc lớp.\nTham khảo\nPython hỗ trợ cú pháp (syntax) cho Decorator từ version 2.4\nVề cơ bản Decorator giống như một lớp vỏ bọc (wrapper), nó thay đổi hành vi(behavior) của code trước và sau khi gọi hàm chính (hàm được decorate).\n\n##2. Decorator được dùng làm gì?\n\nTại sao chúng ta cần Decorator?\n\nCho phép tái sử dụng code.\nMở rộng các hàm, hoặc lớp mà không cần phải thay đổi code có sẵn —> không cần test lại.\nVí dụ trong chương trình của bạn bạn cần kiểm tra quyền (permission) của người dùng trước khi thực hiện hàm. Bạn có thể phải thêm code vào tất cả các hàm đã có để kiểm tra. Thay vào đó với decorator, bạn chỉ cần định nghĩa một decorator và khai báo nó trước hàm.\n\n##3. Làm sao để định nghĩa một decorator?\n\nDecorator cũng là một hàm chỉ khác là hàm decorator nhận vào một hàm và kết quả trả về của nó là hàm sau khi được decorate.\nNhư vậy để định nghĩa một decorator chỉ đơn giản là định nghĩa một hàm nhận vào một hàm khác và trả về một hàm mới có prototype tương đương với hàm nhận vào.\n\n**Ví dụ 1:**\n```python\n  def ten_decorator(f):\n      def wrapper(ten):\n          chuoi_moi = \"Ten tui la %s\" % ten\n          return f(chuoi_moi)\n      return wrapper\n\ndef xuat_ten( ten ):\nprint ten\n```\n**CHÚ Ý QUAN TRỌNG**: hàm wrapper và hàm f phải có tham số phù hợp với nhau. Ví dụ như hàm f nhận vào chỉ 2 tham số thì hàm decorator không thể nhận vào 3 tham số hoặc 1 tham số.\n \n\n##4. Sử dụng decorator như thế nào?\n\nSử dụng Decorator hết sức đơn giản. Sử dụng decorator trong ví dụ trên cho hàm xuat_ten như sau:\n```python\n@ten_decorator\ndef xuat_ten(ten):\n  print ten\n```\nDùng dấu @ để thông báo đó là một decorator. Một hàm có thể dùng nhiều decorator cùng lúc:\n```python\n@ten_decorator1\n@ten_decorator2\n@ten_decorator3\ndef xuat_ten(ten):\n  print ten\n```\n##5. Decorator hoạt động như thế nào?\n\nNhư trong ví dụ ở trên:\n\nten_decorator nhận vào hàm f, sau đó bọc hàm f trong hàm wrapper của nó và trả về hàm wrapper. Hàm wrapper có nhiệm vụ gắn thêm thông tin vào tên rồi mới gọi thực hiện hàm f với chuỗi mới.\nViệc sử dụng:\n```python\n @ten_decorator\n def xuat_ten(ten):\n     print ten\n xuat_ten('coulson')\nTương đương với:\n\n def xuat_ten(ten):\n     print ten\n ham_xuat_ten_moi = ten_decorator(xuat_ten)\n ham_xuat_ten_moi('coulson')\n```\nRõ ràng với việc sử dụng cú pháp decorator thì code sẽ ngắn gọn và đơn giản hơn. Developer không phải gọi decorator mỗi lần sử dụng mà trình thông dịch sẽ làm việc đó.\nĐối với hàm sử dụng nhiều decorator\n\n**Ví dụ 2**\n```python\n@ten_decorator1\n@ten_decorator2\n@ten_decorator3\ndef xuat_ten(ten):\n    print ten\n```\nDecorator nào càng ở trên, xa function thì sẽ bọc lớp ngoài Giống như khi bạn bọc trái xoài vào trong bị, rồi lại lấy cái bị khác để bọc bên ngoài nữa.\nThứ tự thực thi code:\nCode của decorator được thực thi ngay lúc file nguồn Python được load lên. Ngoại trừ code trong hàm wrapper của decorator trong cùng sẽ được thực thi lúc gọi hàm.\nDecorator được gọi thực thi theo thứ tự từ trong (gần hàm nhất) ra ngoài.\n\n##6 Truyền tham số cho decorator\n\nỞ trên, để cho đơn giản, và dễ hiểu thì decorator là một hàm có tham số là một hàm khác. Nhưng điều đó không bắt buộc, decorator cũng có thể là một hàm nhận vào tham số bất kỳ và trả về một hàm và hàm trả về này nhận vào tham số là một hàm khác.\n\n**Ví dụ 3**: thêm chức danh vào chuỗi xuất ra mình có thể định nghĩa decorator như sau:\n```python\ndef chuc_danh_decorator(ten_chuc_danh):\n    def ten_decorator(f):\n        def wrapper(ten):\n            chuoi_moi = \"Xin gioi thieu %s %s\" % (ten_chuc_danh, ten)\n            return f(chuoi_moi)\n        return wrapper\n    return ten_decorator\n@chuc_danh_decorator(\"Giao su\")\ndef gioi_thieu(ten):\nprint ten\n\n@chuc_danh_decorator(\"Tien si\")\ndef gioi_thieu_2(ten):\nprint ten\n\ngioi_thieu(\"Teo\")\ngioi_thieu_2(\"Ti\")\n\n>> Xin gioi thieu Giao su Teo\n>> Xin gioi thieu Tien si Ti\n```\nSự khác biệt:\n\nHàm decorator bây giờ không phải nhận vào tham số là một hàm mà có thể là tham số bất kỳ.\nHàm trả về từ decorator nhận vào một hàm và chính nó mới trả về hàm wrapper\nCách sử dụng decorator cũng khác một chút. Decorator được gọi chạy ( dùng dấu () ) và truyền vào tham số.\nNó chạy như thế nào:\n\nTrong ví dụ 3 decorator được sử dụng @chuc_danh_decorator(\"Giao su\"). Chú ý dấu (…), decorator được gọi thực thi và nó trả về hàm ten_decorator và chính nó sẽ bọc hàm được decorate.\nHàm chuc_danh_decorator chỉ có tác dụng là dùng để truyền tham số vào decorator.\n\n##7. Debug hàm decorator.\n\nKhi sử dụng decorator thì hàm thực sự được gọi là hàm wrapper của trả về từ decorator. Nên các thuộc tính __name__, __doc__, __module__ không còn là của hàm được decorate nữa mà là của wrapper\n\nSử dụng lại code trong ví dụ 1:\n```python\n print xuat_ten.__name__\n>> wrapper\n```\n\nKhắc phục: sử dụng thư viện functools\nVí dụ 4:\n```python\nfrom functools import wraps\ndef ten_decorator(f):\n@wraps(f)\ndef wrapper(ten):\nchuoi_moi = \"Ten tui la %s\" % ten\nreturn f(chuoi_moi)\nreturn wrapper\n\ndef xuat_ten( ten ):\nprint ten\n\nprint xuat_ten.__name__\n\n>> xuat_ten\n```\nDecorator wraps sẽ lấy các thuộc tính __name__, __doc__, __module__ của hàm được decorate và gán cho hàm wrapper nên khi lấy những thuộc tính này sẽ trả về thông tin đúng.\n\n##8. Khi nào nên sử dụng decorator?\n\nTham khảo trang [Wiki](https://wiki.python.org/moin/PythonDecoratorLibrary) của Python\n\n\nTui mới tập viết blog, bác nào rảnh cho ý kiến nhé [http://kebano.net/](http://kebano.net/)\n","__filename":"posts/8832.md","__url":"/gioi-thieu-decorator-trong-python/","__resourceUrl":"/gioi-thieu-decorator-trong-python/index.html","__dataUrl":"/gioi-thieu-decorator-trong-python/index.html.55c88d81955715a24b2c81035504a642.json"}