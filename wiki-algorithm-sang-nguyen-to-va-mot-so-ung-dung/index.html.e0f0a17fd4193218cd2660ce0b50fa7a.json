{"head":{"id":3793,"layout":"Post","route":"wiki-algorithm-sang-nguyen-to-va-mot-so-ung-dung","title":"[Wiki] [Algorithm] Sàng nguyên tố và một số ứng dụng","tags":["wiki","algorithm","python","c++"],"date":"2015-02-08T03:06:06.317Z","description":"\\###Hôm nay chúng ta sẽ tìm hiểu sàng nguyên tố [Sieve of Eratosthenes][1]\n\nĐPT O(nloglogn)\n\nTư tưởng: Đánh dấu tất cả các số là bội của số…"},"body":"<p>###Hôm nay chúng ta sẽ tìm hiểu sàng nguyên tố <a href=\"http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\">Sieve of Eratosthenes</a></p>\n<h4 id=\"pt-onloglogn\"><a href=\"#pt-onloglogn\" class=\"statinamic-HeadingAnchor\">#</a>ĐPT O(nloglogn)</h4>\n<h4 id=\"t-tng-nh-du-tt-c-cc-s-l-bi-ca-s-nguyn-t-p-t-p2--n\"><a href=\"#t-tng-nh-du-tt-c-cc-s-l-bi-ca-s-nguyn-t-p-t-p2--n\" class=\"statinamic-HeadingAnchor\">#</a><em>Tư tưởng</em>: Đánh dấu tất cả các số là bội của số nguyên tố p từ p^2 -&gt;n</h4>\n<p>###<em>code python</em></p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">sieve</span><span class=\"hljs-params\">(n)</span>:</span>\n    <span class=\"hljs-string\">''' sàng nguyên tố [0,n] '''</span>\n    \n    danh_dau=[<span class=\"hljs-keyword\">True</span>]*(n+<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\"># giả sự lúc đầu đều có thể là snt</span>\n    \n    can_n=int(n**<span class=\"hljs-number\">0.5</span>)+<span class=\"hljs-number\">1</span> <span class=\"hljs-comment\"># = floor(sqrt(n))+1</span>\n    \n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span class=\"hljs-number\">2</span>,can_n+<span class=\"hljs-number\">1</span>): <span class=\"hljs-comment\"># i= 2-&gt;can_n</span>\n        <span class=\"hljs-keyword\">if</span> danh_dau[i]: <span class=\"hljs-comment\"># i là số nguyên tố</span>\n            \n            <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> range(i*i,n+<span class=\"hljs-number\">1</span>,i): <span class=\"hljs-comment\"># j=i*i, i*i+i , ...,n</span>\n                danh_dau[j]=<span class=\"hljs-keyword\">False</span> <span class=\"hljs-comment\">## j khong là số nguyên tố</span>\n    \n    \n    primes=[]\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span class=\"hljs-number\">2</span>,n+<span class=\"hljs-number\">1</span>): <span class=\"hljs-comment\">#i= 2-&gt;n</span>\n        <span class=\"hljs-keyword\">if</span> danh_dau[i]: primes.append(i) <span class=\"hljs-comment\">#liệt kê lại số nguyên tố vào mảng mới</span>\n    <span class=\"hljs-keyword\">return</span> primes\n\n<span class=\"hljs-keyword\">print</span> sieve(<span class=\"hljs-number\">100</span>)\n<span class=\"hljs-string\">\"\"\"\n#output:\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\"\"\"</span></code></pre>\n<hr>\n<h3 id=\"ng-dng-phn-tch-ra-tha-s-ngyn-t\"><a href=\"#ng-dng-phn-tch-ra-tha-s-ngyn-t\" class=\"statinamic-HeadingAnchor\">#</a>ứng dụng phân tích ra thừa số ngyên tố:</h3>\n<p>####nếu thay mảng dánh dấu không phải là [True|False] mà là mảng đánh dấu số nguyên tố trước đó</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">gen_sieve_table</span><span class=\"hljs-params\">(n)</span>:</span>\n    \n    <span class=\"hljs-string\">''' sàng nguyên tố [0,n] '''</span>\n    \n    danh_dau=[<span class=\"hljs-number\">0</span>]*(n+<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\"># giả sự lúc đầu đều có thể là snt</span>\n    \n    can_n=int(n**<span class=\"hljs-number\">0.5</span>)+<span class=\"hljs-number\">1</span> <span class=\"hljs-comment\"># = ceil(sqrt(n))+1</span>\n    \n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> range(<span class=\"hljs-number\">2</span>,can_n+<span class=\"hljs-number\">1</span>): <span class=\"hljs-comment\"># i= 2-&gt;can_n</span>\n        <span class=\"hljs-keyword\">if</span> danh_dau[i]==<span class=\"hljs-number\">0</span>: <span class=\"hljs-comment\"># i là số nguyên tố -&gt; giá trị =0 [không có ước nguyên tố nhỏ hơn #1]</span>\n            \n            <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> range(i*i,n+<span class=\"hljs-number\">1</span>,i): <span class=\"hljs-comment\"># j=i*i, i*i+i , ...,n</span>\n                danh_dau[j]=i <span class=\"hljs-comment\">## j khong là số nguyên tố</span>\n    \n    \n    <span class=\"hljs-keyword\">return</span> danh_dau\n    \n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">factor</span><span class=\"hljs-params\">(n,sieve_table)</span>:</span>\n    <span class=\"hljs-keyword\">if</span> sieve_table[n]==<span class=\"hljs-number\">0</span>: <span class=\"hljs-comment\">## là số nguyên tố trả lại ước là chính nó</span>\n        <span class=\"hljs-keyword\">return</span> [n] \n    <span class=\"hljs-keyword\">else</span>:\n        d=sieve_table[n]  <span class=\"hljs-comment\">## chứa 1 ước nguyên tố nhỏ nhất là d</span>\n        <span class=\"hljs-keyword\">return</span> [d] + factor(n//d,sieve_table)\n\nsieve_table=gen_sieve_table(<span class=\"hljs-number\">100000</span>)\n\n<span class=\"hljs-keyword\">print</span> factor(<span class=\"hljs-number\">12345</span>,sieve_table)</code></pre>\n<pre><code class=\"hljs language-python\">output:\n[5, 3, 823]</code></pre>\n<h4 id=\"c-code\"><a href=\"#c-code\" class=\"statinamic-HeadingAnchor\">#</a>C code</h4>\n<pre><code class=\"hljs language-c\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdlib.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;string.h&gt;</span></span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> maxn 1000000</span>\n\n<span class=\"hljs-keyword\">int</span> a[maxn+<span class=\"hljs-number\">1</span>];\n<span class=\"hljs-keyword\">int</span> primes[maxn],primes_len;\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">sieve</span><span class=\"hljs-params\">()</span></span>{\n    <span class=\"hljs-keyword\">int</span> i,j;\n    <span class=\"hljs-built_in\">memset</span>(a,<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-keyword\">int</span>)*(maxn+<span class=\"hljs-number\">1</span>),<span class=\"hljs-number\">0</span>);\n    <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">2</span>;i*i&lt;=maxn;++i){\n        <span class=\"hljs-keyword\">if</span>(a[i]) <span class=\"hljs-keyword\">continue</span>; <span class=\"hljs-comment\">//i la hop so</span>\n        <span class=\"hljs-keyword\">for</span>(j=i*i; j&lt;=maxn;j+=i){ <span class=\"hljs-comment\">// cac so la boi cua i tu i*i -&gt;n</span>\n            a[j]=i;  <span class=\"hljs-comment\">// cai nay luu lai so nguyen to nho nhat ma j chia het cho i</span>\n        }\n    }\n    <span class=\"hljs-comment\">/// liet ke lai so nguyen to</span>\n    \n    primes[<span class=\"hljs-number\">0</span>]=<span class=\"hljs-number\">2</span>;\n    primes_len=<span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">3</span>;i&lt;=maxn;i+=<span class=\"hljs-number\">2</span>){\n        <span class=\"hljs-keyword\">if</span>(a[i]) <span class=\"hljs-keyword\">continue</span>;\n        primes[primes_len]=i;\n        primes_len++;\n    }\n    \n}\n\n<span class=\"hljs-keyword\">int</span> ft[<span class=\"hljs-number\">50</span>],fn;\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">recrusive_factor</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span></span>{\n    <span class=\"hljs-keyword\">if</span>(!a[n]){\n        ft[fn]=n;\n        fn++;\n    }<span class=\"hljs-keyword\">else</span>{\n        recrusive_factor(n/a[n]);\n        ft[fn]=a[n];\n        ++fn;\n        \n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">factor</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span></span>{\n    fn=<span class=\"hljs-number\">0</span>;\n    recrusive_factor(n);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    \n    sieve();\n    \n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"so luong so nguyen to &lt;= (%d) = %d\\n\"</span>,maxn,primes_len);\n    <span class=\"hljs-keyword\">int</span> n=<span class=\"hljs-number\">12345</span>;\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"phan tich thua so nguyen to %d=\"</span>,n);\n    factor(n);\n    <span class=\"hljs-keyword\">int</span> i;\n    \n    <span class=\"hljs-keyword\">for</span>(i=<span class=\"hljs-number\">0</span>;i&lt;fn<span class=\"hljs-number\">-1</span>;++i){\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"%d*\"</span>,ft[i]);\n    }\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">\"%d\\n\"</span>,ft[fn<span class=\"hljs-number\">-1</span>]);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}</code></pre>\n<pre><code class=\"hljs language-python\">output:\nso luong so nguyen to &lt;= (1000000) = 78498\nphan tich thua so nguyen to 12345=823*3*5</code></pre>\n","rawBody":"\n###Hôm nay chúng ta sẽ tìm hiểu sàng nguyên tố [Sieve of Eratosthenes][1]\n\n#### ĐPT O(nloglogn)\n\n#### *Tư tưởng*: Đánh dấu tất cả các số là bội của số nguyên tố p từ p^2 ->n\n\n###*code python*\n```python\n\n\ndef sieve(n):\n    ''' sàng nguyên tố [0,n] '''\n    \n    danh_dau=[True]*(n+1) # giả sự lúc đầu đều có thể là snt\n    \n    can_n=int(n**0.5)+1 # = floor(sqrt(n))+1\n    \n    for i in range(2,can_n+1): # i= 2->can_n\n        if danh_dau[i]: # i là số nguyên tố\n            \n            for j in range(i*i,n+1,i): # j=i*i, i*i+i , ...,n\n                danh_dau[j]=False ## j khong là số nguyên tố\n    \n    \n    primes=[]\n    for i in range(2,n+1): #i= 2->n\n        if danh_dau[i]: primes.append(i) #liệt kê lại số nguyên tố vào mảng mới\n    return primes\n\nprint sieve(100)\n\"\"\"\n#output:\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\"\"\"\n```\n\n---------------------------------------\n\n### ứng dụng phân tích ra thừa số ngyên tố:\n\n####nếu thay mảng dánh dấu không phải là [True|False] mà là mảng đánh dấu số nguyên tố trước đó\n\n```python\ndef gen_sieve_table(n):\n    \n    ''' sàng nguyên tố [0,n] '''\n    \n    danh_dau=[0]*(n+1) # giả sự lúc đầu đều có thể là snt\n    \n    can_n=int(n**0.5)+1 # = ceil(sqrt(n))+1\n    \n    for i in range(2,can_n+1): # i= 2->can_n\n        if danh_dau[i]==0: # i là số nguyên tố -> giá trị =0 [không có ước nguyên tố nhỏ hơn #1]\n            \n            for j in range(i*i,n+1,i): # j=i*i, i*i+i , ...,n\n                danh_dau[j]=i ## j khong là số nguyên tố\n    \n    \n    return danh_dau\n    \n\ndef factor(n,sieve_table):\n    if sieve_table[n]==0: ## là số nguyên tố trả lại ước là chính nó\n        return [n] \n    else:\n        d=sieve_table[n]  ## chứa 1 ước nguyên tố nhỏ nhất là d\n        return [d] + factor(n//d,sieve_table)\n\nsieve_table=gen_sieve_table(100000)\n\nprint factor(12345,sieve_table)\n```\n\n```python\noutput:\n[5, 3, 823]\n```\n\n#### C code\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define maxn 1000000\n\nint a[maxn+1];\nint primes[maxn],primes_len;\nvoid sieve(){\n    int i,j;\n    memset(a,sizeof(int)*(maxn+1),0);\n    for(i=2;i*i<=maxn;++i){\n        if(a[i]) continue; //i la hop so\n        for(j=i*i; j<=maxn;j+=i){ // cac so la boi cua i tu i*i ->n\n            a[j]=i;  // cai nay luu lai so nguyen to nho nhat ma j chia het cho i\n        }\n    }\n    /// liet ke lai so nguyen to\n    \n    primes[0]=2;\n    primes_len=1;\n    for(i=3;i<=maxn;i+=2){\n        if(a[i]) continue;\n        primes[primes_len]=i;\n        primes_len++;\n    }\n    \n}\n\nint ft[50],fn;\n\nvoid recrusive_factor(int n){\n    if(!a[n]){\n        ft[fn]=n;\n        fn++;\n    }else{\n        recrusive_factor(n/a[n]);\n        ft[fn]=a[n];\n        ++fn;\n        \n    }\n}\n\nvoid factor(int n){\n    fn=0;\n    recrusive_factor(n);\n}\n\nint main() {\n    \n    sieve();\n    \n    printf(\"so luong so nguyen to <= (%d) = %d\\n\",maxn,primes_len);\n    int n=12345;\n    printf(\"phan tich thua so nguyen to %d=\",n);\n    factor(n);\n    int i;\n    \n    for(i=0;i<fn-1;++i){\n        printf(\"%d*\",ft[i]);\n    }\n    printf(\"%d\\n\",ft[fn-1]);\n    return 0;\n}\n```\n\n```python\noutput:\nso luong so nguyen to <= (1000000) = 78498\nphan tich thua so nguyen to 12345=823*3*5\n```\n  [1]: http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n","raw":"---json\n{\"id\":3793,\"layout\":\"Post\",\"route\":\"wiki-algorithm-sang-nguyen-to-va-mot-so-ung-dung\",\"title\":\"[Wiki] [Algorithm] Sàng nguyên tố và một số ứng dụng\",\"tags\":[\"wiki\",\"algorithm\",\"python\",\"c++\"],\"date\":\"2015-02-08T03:06:06.317Z\"}\n---\n\n###Hôm nay chúng ta sẽ tìm hiểu sàng nguyên tố [Sieve of Eratosthenes][1]\n\n#### ĐPT O(nloglogn)\n\n#### *Tư tưởng*: Đánh dấu tất cả các số là bội của số nguyên tố p từ p^2 ->n\n\n###*code python*\n```python\n\n\ndef sieve(n):\n    ''' sàng nguyên tố [0,n] '''\n    \n    danh_dau=[True]*(n+1) # giả sự lúc đầu đều có thể là snt\n    \n    can_n=int(n**0.5)+1 # = floor(sqrt(n))+1\n    \n    for i in range(2,can_n+1): # i= 2->can_n\n        if danh_dau[i]: # i là số nguyên tố\n            \n            for j in range(i*i,n+1,i): # j=i*i, i*i+i , ...,n\n                danh_dau[j]=False ## j khong là số nguyên tố\n    \n    \n    primes=[]\n    for i in range(2,n+1): #i= 2->n\n        if danh_dau[i]: primes.append(i) #liệt kê lại số nguyên tố vào mảng mới\n    return primes\n\nprint sieve(100)\n\"\"\"\n#output:\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n\"\"\"\n```\n\n---------------------------------------\n\n### ứng dụng phân tích ra thừa số ngyên tố:\n\n####nếu thay mảng dánh dấu không phải là [True|False] mà là mảng đánh dấu số nguyên tố trước đó\n\n```python\ndef gen_sieve_table(n):\n    \n    ''' sàng nguyên tố [0,n] '''\n    \n    danh_dau=[0]*(n+1) # giả sự lúc đầu đều có thể là snt\n    \n    can_n=int(n**0.5)+1 # = ceil(sqrt(n))+1\n    \n    for i in range(2,can_n+1): # i= 2->can_n\n        if danh_dau[i]==0: # i là số nguyên tố -> giá trị =0 [không có ước nguyên tố nhỏ hơn #1]\n            \n            for j in range(i*i,n+1,i): # j=i*i, i*i+i , ...,n\n                danh_dau[j]=i ## j khong là số nguyên tố\n    \n    \n    return danh_dau\n    \n\ndef factor(n,sieve_table):\n    if sieve_table[n]==0: ## là số nguyên tố trả lại ước là chính nó\n        return [n] \n    else:\n        d=sieve_table[n]  ## chứa 1 ước nguyên tố nhỏ nhất là d\n        return [d] + factor(n//d,sieve_table)\n\nsieve_table=gen_sieve_table(100000)\n\nprint factor(12345,sieve_table)\n```\n\n```python\noutput:\n[5, 3, 823]\n```\n\n#### C code\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define maxn 1000000\n\nint a[maxn+1];\nint primes[maxn],primes_len;\nvoid sieve(){\n    int i,j;\n    memset(a,sizeof(int)*(maxn+1),0);\n    for(i=2;i*i<=maxn;++i){\n        if(a[i]) continue; //i la hop so\n        for(j=i*i; j<=maxn;j+=i){ // cac so la boi cua i tu i*i ->n\n            a[j]=i;  // cai nay luu lai so nguyen to nho nhat ma j chia het cho i\n        }\n    }\n    /// liet ke lai so nguyen to\n    \n    primes[0]=2;\n    primes_len=1;\n    for(i=3;i<=maxn;i+=2){\n        if(a[i]) continue;\n        primes[primes_len]=i;\n        primes_len++;\n    }\n    \n}\n\nint ft[50],fn;\n\nvoid recrusive_factor(int n){\n    if(!a[n]){\n        ft[fn]=n;\n        fn++;\n    }else{\n        recrusive_factor(n/a[n]);\n        ft[fn]=a[n];\n        ++fn;\n        \n    }\n}\n\nvoid factor(int n){\n    fn=0;\n    recrusive_factor(n);\n}\n\nint main() {\n    \n    sieve();\n    \n    printf(\"so luong so nguyen to <= (%d) = %d\\n\",maxn,primes_len);\n    int n=12345;\n    printf(\"phan tich thua so nguyen to %d=\",n);\n    factor(n);\n    int i;\n    \n    for(i=0;i<fn-1;++i){\n        printf(\"%d*\",ft[i]);\n    }\n    printf(\"%d\\n\",ft[fn-1]);\n    return 0;\n}\n```\n\n```python\noutput:\nso luong so nguyen to <= (1000000) = 78498\nphan tich thua so nguyen to 12345=823*3*5\n```\n  [1]: http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n","__filename":"posts/3793.md","__url":"/wiki-algorithm-sang-nguyen-to-va-mot-so-ung-dung/","__resourceUrl":"/wiki-algorithm-sang-nguyen-to-va-mot-so-ung-dung/index.html","__dataUrl":"/wiki-algorithm-sang-nguyen-to-va-mot-so-ung-dung/index.html.e0f0a17fd4193218cd2660ce0b50fa7a.json"}