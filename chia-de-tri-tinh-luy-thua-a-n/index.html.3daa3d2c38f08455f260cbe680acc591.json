{"head":{"id":6710,"layout":"Post","route":"chia-de-tri-tinh-luy-thua-a-n","title":"[Chia để trị] Tính lũy thừa a^n","tags":["algorithm"],"date":"2015-04-30T06:20:35.807Z","description":"Giờ rảnh được chút, làm thêm một bài nữa về một thuật toán cơ bản: tính lũy thừa an bằng phương pháp chia để trị.\nChắc mọi người đa số hay…"},"body":"<p>Giờ rảnh được chút, làm thêm một bài nữa về một thuật toán cơ bản: tính lũy thừa a<sup>n</sup> bằng phương pháp chia để trị.\nChắc mọi người đa số hay dùng vòng lặp nhỉ (cứ ừ đại đi), bây giờ đổi gió xíu nhé</p>\n<p>Vào luôn vấn đề, như mọi người đã biết, a<sup>n</sup> được tính bằng cách nhân n lần số a (nói vậy cho gọn đi)\nMình lấy ví dụ:</p>\n<blockquote>\n<p>a<sup>8</sup> = a . a . a . a . a . a . a . a (8 chữ a lận nhé)</p>\n</blockquote>\n<p>Ta nhận thấy rằng có thể chia nửa cái phép tính trên kia ra, như thế này:</p>\n<blockquote>\n<p>a<sup>8</sup> = a<sup>4 + 4</sup> = a<sup>4</sup> . a<sup>4</sup></p>\n</blockquote>\n<p>trong đó, a<sup>4</sup> có thể được tính:</p>\n<blockquote>\n<p>a<sup>4</sup> = a<sup>2</sup> . a<sup>2</sup></p>\n</blockquote>\n<p>Lại một lần nữa chia nhỏ :</p>\n<blockquote>\n<p>a<sup>2</sup> = a<sup>1</sup> . a<sup>1</sup> = a . a</p>\n</blockquote>\n<p>Đến đây ra có thể dễ dàng đưa ra a (a cùng n là input của bài toán này).</p>\n<blockquote>\n<p>Vậy ta nhận ra được phần base case của thuật đệ quy ở đây (hay nhiều sách tiếng Việt gọi là phần neo ấy, mình học trên Khan nên đọc quen rồi) chính là  <strong>khi số mũ đưa về 1, ta có thể đưa thẳng ra giá trị a</strong></p>\n</blockquote>\n<ul>\n<li>Từ đó ta suy ra cách giải quyết bài toán thế này: <strong>chia nhỏ số mũ n ra cho đến khi n = 1</strong></li>\n</ul>\n<p>Vậy hàm pow với tham số : <code>int pow(int a, int n)</code>\nSẽ có phần base case:</p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-keyword\">if</span>(n == <span class=\"hljs-number\">1</span>)\n    <span class=\"hljs-keyword\">return</span> a;</code></pre>\n<p>Thế còn recursive case (phần đệ quy) ? Thì theo như ví dụ ở trên, ta có công thức:</p>\n<blockquote>\n<p>a<sup>n</sup> = a<sup>n/2</sup> . a<sup>n/2</sup></p>\n</blockquote>\n<p>Chuyển ra code:</p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">pow</span>(a, n/<span class=\"hljs-number\">2</span>) * <span class=\"hljs-built_in\">pow</span>(a, n/<span class=\"hljs-number\">2</span>);</code></pre>\n<p>Thế nhưng nếu n là một số lẻ thì sao? Ví dụ như n = 3:</p>\n<blockquote>\n<p>a<sup>5</sup> = a . a . a . a . a (1)\nThì trong trường hợp này, n/2 sẽ bằng 5/2 = 2 (do n kiểu int nên số sẽ tự bỏ đi phần thập phân)\n(1) = a<sup>2</sup> . a<sup>2</sup> . a</p>\n</blockquote>\n<p>do là số lẻ nên khi khi mod 2 (chia lấy dư) thì số dư sẽ luôn luôn là 1\n=&gt; Với n là số lẻ, khi chia ra sẽ luôn thừa một số a</p>\n<p>Vậy ta suy ra công thức:</p>\n<blockquote>\n<p>a<sup>n</sup> = a<sup>n/2</sup> . a<sup>n/2</sup> với n là số lẻ</p>\n</blockquote>\n<p>hay chuyển ra code:</p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">pow</span>(a, n/<span class=\"hljs-number\">2</span>) * <span class=\"hljs-built_in\">pow</span>(a, n/<span class=\"hljs-number\">2</span>) * a;</code></pre>\n<p>Tổng hợp lại công thức tổng quát:</p>\n<blockquote>\n<p>a<sup>n</sup> =</p>\n</blockquote>\n<ul>\n<li>a<sup>n/2</sup> * a<sup>n/2</sup> nếu n chẵn</li>\n<li>a<sup>n/2</sup> <em> a<sup>n/2</sup> </em> a nếu n lẻ</li>\n</ul>\n<p>Và cuối cùng là code, dài dòng lê thê lắm rồi:</p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">pow</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> n)</span>\n</span>{\n    <span class=\"hljs-keyword\">if</span>(n == <span class=\"hljs-number\">1</span>) {\n        <span class=\"hljs-keyword\">return</span> a;\n    } <span class=\"hljs-keyword\">else</span> { \n        <span class=\"hljs-keyword\">if</span>(n % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>)\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">pow</span>(a, n/<span class=\"hljs-number\">2</span>) * <span class=\"hljs-built_in\">pow</span>(a, n/<span class=\"hljs-number\">2</span>);\n        <span class=\"hljs-keyword\">else</span>\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">pow</span>(a, n/<span class=\"hljs-number\">2</span>) * <span class=\"hljs-built_in\">pow</span>(a, n/<span class=\"hljs-number\">2</span>) * a;\n    }\n}</code></pre>\n<p>Thế nhưng, ta lại thấy code trên có 1 điểm không tốt, đó chính là trong phần đệ quy, hàm pow được tính 2 lần trong khi chúng giống hệt nhau:</p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">pow</span>(a, n/<span class=\"hljs-number\">2</span>) * <span class=\"hljs-built_in\">pow</span>(a, n/<span class=\"hljs-number\">2</span>);</code></pre>\n<p>Vậy ta sẽ gán chúng vào một biến, như thế thì sẽ đỡ phải tính lại thêm 1 lần:</p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">pow</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> n)</span>\n</span>{\n    <span class=\"hljs-keyword\">if</span>(n == <span class=\"hljs-number\">1</span>) {\n        <span class=\"hljs-keyword\">return</span> a;\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-keyword\">int</span> temp = <span class=\"hljs-built_in\">pow</span>(a, n/<span class=\"hljs-number\">2</span>);\n        <span class=\"hljs-keyword\">if</span>(n % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>)\n            <span class=\"hljs-keyword\">return</span> temp * temp;\n        <span class=\"hljs-keyword\">else</span>\n            <span class=\"hljs-keyword\">return</span> temp * temp * a;\n    }\n}</code></pre>\n<p>Code ngắn gọn hơn xíu:</p>\n<pre><code>int pow(int a, int n)\n{\n    if(n == 1) return a;\n    int tmp = pow(a, n/2);\n    return (n &amp; 1) ? tmp * tmp * a : tmp * tmp;\n}\n</code></pre>\n<p>Cập nhật:</p>\n<p>[quote=&quot;Gio, post:4, topic:6710, full:true&quot;]\nDùng vòng for(i=0-&gt;n): dpt=O(n)</p>\n<p>Dùng chia để trị: T(n)= T(n/2)+O(1) =&gt; dpt=O(logn)\n[/quote]\n=&gt; Dùng phương pháp chia để trị nhanh hơn là dùng vòng lặp</p>\n<p>Kết thúc bài :D chưa có kinh nghiệm nên viết bài có vẻ lê thê quá, mọi người thông cảm :)</p>\n","rawBody":"\nGiờ rảnh được chút, làm thêm một bài nữa về một thuật toán cơ bản: tính lũy thừa a<sup>n</sup> bằng phương pháp chia để trị.\nChắc mọi người đa số hay dùng vòng lặp nhỉ (cứ ừ đại đi), bây giờ đổi gió xíu nhé\n\nVào luôn vấn đề, như mọi người đã biết, a<sup>n</sup> được tính bằng cách nhân n lần số a (nói vậy cho gọn đi)\nMình lấy ví dụ: \n>a<sup>8</sup> = a . a . a . a . a . a . a . a (8 chữ a lận nhé)\n\nTa nhận thấy rằng có thể chia nửa cái phép tính trên kia ra, như thế này:\n>a<sup>8</sup> = a<sup>4 + 4</sup> = a<sup>4</sup> . a<sup>4</sup> \n\ntrong đó, a<sup>4</sup> có thể được tính:\n>a<sup>4</sup> = a<sup>2</sup> . a<sup>2</sup>\n\nLại một lần nữa chia nhỏ : \n>a<sup>2</sup> = a<sup>1</sup> . a<sup>1</sup> = a . a\n\nĐến đây ra có thể dễ dàng đưa ra a (a cùng n là input của bài toán này).\n\n>Vậy ta nhận ra được phần base case của thuật đệ quy ở đây (hay nhiều sách tiếng Việt gọi là phần neo ấy, mình học trên Khan nên đọc quen rồi) chính là  **khi số mũ đưa về 1, ta có thể đưa thẳng ra giá trị a**\n- Từ đó ta suy ra cách giải quyết bài toán thế này: **chia nhỏ số mũ n ra cho đến khi n = 1**\n\nVậy hàm pow với tham số : ``int pow(int a, int n)``\nSẽ có phần base case:\n\n```cpp\nif(n == 1)\n    return a;\n```\n\nThế còn recursive case (phần đệ quy) ? Thì theo như ví dụ ở trên, ta có công thức:\n>a<sup>n</sup> = a<sup>n/2</sup> . a<sup>n/2</sup>\n\nChuyển ra code:\n```cpp\nreturn pow(a, n/2) * pow(a, n/2);\n```\nThế nhưng nếu n là một số lẻ thì sao? Ví dụ như n = 3:\n>a<sup>5</sup> = a . a . a . a . a (1)\nThì trong trường hợp này, n/2 sẽ bằng 5/2 = 2 (do n kiểu int nên số sẽ tự bỏ đi phần thập phân)\n(1) = a<sup>2</sup> . a<sup>2</sup> . a\ndo là số lẻ nên khi khi mod 2 (chia lấy dư) thì số dư sẽ luôn luôn là 1\n=> Với n là số lẻ, khi chia ra sẽ luôn thừa một số a\n\nVậy ta suy ra công thức:\n>a<sup>n</sup> = a<sup>n/2</sup> . a<sup>n/2</sup> với n là số lẻ\n\nhay chuyển ra code:\n```cpp\nreturn pow(a, n/2) * pow(a, n/2) * a;\n```\n\nTổng hợp lại công thức tổng quát:\n>a<sup>n</sup> =\n- a<sup>n/2</sup> * a<sup>n/2</sup> nếu n chẵn\n- a<sup>n/2</sup> * a<sup>n/2</sup> * a nếu n lẻ\n\nVà cuối cùng là code, dài dòng lê thê lắm rồi:\n\n```cpp\nint pow(int a, int n)\n{\n    if(n == 1) {\n        return a;\n    } else { \n        if(n % 2 == 0)\n            return pow(a, n/2) * pow(a, n/2);\n        else\n            return pow(a, n/2) * pow(a, n/2) * a;\n    }\n}\n```\n\nThế nhưng, ta lại thấy code trên có 1 điểm không tốt, đó chính là trong phần đệ quy, hàm pow được tính 2 lần trong khi chúng giống hệt nhau:\n\n```cpp\nreturn pow(a, n/2) * pow(a, n/2);\n```\nVậy ta sẽ gán chúng vào một biến, như thế thì sẽ đỡ phải tính lại thêm 1 lần:\n```cpp\nint pow(int a, int n)\n{\n    if(n == 1) {\n        return a;\n    } else {\n        int temp = pow(a, n/2);\n        if(n % 2 == 0)\n            return temp * temp;\n        else\n            return temp * temp * a;\n    }\n}\n```\n\nCode ngắn gọn hơn xíu:\n```\nint pow(int a, int n)\n{\n    if(n == 1) return a;\n    int tmp = pow(a, n/2);\n    return (n & 1) ? tmp * tmp * a : tmp * tmp;\n}\n```\n\nCập nhật:\n\n[quote=\"Gio, post:4, topic:6710, full:true\"]\nDùng vòng for(i=0-&gt;n): dpt=O(n)\n\nDùng chia để trị: T(n)= T(n/2)+O(1) =&gt; dpt=O(logn)\n[/quote]\n=> Dùng phương pháp chia để trị nhanh hơn là dùng vòng lặp\n\nKết thúc bài :D chưa có kinh nghiệm nên viết bài có vẻ lê thê quá, mọi người thông cảm :)\n","raw":"---json\n{\"id\":6710,\"layout\":\"Post\",\"route\":\"chia-de-tri-tinh-luy-thua-a-n\",\"title\":\"[Chia để trị] Tính lũy thừa a^n\",\"tags\":[\"algorithm\"],\"date\":\"2015-04-30T06:20:35.807Z\"}\n---\n\nGiờ rảnh được chút, làm thêm một bài nữa về một thuật toán cơ bản: tính lũy thừa a<sup>n</sup> bằng phương pháp chia để trị.\nChắc mọi người đa số hay dùng vòng lặp nhỉ (cứ ừ đại đi), bây giờ đổi gió xíu nhé\n\nVào luôn vấn đề, như mọi người đã biết, a<sup>n</sup> được tính bằng cách nhân n lần số a (nói vậy cho gọn đi)\nMình lấy ví dụ: \n>a<sup>8</sup> = a . a . a . a . a . a . a . a (8 chữ a lận nhé)\n\nTa nhận thấy rằng có thể chia nửa cái phép tính trên kia ra, như thế này:\n>a<sup>8</sup> = a<sup>4 + 4</sup> = a<sup>4</sup> . a<sup>4</sup> \n\ntrong đó, a<sup>4</sup> có thể được tính:\n>a<sup>4</sup> = a<sup>2</sup> . a<sup>2</sup>\n\nLại một lần nữa chia nhỏ : \n>a<sup>2</sup> = a<sup>1</sup> . a<sup>1</sup> = a . a\n\nĐến đây ra có thể dễ dàng đưa ra a (a cùng n là input của bài toán này).\n\n>Vậy ta nhận ra được phần base case của thuật đệ quy ở đây (hay nhiều sách tiếng Việt gọi là phần neo ấy, mình học trên Khan nên đọc quen rồi) chính là  **khi số mũ đưa về 1, ta có thể đưa thẳng ra giá trị a**\n- Từ đó ta suy ra cách giải quyết bài toán thế này: **chia nhỏ số mũ n ra cho đến khi n = 1**\n\nVậy hàm pow với tham số : ``int pow(int a, int n)``\nSẽ có phần base case:\n\n```cpp\nif(n == 1)\n    return a;\n```\n\nThế còn recursive case (phần đệ quy) ? Thì theo như ví dụ ở trên, ta có công thức:\n>a<sup>n</sup> = a<sup>n/2</sup> . a<sup>n/2</sup>\n\nChuyển ra code:\n```cpp\nreturn pow(a, n/2) * pow(a, n/2);\n```\nThế nhưng nếu n là một số lẻ thì sao? Ví dụ như n = 3:\n>a<sup>5</sup> = a . a . a . a . a (1)\nThì trong trường hợp này, n/2 sẽ bằng 5/2 = 2 (do n kiểu int nên số sẽ tự bỏ đi phần thập phân)\n(1) = a<sup>2</sup> . a<sup>2</sup> . a\ndo là số lẻ nên khi khi mod 2 (chia lấy dư) thì số dư sẽ luôn luôn là 1\n=> Với n là số lẻ, khi chia ra sẽ luôn thừa một số a\n\nVậy ta suy ra công thức:\n>a<sup>n</sup> = a<sup>n/2</sup> . a<sup>n/2</sup> với n là số lẻ\n\nhay chuyển ra code:\n```cpp\nreturn pow(a, n/2) * pow(a, n/2) * a;\n```\n\nTổng hợp lại công thức tổng quát:\n>a<sup>n</sup> =\n- a<sup>n/2</sup> * a<sup>n/2</sup> nếu n chẵn\n- a<sup>n/2</sup> * a<sup>n/2</sup> * a nếu n lẻ\n\nVà cuối cùng là code, dài dòng lê thê lắm rồi:\n\n```cpp\nint pow(int a, int n)\n{\n    if(n == 1) {\n        return a;\n    } else { \n        if(n % 2 == 0)\n            return pow(a, n/2) * pow(a, n/2);\n        else\n            return pow(a, n/2) * pow(a, n/2) * a;\n    }\n}\n```\n\nThế nhưng, ta lại thấy code trên có 1 điểm không tốt, đó chính là trong phần đệ quy, hàm pow được tính 2 lần trong khi chúng giống hệt nhau:\n\n```cpp\nreturn pow(a, n/2) * pow(a, n/2);\n```\nVậy ta sẽ gán chúng vào một biến, như thế thì sẽ đỡ phải tính lại thêm 1 lần:\n```cpp\nint pow(int a, int n)\n{\n    if(n == 1) {\n        return a;\n    } else {\n        int temp = pow(a, n/2);\n        if(n % 2 == 0)\n            return temp * temp;\n        else\n            return temp * temp * a;\n    }\n}\n```\n\nCode ngắn gọn hơn xíu:\n```\nint pow(int a, int n)\n{\n    if(n == 1) return a;\n    int tmp = pow(a, n/2);\n    return (n & 1) ? tmp * tmp * a : tmp * tmp;\n}\n```\n\nCập nhật:\n\n[quote=\"Gio, post:4, topic:6710, full:true\"]\nDùng vòng for(i=0-&gt;n): dpt=O(n)\n\nDùng chia để trị: T(n)= T(n/2)+O(1) =&gt; dpt=O(logn)\n[/quote]\n=> Dùng phương pháp chia để trị nhanh hơn là dùng vòng lặp\n\nKết thúc bài :D chưa có kinh nghiệm nên viết bài có vẻ lê thê quá, mọi người thông cảm :)\n","__filename":"posts/6710.md","__url":"/chia-de-tri-tinh-luy-thua-a-n/","__resourceUrl":"/chia-de-tri-tinh-luy-thua-a-n/index.html","__dataUrl":"/chia-de-tri-tinh-luy-thua-a-n/index.html.3daa3d2c38f08455f260cbe680acc591.json"}