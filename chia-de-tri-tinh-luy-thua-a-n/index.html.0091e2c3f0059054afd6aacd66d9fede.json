{"head":{"id":6710,"layout":"Post","route":"chia-de-tri-tinh-luy-thua-a-n","title":"[Chia để trị] Tính lũy thừa a^n","tags":["algorithm"],"date":"2015-04-30T06:20:35.807Z","views":3638,"likes":21,"description":"Giờ rảnh được chút, làm thêm một bài nữa về một thuật toán cơ bản: tính lũy thừa an bằng phương pháp chia để trị.Chắc mọi người đa số hay…","author":{"name":"nhatlonggunz","avatar":"/letter_avatar_proxy/v2/letter/n/7bcc69/{size}.png","username":"nhatlonggunz"}},"body":"\n<p>Giờ rảnh được chút, làm thêm một bài nữa về một thuật toán cơ bản: tính lũy thừa a<sup>n</sup> bằng phương pháp chia để trị.<br>Chắc mọi người đa số hay dùng vòng lặp nhỉ (cứ ừ đại đi), bây giờ đổi gió xíu nhé</p>\n\n<p>Vào luôn vấn đề, như mọi người đã biết, a<sup>n</sup> được tính bằng cách nhân n lần số a (nói vậy cho gọn đi)<br>Mình lấy ví dụ: </p>\n\n<blockquote><p>a<sup>8</sup> = a . a . a . a . a . a . a . a (8 chữ a lận nhé)</p></blockquote>\n\n<p>Ta nhận thấy rằng có thể chia nửa cái phép tính trên kia ra, như thế này:</p>\n\n<blockquote><p>a<sup>8</sup> = a<sup>4 + 4</sup> = a<sup>4</sup> . a<sup>4</sup> </p></blockquote>\n\n<p>trong đó, a<sup>4</sup> có thể được tính:</p>\n\n<blockquote><p>a<sup>4</sup> = a<sup>2</sup> . a<sup>2</sup></p></blockquote>\n\n<p>Lại một lần nữa chia nhỏ : </p>\n\n<blockquote><p>a<sup>2</sup> = a<sup>1</sup> . a<sup>1</sup> = a . a</p></blockquote>\n\n<p>Đến đây ra có thể dễ dàng đưa ra a (a cùng n là input của bài toán này).</p>\n\n<blockquote><p>Vậy ta nhận ra được phần base case của thuật đệ quy ở đây (hay nhiều sách tiếng Việt gọi là phần neo ấy, mình học trên Khan nên đọc quen rồi) chính là  <strong>khi số mũ đưa về 1, ta có thể đưa thẳng ra giá trị a</strong><br>- Từ đó ta suy ra cách giải quyết bài toán thế này: <strong>chia nhỏ số mũ n ra cho đến khi n = 1</strong></p></blockquote>\n\n<p>Vậy hàm pow với tham số : <code>int pow(int a, int n)</code><br>Sẽ có phần base case:</p>\n\n<p></p><pre><code class=\"lang-cpp\">if(n == 1)\n    return a;</code></pre>\n\n<p>Thế còn recursive case (phần đệ quy) ? Thì theo như ví dụ ở trên, ta có công thức:</p>\n\n<blockquote><p>a<sup>n</sup> = a<sup>n/2</sup> . a<sup>n/2</sup></p></blockquote>\n\n<p>Chuyển ra code:<br></p>\n\n<p></p><pre><code class=\"lang-cpp\">return pow(a, n/2) * pow(a, n/2);</code></pre>\n\n<p>Thế nhưng nếu n là một số lẻ thì sao? Ví dụ như n = 3:</p>\n\n<blockquote><p>a<sup>5</sup> = a . a . a . a . a (1)<br>Thì trong trường hợp này, n/2 sẽ bằng 5/2 = 2 (do n kiểu int nên số sẽ tự bỏ đi phần thập phân)<br>(1) = a<sup>2</sup> . a<sup>2</sup> . a<br>do là số lẻ nên khi khi mod 2 (chia lấy dư) thì số dư sẽ luôn luôn là 1<br>=&gt; Với n là số lẻ, khi chia ra sẽ luôn thừa một số a</p></blockquote>\n\n<p>Vậy ta suy ra công thức:</p>\n\n<blockquote><p>a<sup>n</sup> = a<sup>n/2</sup> . a<sup>n/2</sup> với n là số lẻ</p></blockquote>\n\n<p>hay chuyển ra code:<br></p>\n\n<p></p><pre><code class=\"lang-cpp\">return pow(a, n/2) * pow(a, n/2) * a;</code></pre>\n\n<p>Tổng hợp lại công thức tổng quát:</p>\n\n<blockquote><p>a<sup>n</sup> =<br>- a<sup>n/2</sup> * a<sup>n/2</sup> nếu n chẵn<br>- a<sup>n/2</sup> * a<sup>n/2</sup> * a nếu n lẻ</p></blockquote>\n\n<p>Và cuối cùng là code, dài dòng lê thê lắm rồi:</p>\n\n<p></p><pre><code class=\"lang-cpp\">int pow(int a, int n)\n{\n    if(n == 1) {\n        return a;\n    } else { \n        if(n % 2 == 0)\n            return pow(a, n/2) * pow(a, n/2);\n        else\n            return pow(a, n/2) * pow(a, n/2) * a;\n    }\n}</code></pre>\n\n<p>Thế nhưng, ta lại thấy code trên có 1 điểm không tốt, đó chính là trong phần đệ quy, hàm pow được tính 2 lần trong khi chúng giống hệt nhau:</p>\n\n<p></p><pre><code class=\"lang-cpp\">return pow(a, n/2) * pow(a, n/2);</code></pre>\n\n<p>Vậy ta sẽ gán chúng vào một biến, như thế thì sẽ đỡ phải tính lại thêm 1 lần:<br></p>\n\n<p></p><pre><code class=\"lang-cpp\">int pow(int a, int n)\n{\n    if(n == 1) {\n        return a;\n    } else {\n        int temp = pow(a, n/2);\n        if(n % 2 == 0)\n            return temp * temp;\n        else\n            return temp * temp * a;\n    }\n}</code></pre>\n\n<p>Code ngắn gọn hơn xíu:<br></p>\n\n<p></p><pre><code class=\"lang-auto\">int pow(int a, int n)\n{\n    if(n == 1) return a;\n    int tmp = pow(a, n/2);\n    return (n &amp; 1) ? tmp * tmp * a : tmp * tmp;\n}</code></pre>\n\n<p>Cập nhật:</p>\n\n<aside class=\"quote\" data-post=\"4\" data-topic=\"6710\" data-full=\"true\"><div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"20\" height=\"20\" src=\"http://daynhauhoc.com/user_avatar/daynhauhoc.com/gio/40/577_1.png\" class=\"avatar\">Gio:</div>\n<blockquote>\n<p>Dùng vòng for(i=0-&gt;n): dpt=O(n)</p>\n<p>Dùng chia để trị: T(n)= T(n/2)+O(1) =&gt; dpt=O(logn)</p>\n</blockquote></aside>\n\n<p>=&gt; Dùng phương pháp chia để trị nhanh hơn là dùng vòng lặp</p>\n\n<p>Kết thúc bài <img src=\"http://daynhauhoc.com/images/emoji/twitter/smiley.png?v=2\" title=\":smiley:\" class=\"emoji\" alt=\":smiley:\"> chưa có kinh nghiệm nên viết bài có vẻ lê thê quá, mọi người thông cảm <img src=\"http://daynhauhoc.com/images/emoji/twitter/slight_smile.png?v=2\" title=\":slight_smile:\" class=\"emoji\" alt=\":slight_smile:\"></p>\n","rawBody":"\n<p>Giờ rảnh được chút, làm thêm một bài nữa về một thuật toán cơ bản: tính lũy thừa a<sup>n</sup> bằng phương pháp chia để trị.<br>Chắc mọi người đa số hay dùng vòng lặp nhỉ (cứ ừ đại đi), bây giờ đổi gió xíu nhé</p>\n\n<p>Vào luôn vấn đề, như mọi người đã biết, a<sup>n</sup> được tính bằng cách nhân n lần số a (nói vậy cho gọn đi)<br>Mình lấy ví dụ: </p>\n\n<blockquote><p>a<sup>8</sup> = a . a . a . a . a . a . a . a (8 chữ a lận nhé)</p></blockquote>\n\n<p>Ta nhận thấy rằng có thể chia nửa cái phép tính trên kia ra, như thế này:</p>\n\n<blockquote><p>a<sup>8</sup> = a<sup>4 + 4</sup> = a<sup>4</sup> . a<sup>4</sup> </p></blockquote>\n\n<p>trong đó, a<sup>4</sup> có thể được tính:</p>\n\n<blockquote><p>a<sup>4</sup> = a<sup>2</sup> . a<sup>2</sup></p></blockquote>\n\n<p>Lại một lần nữa chia nhỏ : </p>\n\n<blockquote><p>a<sup>2</sup> = a<sup>1</sup> . a<sup>1</sup> = a . a</p></blockquote>\n\n<p>Đến đây ra có thể dễ dàng đưa ra a (a cùng n là input của bài toán này).</p>\n\n<blockquote><p>Vậy ta nhận ra được phần base case của thuật đệ quy ở đây (hay nhiều sách tiếng Việt gọi là phần neo ấy, mình học trên Khan nên đọc quen rồi) chính là  <strong>khi số mũ đưa về 1, ta có thể đưa thẳng ra giá trị a</strong><br>- Từ đó ta suy ra cách giải quyết bài toán thế này: <strong>chia nhỏ số mũ n ra cho đến khi n = 1</strong></p></blockquote>\n\n<p>Vậy hàm pow với tham số : <code>int pow(int a, int n)</code><br>Sẽ có phần base case:</p>\n\n<p></p><pre><code class=\"lang-cpp\">if(n == 1)\n    return a;</code></pre>\n\n<p>Thế còn recursive case (phần đệ quy) ? Thì theo như ví dụ ở trên, ta có công thức:</p>\n\n<blockquote><p>a<sup>n</sup> = a<sup>n/2</sup> . a<sup>n/2</sup></p></blockquote>\n\n<p>Chuyển ra code:<br></p>\n\n<p></p><pre><code class=\"lang-cpp\">return pow(a, n/2) * pow(a, n/2);</code></pre>\n\n<p>Thế nhưng nếu n là một số lẻ thì sao? Ví dụ như n = 3:</p>\n\n<blockquote><p>a<sup>5</sup> = a . a . a . a . a (1)<br>Thì trong trường hợp này, n/2 sẽ bằng 5/2 = 2 (do n kiểu int nên số sẽ tự bỏ đi phần thập phân)<br>(1) = a<sup>2</sup> . a<sup>2</sup> . a<br>do là số lẻ nên khi khi mod 2 (chia lấy dư) thì số dư sẽ luôn luôn là 1<br>=&gt; Với n là số lẻ, khi chia ra sẽ luôn thừa một số a</p></blockquote>\n\n<p>Vậy ta suy ra công thức:</p>\n\n<blockquote><p>a<sup>n</sup> = a<sup>n/2</sup> . a<sup>n/2</sup> với n là số lẻ</p></blockquote>\n\n<p>hay chuyển ra code:<br></p>\n\n<p></p><pre><code class=\"lang-cpp\">return pow(a, n/2) * pow(a, n/2) * a;</code></pre>\n\n<p>Tổng hợp lại công thức tổng quát:</p>\n\n<blockquote><p>a<sup>n</sup> =<br>- a<sup>n/2</sup> * a<sup>n/2</sup> nếu n chẵn<br>- a<sup>n/2</sup> * a<sup>n/2</sup> * a nếu n lẻ</p></blockquote>\n\n<p>Và cuối cùng là code, dài dòng lê thê lắm rồi:</p>\n\n<p></p><pre><code class=\"lang-cpp\">int pow(int a, int n)\n{\n    if(n == 1) {\n        return a;\n    } else { \n        if(n % 2 == 0)\n            return pow(a, n/2) * pow(a, n/2);\n        else\n            return pow(a, n/2) * pow(a, n/2) * a;\n    }\n}</code></pre>\n\n<p>Thế nhưng, ta lại thấy code trên có 1 điểm không tốt, đó chính là trong phần đệ quy, hàm pow được tính 2 lần trong khi chúng giống hệt nhau:</p>\n\n<p></p><pre><code class=\"lang-cpp\">return pow(a, n/2) * pow(a, n/2);</code></pre>\n\n<p>Vậy ta sẽ gán chúng vào một biến, như thế thì sẽ đỡ phải tính lại thêm 1 lần:<br></p>\n\n<p></p><pre><code class=\"lang-cpp\">int pow(int a, int n)\n{\n    if(n == 1) {\n        return a;\n    } else {\n        int temp = pow(a, n/2);\n        if(n % 2 == 0)\n            return temp * temp;\n        else\n            return temp * temp * a;\n    }\n}</code></pre>\n\n<p>Code ngắn gọn hơn xíu:<br></p>\n\n<p></p><pre><code class=\"lang-auto\">int pow(int a, int n)\n{\n    if(n == 1) return a;\n    int tmp = pow(a, n/2);\n    return (n &amp; 1) ? tmp * tmp * a : tmp * tmp;\n}</code></pre>\n\n<p>Cập nhật:</p>\n\n<aside class=\"quote\" data-post=\"4\" data-topic=\"6710\" data-full=\"true\"><div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"20\" height=\"20\" src=\"http://daynhauhoc.com/user_avatar/daynhauhoc.com/gio/40/577_1.png\" class=\"avatar\">Gio:</div>\n<blockquote>\n<p>Dùng vòng for(i=0-&gt;n): dpt=O(n)</p>\n<p>Dùng chia để trị: T(n)= T(n/2)+O(1) =&gt; dpt=O(logn)</p>\n</blockquote></aside>\n\n<p>=&gt; Dùng phương pháp chia để trị nhanh hơn là dùng vòng lặp</p>\n\n<p>Kết thúc bài <img src=\"http://daynhauhoc.com/images/emoji/twitter/smiley.png?v=2\" title=\":smiley:\" class=\"emoji\" alt=\":smiley:\"> chưa có kinh nghiệm nên viết bài có vẻ lê thê quá, mọi người thông cảm <img src=\"http://daynhauhoc.com/images/emoji/twitter/slight_smile.png?v=2\" title=\":slight_smile:\" class=\"emoji\" alt=\":slight_smile:\"></p>\n","raw":"---json\n{\"id\":6710,\"layout\":\"Post\",\"route\":\"chia-de-tri-tinh-luy-thua-a-n\",\"title\":\"[Chia để trị] Tính lũy thừa a^n\",\"tags\":[\"algorithm\"],\"date\":\"2015-04-30T06:20:35.807Z\",\"views\":3638,\"likes\":21,\"description\":\"Giờ rảnh được chút, làm thêm một bài nữa về một thuật toán cơ bản: tính lũy thừa an bằng phương pháp chia để trị.Chắc mọi người đa số hay…\",\"author\":{\"name\":\"nhatlonggunz\",\"avatar\":\"/letter_avatar_proxy/v2/letter/n/7bcc69/{size}.png\",\"username\":\"nhatlonggunz\"}}\n---\n\n<p>Giờ rảnh được chút, làm thêm một bài nữa về một thuật toán cơ bản: tính lũy thừa a<sup>n</sup> bằng phương pháp chia để trị.<br>Chắc mọi người đa số hay dùng vòng lặp nhỉ (cứ ừ đại đi), bây giờ đổi gió xíu nhé</p>\n\n<p>Vào luôn vấn đề, như mọi người đã biết, a<sup>n</sup> được tính bằng cách nhân n lần số a (nói vậy cho gọn đi)<br>Mình lấy ví dụ: </p>\n\n<blockquote><p>a<sup>8</sup> = a . a . a . a . a . a . a . a (8 chữ a lận nhé)</p></blockquote>\n\n<p>Ta nhận thấy rằng có thể chia nửa cái phép tính trên kia ra, như thế này:</p>\n\n<blockquote><p>a<sup>8</sup> = a<sup>4 + 4</sup> = a<sup>4</sup> . a<sup>4</sup> </p></blockquote>\n\n<p>trong đó, a<sup>4</sup> có thể được tính:</p>\n\n<blockquote><p>a<sup>4</sup> = a<sup>2</sup> . a<sup>2</sup></p></blockquote>\n\n<p>Lại một lần nữa chia nhỏ : </p>\n\n<blockquote><p>a<sup>2</sup> = a<sup>1</sup> . a<sup>1</sup> = a . a</p></blockquote>\n\n<p>Đến đây ra có thể dễ dàng đưa ra a (a cùng n là input của bài toán này).</p>\n\n<blockquote><p>Vậy ta nhận ra được phần base case của thuật đệ quy ở đây (hay nhiều sách tiếng Việt gọi là phần neo ấy, mình học trên Khan nên đọc quen rồi) chính là  <strong>khi số mũ đưa về 1, ta có thể đưa thẳng ra giá trị a</strong><br>- Từ đó ta suy ra cách giải quyết bài toán thế này: <strong>chia nhỏ số mũ n ra cho đến khi n = 1</strong></p></blockquote>\n\n<p>Vậy hàm pow với tham số : <code>int pow(int a, int n)</code><br>Sẽ có phần base case:</p>\n\n<p></p><pre><code class=\"lang-cpp\">if(n == 1)\n    return a;</code></pre>\n\n<p>Thế còn recursive case (phần đệ quy) ? Thì theo như ví dụ ở trên, ta có công thức:</p>\n\n<blockquote><p>a<sup>n</sup> = a<sup>n/2</sup> . a<sup>n/2</sup></p></blockquote>\n\n<p>Chuyển ra code:<br></p>\n\n<p></p><pre><code class=\"lang-cpp\">return pow(a, n/2) * pow(a, n/2);</code></pre>\n\n<p>Thế nhưng nếu n là một số lẻ thì sao? Ví dụ như n = 3:</p>\n\n<blockquote><p>a<sup>5</sup> = a . a . a . a . a (1)<br>Thì trong trường hợp này, n/2 sẽ bằng 5/2 = 2 (do n kiểu int nên số sẽ tự bỏ đi phần thập phân)<br>(1) = a<sup>2</sup> . a<sup>2</sup> . a<br>do là số lẻ nên khi khi mod 2 (chia lấy dư) thì số dư sẽ luôn luôn là 1<br>=&gt; Với n là số lẻ, khi chia ra sẽ luôn thừa một số a</p></blockquote>\n\n<p>Vậy ta suy ra công thức:</p>\n\n<blockquote><p>a<sup>n</sup> = a<sup>n/2</sup> . a<sup>n/2</sup> với n là số lẻ</p></blockquote>\n\n<p>hay chuyển ra code:<br></p>\n\n<p></p><pre><code class=\"lang-cpp\">return pow(a, n/2) * pow(a, n/2) * a;</code></pre>\n\n<p>Tổng hợp lại công thức tổng quát:</p>\n\n<blockquote><p>a<sup>n</sup> =<br>- a<sup>n/2</sup> * a<sup>n/2</sup> nếu n chẵn<br>- a<sup>n/2</sup> * a<sup>n/2</sup> * a nếu n lẻ</p></blockquote>\n\n<p>Và cuối cùng là code, dài dòng lê thê lắm rồi:</p>\n\n<p></p><pre><code class=\"lang-cpp\">int pow(int a, int n)\n{\n    if(n == 1) {\n        return a;\n    } else { \n        if(n % 2 == 0)\n            return pow(a, n/2) * pow(a, n/2);\n        else\n            return pow(a, n/2) * pow(a, n/2) * a;\n    }\n}</code></pre>\n\n<p>Thế nhưng, ta lại thấy code trên có 1 điểm không tốt, đó chính là trong phần đệ quy, hàm pow được tính 2 lần trong khi chúng giống hệt nhau:</p>\n\n<p></p><pre><code class=\"lang-cpp\">return pow(a, n/2) * pow(a, n/2);</code></pre>\n\n<p>Vậy ta sẽ gán chúng vào một biến, như thế thì sẽ đỡ phải tính lại thêm 1 lần:<br></p>\n\n<p></p><pre><code class=\"lang-cpp\">int pow(int a, int n)\n{\n    if(n == 1) {\n        return a;\n    } else {\n        int temp = pow(a, n/2);\n        if(n % 2 == 0)\n            return temp * temp;\n        else\n            return temp * temp * a;\n    }\n}</code></pre>\n\n<p>Code ngắn gọn hơn xíu:<br></p>\n\n<p></p><pre><code class=\"lang-auto\">int pow(int a, int n)\n{\n    if(n == 1) return a;\n    int tmp = pow(a, n/2);\n    return (n &amp; 1) ? tmp * tmp * a : tmp * tmp;\n}</code></pre>\n\n<p>Cập nhật:</p>\n\n<aside class=\"quote\" data-post=\"4\" data-topic=\"6710\" data-full=\"true\"><div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"20\" height=\"20\" src=\"http://daynhauhoc.com/user_avatar/daynhauhoc.com/gio/40/577_1.png\" class=\"avatar\">Gio:</div>\n<blockquote>\n<p>Dùng vòng for(i=0-&gt;n): dpt=O(n)</p>\n<p>Dùng chia để trị: T(n)= T(n/2)+O(1) =&gt; dpt=O(logn)</p>\n</blockquote></aside>\n\n<p>=&gt; Dùng phương pháp chia để trị nhanh hơn là dùng vòng lặp</p>\n\n<p>Kết thúc bài <img src=\"http://daynhauhoc.com/images/emoji/twitter/smiley.png?v=2\" title=\":smiley:\" class=\"emoji\" alt=\":smiley:\"> chưa có kinh nghiệm nên viết bài có vẻ lê thê quá, mọi người thông cảm <img src=\"http://daynhauhoc.com/images/emoji/twitter/slight_smile.png?v=2\" title=\":slight_smile:\" class=\"emoji\" alt=\":slight_smile:\"></p>\n","__filename":"posts/6710.md","__url":"/chia-de-tri-tinh-luy-thua-a-n/","__resourceUrl":"/chia-de-tri-tinh-luy-thua-a-n/index.html","__dataUrl":"/chia-de-tri-tinh-luy-thua-a-n/index.html.0091e2c3f0059054afd6aacd66d9fede.json"}