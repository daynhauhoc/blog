{"head":{"id":15082,"layout":"Post","route":"java-virtual-machine-va-c-ch-ho-t-d-ng","title":"Java virtual Machine và Cơ chế hoạt động","tags":["java"],"date":"2015-10-22T06:51:11.547Z","description":"JVM - Java virtual machine\nCó thể dịch là máy ảo java\n\n\nNhư bạn thấy mỗi hệ điều hành chạy chương trình của nó với một mã máy khác nhau đó…"},"body":"<p>JVM - Java virtual machine\nCó thể dịch là máy ảo java\n<img src=\"//daynhauhoc.s3-ap-southeast-1.amazonaws.com/original/2X/b/bc76c6cfaba0ed3710abf44475270b5f853fc8a0.jpg\" width=\"658\" height=\"500\"></p>\n<p>Như bạn thấy mỗi hệ điều hành chạy chương trình của nó với một mã máy khác nhau đó là mã bytecodes. Windows được biên dịch dưới dạng exe còn Linux là .ELF vì vậy hầu hết các phần mềm  gặp khó khăn khi viết ra để sử dụng trên nhiều hệ điều hành.\nMáy ảo java được sinh ra với 3 mục đích chính:</p>\n<ul>\n<li>dịch mã java ra mã máy chạy được trên các hệ điều hành khác nhau</li>\n<li>tăng tốc độ</li>\n<li>Nâng cao độ bảo mật và tránh virus phá source code</li>\n</ul>\n<p>JVM có 3 thành phần chính: ̀</p>\n<ul>\n<li>Class Loader: Tìm kiếm và load các file .class vào vùng nhớ của java dưới dạng bytecode</li>\n<li>Data Area :  vùng nhớ hệ thống cấp phát cho Java Virtual Machine</li>\n<li>Execution Engine: chuyển các lệnh của JVM trong file .class thành các lệnh của máy, hệ điều hành tương ứng và thực thi chúng.</li>\n</ul>\n<p>Mình vẽ = pain các bạn thông cảm:\nHình ảnh mình họa java thực thi file .java sang mã bytecode bằng trình biên dịch JAVAC chuyển thành mã máy qua compiler JIT\n<img src=\"//daynhauhoc.s3-ap-southeast-1.amazonaws.com/original/2X/4/4368b80e3be10cd99c3029a31879b5090333e544.png\" width=\"690\" height=\"339\"></p>\n<p>Sau khi Classloader làm xong nhiệm vụ của mình các file sẽ được máy ảo JVM cung cấp bộ nhớ tương ứng với chúng.</p>\n<ul>\n<li>\n<p>Class area: đúng như tên gọi của nó, là vùng nhớ cấp phát cho class(Method) trong đó lại phân chia thành heap, stack, PC register, native method stack</p>\n</li>\n<li>\n<p>Heap:  Là nơi các đối tượng khởi tạo bằng toàn tử &quot;new &quot;sẽ được lưu ở đây tại thời điểm chương trình chạy</p>\n</li>\n<li>\n<p>Stak :  Các phương thức và tham chiếu tới đối tượng địa phương được lưu trữ trong Stack. Mỗi Thread quản lý một stack. Khi phương thức được gọi, nó được đưa vào đỉnh của Stack. Stack lưu trữ trạng thái của phương thức bao gồm: dòng code thực thi, tham chiếu tới đối tượng địa phương. Khi phương thức chạy xong, vùng nhớ (dòng code thực thi, tham chiếu tới đối tượng địa phương) được đẩy ra khỏi stack và tự động giải phóng.</p>\n</li>\n<li>\n<p>PC register : Khi JVM thực thi mã, một thanh ghi cục bộ có tên “Program Counter” được sử dụng. Thanh ghi này trỏ tới lệnh đang thực hiện. Khi cần thiết, có thể thay đổi nội dung thanh ghi để đổi hướng thực thi của chương trình. Trong trường hợp thông thường thì từng lệnh một nối tiếp nhau sẽ được thực thi.</p>\n</li>\n<li>\n<p>native method: Nơi chứa tất cả các method native trong chương trình</p>\n</li>\n<li>\n<p>Java Perm: Lưu trữ thông tin của Class được nạp vào và một vài tính năng khác như StringPool (vùng nhớ của biến String) thường được tạo bởi phương thức String.interm(). Khi ứng dụng của bạn chạy, Perm space được lấp đầy nhanh chóng.</p>\n</li>\n</ul>\n<pre><code class=\"hljs language-java\">Ví dụ: Person person = <span class=\"hljs-keyword\">new</span> Person ();\nHeap: lưu đối tượng Person khi ta “<span class=\"hljs-keyword\">new</span> Person ();”\nStack: lưu tham chiếu “person ”.\nPerm: lưu thông tin về Class “Person ”.</code></pre>\n<p>Execution Engine:\nSau khi lưu Dữ liệu xong chương trinh JVM sẽ biên dịch file .java thành dạng file .class bytecode bằng trình biên dịch javac</p>\n<p>Khi file .class được hoàn thành chương trình tiếp tục sử dụng compiler “Just In Time-JIT”. Các trình duyệt thông dụng như Netscape hay IE đều có JIT bên trong để tăng tốc độ thực thi chương trình Java. Mục đích chính của JIT là chuyển tập lệnh bytecode thành mã máy cụ thể cho từng loại CPU. Các lệnh này sẽ được lưu trữ và sử dụng mỗi khi gọi đến.</p>\n<p><img src=\"//daynhauhoc.s3-ap-southeast-1.amazonaws.com/original/2X/5/5128d8b76675a95fc7af49d7c6246c2cb48f643a.png\" width=\"478\" height=\"307\"></p>\n<p>3: Bởi vì các file .java đều được chuyển sang mã bytecode nên trong quá trình chạy không sợ virus có thể tấn công nên Java được coi là ngôn ngữ có độ bảo mật cao nhất hiện nay</p>\n","rawBody":"\nJVM - Java virtual machine\nCó thể dịch là máy ảo java\n<img src=\"//daynhauhoc.s3-ap-southeast-1.amazonaws.com/original/2X/b/bc76c6cfaba0ed3710abf44475270b5f853fc8a0.jpg\" width=\"658\" height=\"500\">\n\nNhư bạn thấy mỗi hệ điều hành chạy chương trình của nó với một mã máy khác nhau đó là mã bytecodes. Windows được biên dịch dưới dạng exe còn Linux là .ELF vì vậy hầu hết các phần mềm  gặp khó khăn khi viết ra để sử dụng trên nhiều hệ điều hành.\nMáy ảo java được sinh ra với 3 mục đích chính:\n\n - dịch mã java ra mã máy chạy được trên các hệ điều hành khác nhau\n -  tăng tốc độ\n - Nâng cao độ bảo mật và tránh virus phá source code\n\nJVM có 3 thành phần chính: ̀ \n\n   - Class Loader: Tìm kiếm và load các file .class vào vùng nhớ của java dưới dạng bytecode\n   - Data Area :  vùng nhớ hệ thống cấp phát cho Java Virtual Machine\n   - Execution Engine: chuyển các lệnh của JVM trong file .class thành các lệnh của máy, hệ điều hành tương ứng và thực thi chúng.\n\nMình vẽ = pain các bạn thông cảm:\nHình ảnh mình họa java thực thi file .java sang mã bytecode bằng trình biên dịch JAVAC chuyển thành mã máy qua compiler JIT\n<img src=\"//daynhauhoc.s3-ap-southeast-1.amazonaws.com/original/2X/4/4368b80e3be10cd99c3029a31879b5090333e544.png\" width=\"690\" height=\"339\">\n\nSau khi Classloader làm xong nhiệm vụ của mình các file sẽ được máy ảo JVM cung cấp bộ nhớ tương ứng với chúng.\n\n - Class area: đúng như tên gọi của nó, là vùng nhớ cấp phát cho class(Method) trong đó lại phân chia thành heap, stack, PC register, native method stack\n\n - Heap:  Là nơi các đối tượng khởi tạo bằng toàn tử \"new \"sẽ được lưu ở đây tại thời điểm chương trình chạy\n\n - Stak :  Các phương thức và tham chiếu tới đối tượng địa phương được lưu trữ trong Stack. Mỗi Thread quản lý một stack. Khi phương thức được gọi, nó được đưa vào đỉnh của Stack. Stack lưu trữ trạng thái của phương thức bao gồm: dòng code thực thi, tham chiếu tới đối tượng địa phương. Khi phương thức chạy xong, vùng nhớ (dòng code thực thi, tham chiếu tới đối tượng địa phương) được đẩy ra khỏi stack và tự động giải phóng.\n\n - PC register : Khi JVM thực thi mã, một thanh ghi cục bộ có tên “Program Counter” được sử dụng. Thanh ghi này trỏ tới lệnh đang thực hiện. Khi cần thiết, có thể thay đổi nội dung thanh ghi để đổi hướng thực thi của chương trình. Trong trường hợp thông thường thì từng lệnh một nối tiếp nhau sẽ được thực thi.\n\n - native method: Nơi chứa tất cả các method native trong chương trình\n - Java Perm: Lưu trữ thông tin của Class được nạp vào và một vài tính năng khác như StringPool (vùng nhớ của biến String) thường được tạo bởi phương thức String.interm(). Khi ứng dụng của bạn chạy, Perm space được lấp đầy nhanh chóng.\n```java\nVí dụ: Person person = new Person ();\nHeap: lưu đối tượng Person khi ta “new Person ();”\nStack: lưu tham chiếu “person ”.\nPerm: lưu thông tin về Class “Person ”.\n```\n\n Execution Engine:\nSau khi lưu Dữ liệu xong chương trinh JVM sẽ biên dịch file .java thành dạng file .class bytecode bằng trình biên dịch javac\n\nKhi file .class được hoàn thành chương trình tiếp tục sử dụng compiler “Just In Time-JIT”. Các trình duyệt thông dụng như Netscape hay IE đều có JIT bên trong để tăng tốc độ thực thi chương trình Java. Mục đích chính của JIT là chuyển tập lệnh bytecode thành mã máy cụ thể cho từng loại CPU. Các lệnh này sẽ được lưu trữ và sử dụng mỗi khi gọi đến.\n\n<img src=\"//daynhauhoc.s3-ap-southeast-1.amazonaws.com/original/2X/5/5128d8b76675a95fc7af49d7c6246c2cb48f643a.png\" width=\"478\" height=\"307\">\n\n3: Bởi vì các file .java đều được chuyển sang mã bytecode nên trong quá trình chạy không sợ virus có thể tấn công nên Java được coi là ngôn ngữ có độ bảo mật cao nhất hiện nay\n","raw":"---json\n{\"id\":15082,\"layout\":\"Post\",\"route\":\"java-virtual-machine-va-c-ch-ho-t-d-ng\",\"title\":\"Java virtual Machine và Cơ chế hoạt động\",\"tags\":[\"java\"],\"date\":\"2015-10-22T06:51:11.547Z\"}\n---\n\nJVM - Java virtual machine\nCó thể dịch là máy ảo java\n<img src=\"//daynhauhoc.s3-ap-southeast-1.amazonaws.com/original/2X/b/bc76c6cfaba0ed3710abf44475270b5f853fc8a0.jpg\" width=\"658\" height=\"500\">\n\nNhư bạn thấy mỗi hệ điều hành chạy chương trình của nó với một mã máy khác nhau đó là mã bytecodes. Windows được biên dịch dưới dạng exe còn Linux là .ELF vì vậy hầu hết các phần mềm  gặp khó khăn khi viết ra để sử dụng trên nhiều hệ điều hành.\nMáy ảo java được sinh ra với 3 mục đích chính:\n\n - dịch mã java ra mã máy chạy được trên các hệ điều hành khác nhau\n -  tăng tốc độ\n - Nâng cao độ bảo mật và tránh virus phá source code\n\nJVM có 3 thành phần chính: ̀ \n\n   - Class Loader: Tìm kiếm và load các file .class vào vùng nhớ của java dưới dạng bytecode\n   - Data Area :  vùng nhớ hệ thống cấp phát cho Java Virtual Machine\n   - Execution Engine: chuyển các lệnh của JVM trong file .class thành các lệnh của máy, hệ điều hành tương ứng và thực thi chúng.\n\nMình vẽ = pain các bạn thông cảm:\nHình ảnh mình họa java thực thi file .java sang mã bytecode bằng trình biên dịch JAVAC chuyển thành mã máy qua compiler JIT\n<img src=\"//daynhauhoc.s3-ap-southeast-1.amazonaws.com/original/2X/4/4368b80e3be10cd99c3029a31879b5090333e544.png\" width=\"690\" height=\"339\">\n\nSau khi Classloader làm xong nhiệm vụ của mình các file sẽ được máy ảo JVM cung cấp bộ nhớ tương ứng với chúng.\n\n - Class area: đúng như tên gọi của nó, là vùng nhớ cấp phát cho class(Method) trong đó lại phân chia thành heap, stack, PC register, native method stack\n\n - Heap:  Là nơi các đối tượng khởi tạo bằng toàn tử \"new \"sẽ được lưu ở đây tại thời điểm chương trình chạy\n\n - Stak :  Các phương thức và tham chiếu tới đối tượng địa phương được lưu trữ trong Stack. Mỗi Thread quản lý một stack. Khi phương thức được gọi, nó được đưa vào đỉnh của Stack. Stack lưu trữ trạng thái của phương thức bao gồm: dòng code thực thi, tham chiếu tới đối tượng địa phương. Khi phương thức chạy xong, vùng nhớ (dòng code thực thi, tham chiếu tới đối tượng địa phương) được đẩy ra khỏi stack và tự động giải phóng.\n\n - PC register : Khi JVM thực thi mã, một thanh ghi cục bộ có tên “Program Counter” được sử dụng. Thanh ghi này trỏ tới lệnh đang thực hiện. Khi cần thiết, có thể thay đổi nội dung thanh ghi để đổi hướng thực thi của chương trình. Trong trường hợp thông thường thì từng lệnh một nối tiếp nhau sẽ được thực thi.\n\n - native method: Nơi chứa tất cả các method native trong chương trình\n - Java Perm: Lưu trữ thông tin của Class được nạp vào và một vài tính năng khác như StringPool (vùng nhớ của biến String) thường được tạo bởi phương thức String.interm(). Khi ứng dụng của bạn chạy, Perm space được lấp đầy nhanh chóng.\n```java\nVí dụ: Person person = new Person ();\nHeap: lưu đối tượng Person khi ta “new Person ();”\nStack: lưu tham chiếu “person ”.\nPerm: lưu thông tin về Class “Person ”.\n```\n\n Execution Engine:\nSau khi lưu Dữ liệu xong chương trinh JVM sẽ biên dịch file .java thành dạng file .class bytecode bằng trình biên dịch javac\n\nKhi file .class được hoàn thành chương trình tiếp tục sử dụng compiler “Just In Time-JIT”. Các trình duyệt thông dụng như Netscape hay IE đều có JIT bên trong để tăng tốc độ thực thi chương trình Java. Mục đích chính của JIT là chuyển tập lệnh bytecode thành mã máy cụ thể cho từng loại CPU. Các lệnh này sẽ được lưu trữ và sử dụng mỗi khi gọi đến.\n\n<img src=\"//daynhauhoc.s3-ap-southeast-1.amazonaws.com/original/2X/5/5128d8b76675a95fc7af49d7c6246c2cb48f643a.png\" width=\"478\" height=\"307\">\n\n3: Bởi vì các file .java đều được chuyển sang mã bytecode nên trong quá trình chạy không sợ virus có thể tấn công nên Java được coi là ngôn ngữ có độ bảo mật cao nhất hiện nay\n","__filename":"posts/15082.md","__url":"/java-virtual-machine-va-c-ch-ho-t-d-ng/","__resourceUrl":"/java-virtual-machine-va-c-ch-ho-t-d-ng/index.html","__dataUrl":"/java-virtual-machine-va-c-ch-ho-t-d-ng/index.html.f44fdad9829a18946cbea1842fe6674c.json"}